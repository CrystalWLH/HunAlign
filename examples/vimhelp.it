<p>
*usr_01.txt*	Per Vim version 7.2.
Ultima modifica: 2008 Mag 07
<p>
VIM USER MANUAL - di Bram Moolenaar 	 Traduzione di questo capitolo: Giuliano Bordonaro
<p>
Sui manuali
<p>

<p>
Questo capitolo introduce i manuali disponibili con Vim.
Leggetelo per sapere come i comandi verranno spiegati.

<p>
|01.1|	Due manuali |01.2|	A Vim installato |01.3|	Usare il tutor di Vim |01.4|	Copyright
<p>
Capitolo seguente: |usr_02.txt| I primi passi con Vim 	 Indice: |usr_toc.txt|
<p>
============================================================================== *01.1*	Due manuali
<p>
La documentazione di Vim consiste in due parti:
<p>
1.
Il manuale utente Spiegazioni orientate alle operazioni, da semplici a complesse.
Da leggere dall'inizio alla fine come un libro.

<p>
2.
Il manuale di riferimento Descrizione accurata di come funzioni ogni cosa in Vim.

<p>
La notazione usata in questi manuali viene spiegata qui: |notation|
<p>

<p>
SALTANDO QUA E LA'
<p>
Il testo contiene iperlink tra le due parti, che vi consentono di saltare velocemente tra la descrizione di un'operazione di modifica di un file ed una precisa spiegazione dei comandi ed opzioni usate per compierla.
Usate questi due comandi:
<p>
Premete CTRL-] per saltare ad un oggetto sotto il cursore.
Premete CTRL-O per tornare indietro (ripetuta va ancora indietro).

<p>
Molti link sono racchiusi tra barre verticali, come questo: |bars|.
Un nome di opzione, come 'number', un comando racchiuso entro virgolette doppie come ":write" ed ogni altra parola può venire usata come link.
Provate: Portate il cursore su CTRL-] e premete CTRL-] su di esso.

<p>
Potete trovare altri argomenti con il comando ":help", vedere |help.txt|.

<p>
============================================================================== *01.2*	A Vim installato
<p>
Ogni manuale dà per scontato che Vim sia stato installato correttamente.
Se il vostro non lo fosse fatelo adesso, o se Vim non girasse correttamente (ad es., non si trovassero i file o non venisse mostrato il menù nella GUI) prima leggete il capitolo sull'installazione: |usr_90.txt|.
*not-compatible* I manuali spesso presumono che stiate utilizzando Vim con la compatibilità Vi disattivata.
Per molti comandi ciò non è un problema, ma talvolta questo è importante, ad es., per l'undo multilivello.
Un modo semplice per accertarsi di star usando delle impostazioni gradevoli, è quello di copiare il file vimrc di esempio.
Per fare ciò dall'interno di Vim non è necessario controllare dove esso si trovi.
Come farlo dipende dal sistema che state usando:
<p>
Unix: > 	:!cp -i $VIMRUNTIME/vimrc_example.vim ~/.vimrc MS-DOS, MS-Windows, OS/2: > 	:!copy $VIMRUNTIME/vimrc_example.vim $VIM/_vimrc Amiga: > 	:!copy $VIMRUNTIME/vimrc_example.vim $VIM/.vimrc
<p>
Se il file esiste giù probabilmente vorrete invece evitare di cambiarlo.

<p>
Adesso avviando Vim, l'opzione 'compatible' dovrebbe essere disattivata.
Potete verificarlo con questo comando: >
<p>
:set compatible?
<p>
Se viene risposto con "nocompatible" state andando bene.
Se la risposta è "compatible" avete un problema.
Dovrete riuscire a capire perché l'opzione sia ancora attiva.
Vim potrebbe non trovare il file che avete scritto.
Usate questo comando per trovarlo: >
<p>
:scriptnames
<p>
Se il vostro file non viene elencato, andate a vedere la sua collocazione ed il suo nome.
Se fosse nella lista, dovrebbe esistere un altro posto ove l'opzione 'compatible' viene nuovamente attivata.

<p>
Per ulteriori informazioni vedere |vimrc| e |compatible-default|.

<p>
Note: 	Questo manuale descrive l'uso normale di Vim.
Esiste un'alternativa 	chiamata "evim" (easy Vim).
E' ancora Vim, ma si usa in modo da farlo 	rassomigliare ad un editor basato sul mouse, come Notepad.
Rimane 	sempre in Insert mode, così appare molto differente.
Non viene 	spiegato nel manuale utente, poiché dovrebbe essere autoesplicante.
Vedere |evim-keys| per i particolari.

<p>
============================================================================== *01.3*	Usare il tutor di Vim				*tutor* *vimtutor*
<p>
Invece di leggere il testo potete usare il vimtutor per apprendere i vostri primi comandi di Vim.
E' un corso di trenta minuti che insegna praticamente le funzionalità del Vim di base.

<p>
Su Unix, se Vim è stato installato correttamente, potete avviarlo dalla shell: > 	vimtutor
<p>
Su MS-Windows, lo potete trovare nel menù Programmi/Vim.
Oppure eseguite vimtutor.bat nella directory $VIMRUNTIME.

<p>
Questo farà una copia del file tutor, in modo che lo possiate modificare senza correre il rischio di danneggiare l'originale.
Ci sono poche versioni tradotte del tutor.
Per scoprire se la vostra esiste, usate il codice a due lettere dei linguaggi.
Per il francese:
<p>
vimtutor fr
<p>
In Unix, se preferite usare la versione GUI di Vim, usate "gvimtutor" o "vimtutor -g" invece che "vimtutor".

<p>
Per OpenVMS, se Vim è stato correttamente installato, potete far partire vimtutor dal prompt di VMS con:
<p>
@VIM:vimtutor
<p>
Volendo si può aggiungere il codice a due lettere dei linguaggi, come visto sopra.

<p>

<p>
Su altri sistemi dovrete fare ancora un lavoretto:
<p>
1.
Copiare il file del tutor.
Potete farlo con Vim (sa come farlo): > 	vim -u NONE -c 'e $VIMRUNTIME/tutor/tutor' -c 'w! TUTORCOPY' -c 'q' < Ciò scriverà il file "TUTORCOPY" nella directory corrente.
Per usare una versione tradotta del tutor, aggiungete al nome del file il codice a due lettere dei linguaggi.
Per il francese: > 	vim -u NONE -c 'e $VIMRUNTIME/tutor/tutor.fr' -c 'w! TUTORCOPY' -c 'q' < 2.
Modificate il file copiato con Vim: > 	vim -u NONE -c "set nocp" TUTORCOPY < Gli argomenti extra garantiscono che Vim parta di buon umore.

<p>
3.
Cancellate il file copiato dopo avere finito con esso.
> 	del TUTORCOPY < ============================================================================== *01.4*	Copyright					*manual-copyright*
<p>
Il manuale utente di Vim ed il manuale di riferimento sono protetti da Copyright (c) 1988-2003 di Bram Moolenaar.
Questo materiale può essere distribuito soltanto sotto i termini e condizioni esposti nella Open Publication License, v1.0 o successiva.
L'ultima versione è attualmente disponibile presso:
<p>
http://www.opencontent.org/openpub/
<p>
Chi intenda contribuire ai manuali deve accettare le disposizioni del precedente copyright.
*frombook* Parti del manuale utente provengono dal libro "Vi IMproved - Vim" di Steve Oualline (pubblicato a cura di New Riders Publishing, ISBN: 0735710015).
Questo libro è soggetto alla Open Publication License.
Solo determinate parti sono state incluse e queste sono state modificate (ad es., rimuovendo le figure, aggiornando il testo per Vim 6.0 e versioni successive e correggendo gli errori).
L'omissione del tag |frombook| non significa che il testo non provenga dal libro.

<p>
Grazie a Steve Oualline ed ai New Riders per avere creato e pubblicato questo libro sotto la OPL! E' stato un grande aiuto per scrivere il manuale utente.
Non soltanto per avere fornito il testo, ma anche per avere impostato tono e stile.

<p>
Se guadagnerete vendendo i manuali, siete fortemente invitati a donare parte del profitto per aiutare le vittime dell'AIDS in Uganda.
Vedere |iccf|.
<p>
==============================================================================
<p>
Capitolo seguente: |usr_02.txt| I primi passi con Vim
<p>
Copyright: vedere |manual-copyright| vim:tw=78:ts=8:ft=help:norl:
<p>
Per segnalazioni scrivere a vimdoc.it at gmail dot com oppure ad Antonio Colombo azc100 at gmail dot com *usr_02.txt*	Per Vim version 7.2.
Ultima modifica: 2007 Feb 28
<p>
VIM USER MANUAL - di Bram Moolenaar 	 Traduzione di questo capitolo: Giuliano Bordonaro
<p>
I primi passi con Vim
<p>

<p>
Questo capitolo fornisce qualche sommaria informazione per scrivere un file con Vim.
Non bene od alla svelta, ma potete scrivere.
Dedicate un po' di tempo ad impratichirvi con questi comandi, essi sono la base per quanto segue.
<p>
|02.1|	Avviare Vim la prima volta |02.2|	Inserire del testo |02.3|	Spostarsi attraverso il file |02.4|	La cancellazione di caratteri |02.5|	Undo e Redo |02.6|	Altri comandi |02.7|	Come uscire |02.8|	Trovare un aiuto Capitolo seguente: |usr_03.txt| Muoversi nel file Capitolo precedente: |usr_01.txt| Sui manuali 	 Indice: |usr_toc.txt|
<p>
============================================================================== *02.1*	Avviare Vim la prima volta
<p>
Per avviare Vim, usate questo comando: >
<p>
gvim file.txt
<p>
In UNIX potete scriverlo in ogni prompt di comando.
Se usaste Microsoft Windows, aprite una finestra MS-DOS e digitate il comando.
In ogni caso, Vim viene avviato aprendo un file chiamato file.txt.
Se questo fosse un file nuovo otterreste una finestra vuota.
La vostra schermata apparirebbe così:
<p>
+---------------------------------------+ 	|#					| 	|~					| 	|~					| 	|~					| 	|~					| 	|"file.txt" [New file]			| 	+---------------------------------------+ 		('#" è la posizione del cursore.) Le linee che iniziano con una tilde (~) indicano di non far parte del file.
In altre parole, quando Vim va oltre la fine del file mostra le linee con la tilde.
In fondo allo schermo una linea di messaggio informa che il file si chiama file.txt ed indica che voi state creando un file nuovo.
Il messaggio informativo è temporaneo ed informazioni successive lo sovrascrivono.

<p>

<p>
IL COMANDO VIM
<p>
Il comando gvim fa sì che l'editor apra una nuova finestra in cui scrivere.

<p>
Se invece usate questo comando: >
<p>
vim file.txt
<p>
lavorerete entro la vostra finestra di comando.
In altre parole, se lavorate entro un xterm, l'editor impiegherà la vostra finestra di xterm.
Se state usando una finestra di comando MS-DOS sotto Microsoft Windows, lavorerete entro questa finestra.
Il testo entro la finestra sarà identico in entrambe le versioni, ma con gvim vi sono altre e maggiori possibilità, come una barra di menù.
Maggiori informazioni più avanti.
<p>
============================================================================== *02.2*	Inserire del testo
<p>
L'editor Vim è un editor modale.
Ciò significa che si comporterà diversamente a seconda del modo in cui vi trovate.
I due modi principali si chiamano Normal mode ed Insert mode.
In Normal mode i caratteri che scrivete sono comandi.
In Insert mode gli stessi caratteri vengono inseriti come testo.
Vim viene avviato in Normal mode.
Per passare all'Insert mode inserite il comando "i" (i sta per Insert).
Poi potrete scrivere del testo.
Esso verrà inserito entro il file.
Non preoccupatevi di aver commesso degli errori; potrete correggerli dopo. Per scrivere la seguente canzoncina del programmatore, dovete digitare quanto segue: >
<p>
iA very intelligent turtle 	Found programming UNIX a hurdle
<p>
Dopo aver scritto "turtle" premete il tasto <Enter> per iniziare una nuova linea.
In ultimo premete il tasto <Esc> per uscire dall'Insert mode e tornare al Normal mode.
Ora ci saranno due linee di testo nella vostra finestra di Vim:
<p>
+---------------------------------------+ 	|A very intelligent turtle		| 	|Found programming UNIX a hurdle	| 	|~					| 	|~					| 	|					| 	+---------------------------------------+
<p>

<p>
QUAL E' IL MODO?
<p>
Per sapere in quale modo vi trovate, scrivete questo comando: >
<p>
:set showmode
<p>
Potete notare che scrivendo il carattere due punti Vim sposta il cursore nell'ultima linea della finestra.
In questa linea potete digitare i comandi due punti (comandi che iniziano con il carattere due punti).
Il comando viene concluso premendo il tasto <Enter> (tutti i comandi iniziati con i due punti vengono conclusi così).
Adesso, se scrivete il comando "i", Vim farà apparire la scritta --INSERT-- alla base della finestra.
Ciò indicherà che vi trovate in Insert mode.

<p>
+---------------------------------------+ 	|A very intelligent turtle		| 	|Found programming UNIX a hurdle	| 	|~					| 	|~					| 	|-- INSERT --				| 	+---------------------------------------+
<p>
Premendo <Esc> per tornare al Normal mode l'ultima linea tornerà vuota.

<p>

<p>
SUPERARE I PROBLEMI
<p>
Uno dei problemi per il principiante di Vim è la confusione dei modi, che può avvenire dimenticando in quale modo ci si trovi o scrivendo accidentalmente un comando che cambia modo.
Per tornare nel Normal mode non c'è problema, qualunque sia il modo in cui vi troviate premete il tasto <Esc>.
Se lo premete due volte Vim vi avvertirà con un suono che siete già nel Normal mode.

<p>
============================================================================== *02.3*	Spostarsi attraverso il file
<p>
Dopo il vostro ritorno nel Normal mode, vi potete spostare usando questi tasti:
<p>
h sinistra						*hjkl* 	j giù 	k su 	l destra
<p>
A prima vista potrebbe apparire che questi comandi siano stati scelti a casaccio.
Dopo tutto, chi mai ha usato l per dire destra? Ma in realtà c'è una ragione molto valida alla base di queste scelte: lo spostamento del cursore è una delle cose più frequenti in un editor, e questi tasti si trovano in basso a destra nella tastiera.
In altre parole questi comandi si trovano dove potete scriverli più velocemente (specialmente se scrivete con dieci dita).

<p>
Note: 	Potete anche spostare il cursore usando i tasti freccia.
Se lo fate, 	comunque, dovrete rallentare la vostra velocità di digitazione per 	premerli, dovendo muovere la mano dai tasti testuali a quelli freccia.
Considerando che dovrete farlo centinaia di volte all'ora, ciò 	significa sprecare una considerevole quantità di tempo.
Inoltre ci sono tastiere che non hanno i tasti freccia, o che li 	hanno in posizioni insolite; così, conoscere l'uso dei tasti hjkl, 	aiuta in queste situazioni.
Un modo per ricordarsi di questi comandi è che h si trova a sinistra, l è a destra e j punta all'ingiù.
Visualmente: >
<p>
k 		 h l 		 j
<p>
Il modo migliore di imparare questi comandi è di usarli.
Con il comando "i" inserite alcune linee di testo.
Poi provate a spostarvi con i tasti hjkl ed ad inserire qualche parola qua e là.
Non scordate di premere <Esc> per tornare al Normal mode.
Il |vimtutor| è un altro modo piacevole per imparare con la pratica.

<p>
Per utenti giapponesi, Hiroshi Iwatani suggerisce di fare così:
<p>
Komsomolsk 			 ^ 			 | 	 Huan Ho	<--- ---> Los Angeles 	(Fiume giallo)	 | 			 v 			 Java (l'isola, non il linguaggio)
<p>
============================================================================== *02.4*	La cancellazione di caratteri
<p>
Per cancellare un carattere, spostate il cursore su di esso e premete "x".
(Questo è un retaggio dei vecchi giorni della macchina per scrivere, quando si cancellavano cose scrivendovi sopra xxxx.) Spostando il cursore all'inizio della prima riga della canzoncina e scrivendo xxxxxxx (sette x) si cancellerà "A very ".
Il risultato dovrebbe apparire così:
<p>
+---------------------------------------+ 	|intelligent turtle			| 	|Found programming UNIX a hurdle	| 	|~					| 	|~					| 	|					| 	+---------------------------------------+
<p>
Adesso si può inserire del testo nuovo, ad esempio scrivendo: >
<p>
iA young <Esc>
<p>
Ciò inizia un'inserzione (la i), scrive le parole "A young", ed esce dall'Insert mode (l'<Esc> finale).
Il risultato:
<p>
+---------------------------------------+ 	|A young intelligent turtle		| 	|Found programming UNIX a hurdle	| 	|~					| 	|~					| 	|					| 	+---------------------------------------+
<p>

<p>
CANCELLAZIONE DI UN'INTERA LINEA
<p>
Per cancellare una linea usate il comando "dd".
La linea che segue si sposterà verso l'alto a riempire il vuoto:
<p>
+---------------------------------------+ 	|Found programming UNIX a hurdle	| 	|~					| 	|~					| 	|~					| 	|					| 	+---------------------------------------+
<p>

<p>
CANCELLAZIONE DI UN "A CAPO"
<p>
In Vim potete unire assieme due linee per farle diventare una sola, ciò significa che l'interruzione di linea tra di esse è stata cancellata.
Il comando "J" fa ciò.
Prendiamo queste due linee:
<p>
A young intelligent ~ 	turtle ~
<p>
Portate il cursore sulla prima linea e premete "J":
<p>
A young intelligent turtle ~
<p>
============================================================================== *02.5*	Undo e Redo
<p>
Supponiamo che abbiate cancellato più del dovuto.
Bene, potete riscriverlo da capo, ma c'è un modo più semplice.
Il comando "u" elimina l'ultima modifica.
Osservate questa azione: dopo aver usato "dd" per cancellare la prima linea , "u" la riporta a come era originariamente.
Ancora una: Portate il cursore sulla A nella prima linea:
<p>
A young intelligent turtle ~
<p>
Ora scrivete xxxxxxx per cancellare "A young".
Rimarrà quanto segue:
<p>
intelligent turtle ~
<p>
Scrivete "u" per eliminare l'ultima cancellazione.
Poiché delete aveva rimosso la g, undo ripristina il carattere.

<p>
g intelligent turtle ~
<p>
Un ulteriore comando u ripristina il precedente carattere cancellato:
<p>
ng intelligent turtle ~
<p>
Il prossimo comando u darà la u, e così via:
<p>
ung intelligent turtle ~ 	oung intelligent turtle ~ 	young intelligent turtle ~ 	 young intelligent turtle ~ 	A young intelligent turtle ~
<p>
Note: 	Se premete "u" due volte, ed il risultato è che ottenete lo stesso 	testo, avete Vim configurato per lavorare in modo compatibile Vi.
Andate a vedere qui per correggerlo: |not-compatible|.
Questo manuale presume che stiate lavorando in "Modo Vim".
Potreste preferire l'utilizzo del vecchio modo Vi, ma dovrete 	aspettarvi alcune piccole differenze nel testo in quel caso.

<p>

<p>
REDO
<p>
Se avete impiegato il comando u troppe volte, potete premere CTRL-R (redo) per invertire il comando precedente.
In altre parole, ciò cancella la cancellazione.
Per vederlo in azione premete CTRL-R due volte.
Il carattere A e lo spazio dopo di esso spariranno:
<p>
young intelligent turtle ~
<p>
C'è una versione speciale del comando undo, il comando "U" (undo linea).
Il comando undo linea ripristina tutte le modifiche effettuate sull'ultima linea su cui avevate lavorato.
Scrivendo questo comando due volte si cancellerà il precedente "U".

<p>
A very intelligent turtle ~ 	 xxxx				Cancella very
<p>
A intelligent turtle ~ 		 xxxxxx		Cancella turtle
<p>
A intelligent ~ 					Ripristina la linea con "U" 	A very intelligent turtle ~ 					Cancella "U" usando "u" 	A intelligent ~
<p>
Il comando "U" modifica da solo, quello che il comando "u" cancella e CTRL-R rifà.
Ciò potrebbe essere un tantino confuso.
Non preoccupatevi, con un "u" e CTRL-R potrete ripristinare qualunque situazione aveste.
Più informazioni nella sezione |32.1|.
<p>
============================================================================== *02.6*	Altri comandi
<p>
Vim possiede un gran numero di comandi per modificare il testo.
Guardate |Q_in| ed oltre.
Ve ne sono alcuni usati di rado.

<p>

<p>
AGGIUNGERE IN FONDO
<p>
Il comando "i" inserisce un carattere prima del carattere sotto il cursore.
Lavora bene; ma cosa succede se volete inserirlo alla fine della linea? Per fare ciò dovete inserire il testo dopo il cursore.
Ciò si ottiene con il comando "a" (append).
Ad esempio, per cambiare la linea
<p>
and that's not saying much for the turtle.
~ in 	and that's not saying much for the turtle!!! ~
<p>
spostate il cursore sul punto alla fine della linea.
Poi scrivete "x" per cancellare il punto.
Il cursore è ora posizionato alla fine della linea sulla e di turtle.
Adesso scrivete
<p>
a!!!<Esc>
<p>
per aggiungere i tre punti esclamativi dopo la e in turtle:
<p>
and that's not saying much for the turtle!!! ~
<p>

<p>
INSERIRE UNA NUOVA LINEA
<p>
Il comando "o" crea una nuova linea vuota sotto il cursore e pone Vim nell'Insert mode.
Ora potete scrivere il testo per la nuova linea.
Supponiamo che il cursore sia da qualche parte nella prima di queste due linee:
<p>
A very intelligent turtle ~ 	Found programming UNIX a hurdle ~
<p>
Se adesso usate il comando "o" e scrivete il testo:
<p>
oThat liked using Vim<Esc>
<p>
Il risultato sarà:
<p>
A very intelligent turtle ~ 	That liked using Vim ~ 	Found programming UNIX a hurdle ~
<p>
Il comando "O" (maiuscolo) apre una linea sopra il cursore.

<p>

<p>
USARE IL NUMERO DI RIPETIZIONI
<p>
Immaginiamo di voler salire di nove linee.
Potete scrivere "kkkkkkkkk" od usare il comando "9k".
Difatti, si possono far precedere molti comandi con un numero.
Prima in questo capitolo, ad esempio avete aggiunto tre punti esclamativi alla fine di una linea scrivendo "a!!!<Esc>".
Un altro modo per farlo è di usare il comando "3a!<Esc>".
Il numero 3 dice al comando che segue di venire eseguito tre volte.
Analogamente per cancellare tre caratteri potete usare il comando "3x".
Il numero deve venire prima del comando che deve essere eseguito.

<p>
============================================================================== *02.7*	Come uscire
<p>
Per uscire usate il comando "ZZ".
Questo comando scrive il file ed esce.
<p>
Note: 	Diversamente da molti altri editor, Vim non farà automaticamente un 	file di backup.
Se scrivete "ZZ", le vostre modifiche verranno 	sovrascritte e non potrete più tornare indietro.
Potete configurare 	Vim per generare un file di backup, vedete |07.4|.

<p>

<p>
ABBANDONARE LE MODIFICHE
<p>
Sovente farete un sacco di modifiche per poi capire improvvisamente di aver fatto qualcosa di diverso da quanto volevate.
Nulla di preoccupante; Vim ha un comando esci-e-getta-via-tutto.
Si tratta di:
<p>
:q!
<p>
Non scordatevi di premere <Enter> per ultimare il comando.

<p>
Per coloro che fossero interessati ai particolari, le tre parti di questo comando sono i due punti (:), che fa entrare in modo Command-line; il comando q che effettua la chiusura dell'editor; ed il modificatore di comando ignora (!).
Il comando ignora è necessario poiché Vim non vorrebbe ignorare le modifiche.
Se scriveste soltanto ":q", Vim mostrerebbe un messaggio di errore e rifiuterebbe di uscire:
<p>
E37: Non salvato dopo modifica (aggiungi ! per eseguire comunque)"
<p>
Specificando di ignorare, state effettivamente dicendo a Vim, "Lo so che ciò che sto facendo sembra stupido, ma io sono adulto e voglio davvero fare questo."
<p>
Se voleste continuare a lavorare sul file con Vim: il comando ":e!" ricaricherebbe la versione originale del file.

<p>
============================================================================== *02.8*	Trovare un aiuto
<p>
Tutto ciò che vorreste sapere può essere trovato nei file di help di Vim.
Non esitate a chiedere! Per avere un aiuto generico usate questo comando:
<p>
:help
<p>
Si può usare il primo tasto di funzione <F1>.
Se la vostra tastiera avesse un tasto <Help> questo potrebbe funzionare altrettanto bene.
Se non gli fornite un argomento, ":help" mostra la finestra generica di aiuto.
I creatori di Vim hanno fatto qualcosa di molto astuto (o pigro) con il sistema di help: hanno fatto la finestra di help come una normale finestra di editing.
Potete usare tutti i comandi normali di Vim per navigare attraverso le informazioni di help.
Comunque h, j, k, e l operano uno spostamento del cursore verso sinistra, giù, su e destra.
Per uscire dalla finestra di help, usate lo stesso comando che usereste per uscire dall'editor: "ZZ".
Si chiuderà solo la finestra di help, non Vim.
<p>
Leggendo il testo di aiuto, noterete del testo racchiuso entro barre verticali (ad esempio, |help|).
Ciò indica un iperlink.
Se posizionate il cursore tra le barre e premete CTRL-] (salta al tag), il sistema di help vi darà l'oggetto indicato.
(Per ragioni non discusse qui, la terminologia di Vim per un iperlink è tag.
Così CTRL-] salta alla posizione del tag indicato dalla parola sotto il cursore.) Dopo pochi passi, potreste voler tornare indietro.
CTRL-T (pop tag) ritorna alla posizione precedente.
Lavora bene anche CTRL-O (salta alla posizione più vecchia).
Alla sommità dello schermo di help, c'è la nota *help.txt*.
Questo nome tra caratteri "*" viene usata dal sistema di help per definire un tag (destinazione dell'iperlink).
Vedere |29.1| circa i particolari per l'uso dei tag.

<p>
Per avere aiuto su un oggetto dato, usate il comando seguente:
<p>
:help {subject}
<p>
Per ottenere aiuto sul comando "x", ad esempio, scrivete quanto segue:
<p>
:help x
<p>
Per scoprire come cancellare del testo, usate questo comando:
<p>
:help deleting
<p>
Per avere un completo indice dei comandi di Vim, usate il comando seguente:
<p>
:help index
<p>
Se vi servisse aiuto per un comando a carattere di controllo (ad esempio, CTRL-A), dovete specificarlo con il prefisso "CTRL-".

<p>
:help CTRL-A
<p>
L'editor Vim ha molte modalità diverse.
Di default il sistema di help mostra i comandi in Normal-mode.
Ad esempio, il comando che segue mostra un aiuto per il comando CTRL-H in Normal mode: >
<p>
:help CTRL-H
<p>
Per identificare gli altri modi, utilizzate un prefisso di modo.
Se volete un aiuto per la versione Insert-mode di un comando, usate "i_".
Per CTRL-H ciò vi fornisce il comando che segue:
<p>
:help i_CTRL-H
<p>
Avviando l'editor Vim, potete usare molti argomenti a linea di comando.
Tutti questi iniziano con un trattino (-).
Per trovare cosa faccia l'argomento -t, per esempio, usate il comando:
<p>
:help -t
<p>
L'editor Vim possiede un certo numero di opzioni che vi consentono di configurare e personalizzare l'editor.
Se voleste un aiuto per qualche opzione, dovete racchiuderla tra due virgolette singole.
Per ottenere informazioni su cosa faccia l'opzione 'number', ad esempio, usate il seguente comando:
<p>
:help 'number'
<p>
La tabella con i prefissi per tutti i modi si può trovare qui: |help-context|.

<p>
I tasti speciali sono racchiusi tra parentesi angolate.
Per ottenere aiuto sul tasto freccia in su nell'Insert mode, per esempio, usate questo comando: >
<p>
:help i_<Up>
<p>
Se vedeste un messaggio di errore che non capite, ad esempio:
<p>
E37: Non salvato dopo modifica (aggiungi ! per eseguire comunque)"
<p>
Potete usare identificativo che inizia il messaggio per ricevere aiuto a proposito del messaggio stesso: >
<p>
:help E37
<p>

<p>
Sommario: 					*help-summary* > 	:help <		Dà un aiuto molto generale.
Se scendete, troverete una lista 		di tutti i file di help, inclusi quelli aggiunti localmente, 		(ovvero non inclusi nella distribuzione di Vim).
> 	:help user-toc.txt <		Indice di VIM USER MANUAL.
> 	:help :argomento <		Aiuto su un comando-Ex, ad es.
il seguente: > 	:help :help <		Aiuto su come ottenere aiuto.
> 	:help abc <		comando "abc" in modo Normal.
> 	:help CTRL-B <		CONTROL-B <C-B> in modo Normal.
> 	:help i_abc 	:help i_CTRL-B <		Come sopra, ma in modo Insert.
> 	:help v_abc 	:help v_CTRL-B <		Come sopra, ma in modo Visual.
> 	:help c_abc 	:help c_CTRL-B <		Come sopra, ma in modo Command-line.
> 	:help 'argomento' <		Opzione 'argomento'.
> 	:help argomento() <		Funzione "argomento".
> 	:help -argomento <		Opzione della Command-line "-argomento".
> 	:help +argomento <		Caratteristica scelta in compilazione "+argomento".
> 	:help NomeEvento <		Evento di autocomando "NomeEvento".
> 	:help digraphs.txt <		L'inizio del file di help "digraph.txt".
Lo stesso vale per ogni altro file di help.
> 	:help modello<Tab> <		Cerca una tag di aiuto che inizia con "modello".
Ripetere 		<Tab> per vedere ulteriori tag.
> 	:help modello<Ctrl-D> <		Vedere tutte le tag di help possibili che corrispondono a 		"modello" contemporaneamente.
> 	:helpgrep espressione <		Cercare in tutto il testo di tutti i file di help 		l'espressione "espressione".
Saltare alla prima 		corrispondenza.
Passate ad altre corrispondenze con: > 	 :cn <			prossima corrispondenza > 	 :cprev 	 :cN <			precedente corrispondenza > 	 :cfirst 	 :clast <			prima o ultima corrispondenza > 	 :copen 	 :cclose <			aprire/chiudere la finestra quickfix; premere <Enter> 			per saltare all'elemento sotto il cursore
<p>

<p>
==============================================================================
<p>
Capitolo seguente: |usr_03.txt| Muoversi nel file Copyright: vedere |manual-copyright| vim:tw=78:ts=8:ft=help:norl:
<p>
Per segnalazioni scrivere a vimdoc.it at gmail dot com oppure ad Antonio Colombo azc100 at gmail dot com *usr_03.txt*	Per Vim version 7.2.
Ultima modifica: 2006 Giu 21
<p>
VIM USER MANUAL - di Bram Moolenaar 	 Traduzione di questo capitolo: Bartolomeo Ravera
<p>
Muoversi nel file
<p>

<p>
Prima di inserire o cancellare del testo, il cursore deve essere portato sul punto giusto.
Vim ha un grande numero di comandi per posizionare il cursore.
Questo capitolo vi mostrerà come usare quelli principali.
Potete trovare una lista di questi comandi in |Q_lr|.
<p>
|03.1|	Movimenti di parola |03.2|	Spostarsi all'inizio o alla fine di una riga |03.3|	Spostarsi verso un carattere |03.4|	Spostarsi sulla parentesi corrispondente |03.5|	Spostarsi sulla linea desiderata |03.6|	Sapere dove siete |03.7|	Paginazione |03.8|	Ricerche semplici |03.9|	Modelli semplici di ricerca |03.10|	Marcare il testo
<p>
Capitolo seguente: |usr_04.txt| Fare piccole modifiche Capitolo precedente: |usr_02.txt| I primi passi con Vim 	 Indice: |usr_toc.txt|
<p>
============================================================================== *03.1*	Movimenti di parola
<p>
Per muovere il cursore avanti di una parola, usate il comando "w".
Come molti comandi di Vim, potete usare un prefisso numerico per muovervi di più parole.
Per esempio, "3w" muove avanti di tre parole.
Questa figura mostra come questo accada:
<p>
Questa è una linea di esempio~ 	 ----->->------------> 	 w w 3w
<p>
Notate che se il cursore è già all'inizio di una parola, "w" muove all'inizio della parola seguente.
Il comando "b" muove indietro all'inizio della parola precedente:
<p>
Questa è una linea di esempio ~ 	<------<-<---------<--<--- 	 b b 2b b b
<p>
C'è anche il comando "e" che muove alla fine della parola seguente, e "ge" che muove alla fine della parola precedente:
<p>
Questa è una linea di esempio ~ 	 <- <---- ---> ----> 	 ge ge e e
<p>
Se siete posizionati sull'ultima parola di una linea, il comando "w" vi porterà alla prima parola della riga seguente.
Potete usare "w" per spostarvi all'interno di un paragrafo molto più rapidamente che usando "l".
"b" si comporta allo stesso modo, ma in direzione opposta.

<p>
Una parola termina al primo carattere che non ricorre in una parola, ad esempio ".", "-" oppure ")".
Per modificare la lista dei caratteri che fanno parte di una parola, si veda l'opzione 'iskeyword'.
E' anche possibile muoversi fra PAROLE (WORDS) separate da spazi bianchi.
Queste non sono parole nel senso di cui prima.
In questo caso si usano le lettere maiuscole.
Guardate il seguente esempio:
<p>
ge b w 				 e 	 <--- <- --->			 -----> Questa è-una linea, con parole/separate/stranamente (e altro ancora).
~ <------ <------ -------------------------> ------> gE B		 W			 E
<p>
Con questi vari comandi minuscoli e maiuscoli, potete muovervi rapidamente avanti e indietro all'interno di un paragrafo.

<p>
============================================================================== *03.2*	Spostarsi all'inizio o alla fine di una riga
<p>
Il comando "$" sposta il cursore alla fine della linea.
Se la vostra tastiera ha un tasto <Fine>, premendolo otterrete lo stesso effetto.

<p>
Il comando "^" muove il cursore al primo carattere non-blank della linea.
Il comando "0" (zero) muove esattamente al primo carattere della linea.
Il tasto <Home> fa la stessa cosa.
In una immagine:
<p>
^ 	 <--------- 	.....Questa è una linea di esempio~ 	<-------------- ------------> 		0		 $
<p>
(i puntini "....." in questo esempio indicano degli spazi)
<p>
Il comando "$" può essere preceduto da un numero, come molti comandi di movimento.
Poiché muoversi più volte alla fine della linea non ha senso, l'editor muoverà il cursore alla fine di un'altra linea.
Per esempio, "1$" vi sposterà alla fine della prima linea, (quella dove siete), "2$" alla fine della linea seguente, e così via.
Il comando "0" non può essere preceduto da alcun numero, perché lo "0" farebbe parte del numero.
Contrariamente alle aspettative, l'uso di un numero davanti a "^" non ha alcun effetto.

<p>
============================================================================== *03.3*	Spostarsi verso un carattere
<p>
Uno dei più utili comandi di movimento è il comando di ricerca di un singolo carattere.
Il comando "fx" cerca avanti nella linea la prima occorrenza del carattere x.
Suggerimento: "f" sta per "Find", ovvero "Cerca" in inglese.
Supponiamo che nel seguente esempio vogliate andare verso la u della parola umano.
Eseguendo il comando "fu" il cursore sarà posizionato sopra la u:
<p>
Errare è umano.
Per fare un vero disastro ci vuole un computer.
~ 	--------->-----------------------------------------------> 	 fu	 fp
<p>
Nello stesso esempio, il comando "fp" vi sposta al centro della parola computer.
Potete specificare un numero; in questo modo, potete ad esempio andare alla "o" di "disastro" con "3fo":
<p>
Errare è umano.
Per fare un vero disastro ci vuole un computer.
~ 		 ------------------------------> 			 3fo
<p>
Il comando "F" cerca verso sinistra:
<p>
Errare è umano.
Per fare un vero disastro ci vuole un computer.
~ 		 <--------------------- 			 Fm
<p>
Il comando "tx" lavora allo stesso modo di "fx", ad eccezione del fatto che si ferma un carattere prima del carattere ricercato.
Suggerimento: "t" sta per "To", ovvero "Verso" in inglese.
Per andare a ritroso usare "Tx".
<p>
Errare è umano.
Per fare un vero disastro ci vuole un computer.
~ 		 <----------- ---------------------> 			Tm		 tl
<p>
Questi quattro comandi possono essere ripetuti con ";".
"," ripete nella direzione opposta.
Il cursore non è mai spostato su un'altra linea.
Neppure quando la frase continua.
<p>
% 			 <-----> 		if (a == (b * c) / d) ~ 		 <----------------> 		 	 %
<p>
Questo funziona anche con le parentesi [] e {}.
(Questa lista si può modificare con l'opzione 'matchpairs').

<p>
Quando il cursore non è su un carattere adatto, "%" cercherà in avanti per trovarne uno.
Così se il cursore si trova all'inizio della linea del precedente esempio, "%" cercherà avanti e troverà il primo "(".
Poi muoverà il cursore alla parentesi corrispondente:
<p>
if (a == (b * c) / d) ~ 		---+----------------> 			 %
<p>
============================================================================== *03.5*	Spostarsi sulla linea desiderata
<p>
Se siete un programmatore C o C++, avrete già visto un messaggio di errore simile al seguente:
<p>
prog.c:33: j undeclared (first use in this function) ~
<p>
Questo vi dice che dovete correggere qualcosa alla riga 33.
Come trovare la linea 33? Un metodo è quello di digitare "9999k" per andare all'inizio del file, e poi "32j" per muovervi verso il basso di 32 linee.
Non è il massimo, ma funziona.
E' comunque meglio usare il comando "G".
Associato a un numero, questo comando vi posiziona sulla linea specificata dal numero.
Per esempio, "33G" vi sposta sulla linea numero 33.
(Per un metodo migliore per scandire la lista degli errori di compilazione, si veda |usr_30.txt|, che contiene informazioni sul comando :make).
Se usato senza argomenti, il comando "G" vi posiziona alla fine del file.
Un metodo veloce per andare all'inizio del file è usare "gg".
"1G" si comporta allo stesso modo, ma bisogna premere qualche tasto in più.

<p>
|	prima linea di un file ^ 	 |	testo testo testo testo | 	 |	testo testo testo testo | gg 	7G |	testo testo testo testo | 	 |	testo testo testo testo 	 |	testo testo testo testo 	 V	testo testo testo testo | 		testo testo testo testo | G 		testo testo testo testo | 		ultima linea di un file V
<p>
Un altro modo per muoversi verso una linea è usare il comando % con un numero.
Per esempio "50%" muove alla metà (50 %) del file.
"90%" muove verso la fine del file.

<p>
I comandi precedenti presumono che vogliate muovervi verso una linea del file, e non importa se la linea è presente sulla schermata o no.
Cosa fare se volete muovervi su una delle linee che vedete? Questa figura vi mostra tre comandi che potete utilizzare:
<p>
+---------------------------+ 		H -->	| testo esempio testo	 | 			| esempio testo		 | 			| testo esempio testo	 | 			| esempio testo		 | 		M -->	| testo esempio testo	 | 			| esempio testo		 | 			| testo esempio testo	 | 			| esempio testo		 | 		L -->	| testo esempio testo	 | 			+---------------------------+
<p>
Suggerimento: "H" sta per "Home" (in questo caso "in Alto"), "M" per "Middle" ("in Mezzo") e "L" per "Last" (in questo caso "in Basso").

<p>
============================================================================== *03.6*	Sapere dove siete
<p>
Per vedere dove siete in un file, ci sono tre metodi:
<p>
1.
Usare il comando CTRL-G.
Ottenete un messaggio come questo (assumendo che l'opzione 'ruler' non sia attiva):
<p>
"usr_03.txt" linea 233 di 650 --35%-- col 45-52 ~
<p>
Questo messaggio mostra il nome del file che state editando, il numero di linea dove si trova il cursore, il numero totale delle linee, in che posizione percentuale siete rispetto a tutto il file e la colonna su cui è posizionato il cursore.
A volte potreste vedere un doppio numero di colonna.
Per esempio, "col 2-9".
Questo indica che il cursore è posizionato sul secondo carattere, ma poiché il primo carattere è una tabulazione, che occupa otto spazi, la colonna sullo schermo è la 9.

<p>
2.
Attivare l'opzione 'number'.
Sarà visualizzato il numero della riga davanti a ogni riga: >
<p>
:set number < Per disattivare questa opzione: >
<p>
:set nonumber < Poiché 'number' è una opzione binaria, premettendo un "no" all'opzione si ottiene la sua disattivazione.
Una opzione binaria ha solo due valori: on e off.
Vim ha molte opzioni.
Oltre a quelle binarie, ci sono opzioni con valore numerico e stringhe.
Si vedranno altri esempi di opzione dove tornerà utile usarle.

<p>
3.
Attivare l'opzione 'ruler'.
Sarà visualizzata la posizione del cursore nell'angolo in basso a destra della finestra di Vim: >
<p>
:set ruler
<p>
L'uso dell'opzione 'ruler' ha il vantaggio di non occupare molto spazio, cosicché c'è più spazio per il vostro testo.

<p>
============================================================================== *03.7*	Paginazione
<p>
Il comando CTRL-U fa "scendere" una mezza schermata di testo.
Pensate di guardare il testo attraverso una finestra, e di spostare questa finestra verso l'alto, per una altezza pari a metà della altezza della finestra.
In questo modo la finestra di sposta all'insù, verso il testo che si trova più indietro nel file.
Non preoccupatevi se fate fatica a ricordare quale parte è più in alto.
Succede così alla maggior parte degli utilizzatori.
Il comando CTRL-D sposta la finestra di visualizzazione verso il basso, e quindi sposta il vostro testo verso l'alto di una mezza schermata.

<p>
+----------------+ 				 | del testo	| 				 | del testo	| 				 | del testo	| 	+---------------+	 | del testo	| 	| del testo	| CTRL-U --> |		| 	|		|	 | 123456		| 	| 123456	|	 +----------------+ 	| 7890		| 	|		|	 +----------------+ 	| esempio	| CTRL-D --> | 7890		| 	+---------------+	 |		| 				 | esempio	| 				 | esempio	| 				 | esempio	| 				 | esempio	| 				 +----------------+
<p>
Per scendere di una linea per volta usate CTRL-E (pagina all'insù) e CTRL-Y (pagina all'ingiù).
Pensate a CTRL-E come il modo per vedere una linea Extra.
(Se utilizzate una mappatura dei tasti simile a MS-Windows, CTRL-Y serve per rifare una modifica (REDO), invece che per paginare).

<p>
Per andare in avanti di una intera schermata (meno un paio di linee), usate CTRL-F.
Nella direzione opposta, il comando da usare è CTRL-B.
Fortunatamente [...per gli inglesi] CTRL-F va "Forward" (in avanti), e CTRL-B va "Backward" (all'indietro).

<p>
Una situazione comune è che dopo esservi mossi all'ingiù di parecchie linee con "j", il vostro cursore è in fondo allo schermo.
Se volete vedere nel suo contesto la linea dove si trova il cursore, basta usare il comando "zz".

<p>
+------------------+		 +------------------+ 	| del testo	 |		 | del testo	 | 	| del testo	 |		 | del testo	 | 	| del testo	 |		 | del testo	 | 	| del testo	 | zz -->	 | linea con cursore| 	| del testo	 |		 | del testo	 | 	| del testo	 |		 | del testo	 | 	| linea con cursore|		 | del testo	 | 	+------------------+		 +------------------+
<p>
Il comando "zt" porta la linea su cui si trova il cursore in cima ("top") allo schermo, "zb" la posta a fondo schermata ("bottom").
Ci sono alcuni altri comandi per paginare, si veda |Q_sc|.
Per lasciare sempre alcune linee di contesto visibili attorno alla linea del cursore, usate l'opzione 'scrolloff'.

<p>
============================================================================== *03.8*	Ricerche semplici
<p>
Per cercare una stringa, si usa il comando "/stringa".
Per trovare la parola include, per esempio, usate il comando: >
<p>
/include
<p>
Potete notare che quando digitate "/" il cursore salta all'ultima linea della finestra di Vim, come quando usate il comando due punti.
Su questa riga digiterete la parola da ricercare.
Potete premere il tasto backspace ("freccia all'indietro" o <BS>) per fare delle correzioni.
Usate i tasti cursore <Left> ("freccia sinistra") e <Right> ("freccia destra") se necessario.
Il comando viene eseguito quando premete <Invio>.

<p>
Note: 	I caratteri .*[]^%/\?~$ hanno un significato speciale.
Se volete 	usarli come caratteri in una ricerca, dovete premettere una \ 	davanti ad essi.
Vedere più sotto.
<p>
Per trovare l'occorrenza successiva della stessa stringa si usa il comando "n".
Per trovare il successivo #include dopo il cursore usare: >
<p>
/#include
<p>
E poi digitare "n" diverse volte.
Raggiungerete ogni #include nel testo.
Potete anche usare un numero se sapete verso quale occorrenza spostarvi.
Così "3n" cerca la terza occorrenza. L'uso di un contatore con "/" non funziona.
<p>
Il comando "?" ha la stessa funzione di "/", ma ricerca all'indietro:
<p>
?parola
<p>
Il comando "N" ripete l'ultima ricerca nell'opposta direzione.
Così "N" dopo un comando "/" cerca all'indietro, "N" dopo "?" cerca in avanti.

<p>

<p>
IGNORARE IL MINUSCOLO/MAIUSCOLO
<p>
Normalmente dovete digitare esattamente quello che volete cercare.
Se non vi interessa distinguere le maiuscole dalle minuscole in una parola, impostate l'opzione 'ignorecase': >
<p>
:set ignorecase
<p>
Se ora cercate "parola", troverete sia "Parola" che "PAROLA".
Per tornare all'impostazione precedente: >
<p>
:set noignorecase
<p>

<p>
CRONOLOGIA
<p>
Supponiamo che abbiate fatto queste tre ricerche: >
<p>
/uno 	/due 	/tre
<p>
Ora iniziate una ricerca con un semplice "/", senza premere <Invio>.
Se premete <Up> (tasto "freccia in su"), Vim mette "/tre" sulla linea di comando.
A questo punto, premendo <Invio> cerca tre.
Se non premete <Invio>, ma nuovamente <Up>, Vim cambia il prompt in "/due".
Se premete ancora <Up> ottenete "/uno".
Potete ovviamente anche usare il tasto cursore <Down> ("freccia in giù") per muovervi attraverso la cronologia dei comandi di ricerca nell'altra direzione.

<p>
Se sapete come inizia una precedente espressione di ricerca che avete usato, e volete utilizzarlo nuovamente, potete inserire tale lettera prima di premere <Up>.
Nel precedente esempio, potete digitare "/u<Up>" e Vim metterà "/uno" sulla linea di comando.

<p>
I comandi che iniziano con ":" hanno anch'essi una cronologia.
Ciò vi permette di richiamare un precedente comando e di eseguirlo nuovamente.
Queste due cronologie sono separate.

<p>

<p>
RICERCA DI UNA PAROLA NEL TESTO
<p>
Supponiamo di vedere la parola "FunzioneConNomeLungo" nel testo e di voler cercare la prossima occorrenza di tale parola.
Potete digitare "/FunzioneConNomeLungo", ma dovete scrivere molto.
C'è un metodo più semplice: posizionare il cursore sulla parola e usare il comando "*".
Vim cattura la parola sotto il cursore e la usa come stringa di ricerca.
Il comando "#" fa la stessa cosa nell'altra direzione.
Potete premettere un numero: "3*" cerca la terza occorrenza della parola sotto il cursore.

<p>

<p>
RICERCA DI PAROLE INTERE
<p>
Se digitate "/sono" trovate anche "sonoro".
Per trovare solamente le parole che finiscono con "sono" digitate: >
<p>
/sono\>
<p>
La voce "\>" è una speciale marcatura che indica la fine di una parola.
Similmente "\<" indica l'inizio di una parola.
Così per cercare esattamente la parola "sono" si usa: >
<p>
/\<sono\>
<p>
Questo non trova "sonoro" o "consono".
Notate che i comandi "*" e "#" usano questi marcatori di fine-parola e inizio-parola per cercare unicamente le parole complete (si possono usare "g*" e "g#" per trovare parole parziali).

<p>

<p>
EVIDENZIARE I RISULTATI DELLE RICERCHE
<p>
Immaginiamo di editare un programma e di vedere una variabile chiamata "nr", e di voler controllare dove è usata.
Potete posizionare il cursore su "nr" e usare il comando "*" e poi premere "n" per visualizzare tutte le corrispondenze.
C'è un altro metodo.
Digitate questo comando: >
<p>
:set hlsearch
<p>
Se ora ricercate "nr", Vim evidenzierà tutte le corrispondenze.
Questo è un ottimo metodo per vedere dove è usata una variabile, senza dover digitare altri comandi.
Per annullare questa impostazione: >
<p>
:set nohlsearch
<p>
Ora dovrete riattivare l'impostazione se volete usarla per il prossimo comando di ricerca.
Se volete solo rimuovere l'evidenziazione, usate questo comando: > 	:nohlsearch
<p>
Questo non disattiva l'opzione, ma disabilita l'evidenziazione.
Subito dopo che avrete eseguito la ricerca, l'evidenziazione sarà usata di nuovo.
Questo vale anche per i comandi "n" e "N".

<p>

<p>
AFFINAMENTO DELLE RICERCHE
<p>
Ci sono alcune opzioni che modificano il comportamento delle ricerche.
Queste sono quelle essenziali: > 	:set incsearch
<p>
Questo fa sì che Vim visualizzi i risultati della ricerca mentre state ancora digitando.
Usate questa opzione per controllare se verrà trovata la corrispondenza che cercate.
Poi premete <Invio> per spostarvi realmente nel posto evidenziato.
Oppure digitate altre lettere per modificare la stringa di ricerca.
> 	:set nowrapscan
<p>
Questa opzione interrompe la ricerca alla fine del file.
Oppure, se state cercando all'indietro, la interrompe all'inizio del file.
L'opzione 'wrapscan' è attivata per default, e quindi le ricerche proseguono ad anello, passando dalla fine all'inizio del file (o viceversa).

<p>

<p>
INTERMEZZO
<p>
Se gradite una delle opzioni appena menzionate, e volete attivarla ogni volta che usate Vim, potete inserire il comando nel file di configurazione di Vim.
Editate il file, come menzionato in |not-compatible|.
Oppure usate questo comando per trovare dove sia tale file: >
<p>
:scriptnames
<p>
Editate il file, per esempio con: >
<p>
:edit ~/.vimrc
<p>
Poi aggiungete una linea con il comando per impostare l'opzione, esattamente come avreste fatto in Vim.
Esempio: >
<p>
Go:set hlsearch<Esc>
<p>
"G" vi posiziona alla fine del file.
"o" inizia una nuova riga, dove digitate il comando ":set".
Infine uscite dalla modalità di inserimento con <Esc>.
Ora salvate il file: >
<p>
ZZ
<p>
Se avviate nuovamente Vim, l'opzione 'hlsearch' sarà impostata.

<p>
============================================================================== *03.9*	Modelli semplici di ricerca
<p>
L'editor Vim usa delle espressioni regolari per specificare cosa si vuole cercare.
Le espressioni regolari sono un mezzo estremamente compatto e potente per specificare una espressione da cercare.
Sfortunatamente, questa potenza ha un prezzo, perché le espressioni regolari devono essere specificate con molta pignoleria...
In questa sezione menzioneremo solo le più essenziali.
Potete trovare maggiori informazioni sulle espressioni e sui comandi di ricerca nel capitolo 27 |usr_27.txt|.
Potete trovare una spiegazione esauriente qui: |pattern|.

<p>

<p>
INIZIO E FINE DI LINEA
<p>
Il carattere ^ indica l'inizio di una linea.
Ad esempio, l'espressione "include" trova la parola include ovunque sulla linea.
L'espressione "^include" invece trova la parola include solo se questa è all'inizio di una linea.
Il carattere $ indica la fine di una linea.
Così, "was$" trova la parola was solo se questa si trova alla fine di una linea.

<p>
In questa linea di esempio, sono indicate con delle "x" le posizioni dove è stata trovata la stringa "the":
<p>
the solder holding one of the chips melted and the ~ 	xxx			 xxx		 xxx
<p>
Usando "/the$" si trova soltanto:
<p>
the solder holding one of the chips melted and the ~ 						 xxx
<p>
E con "/^the" si trova soltanto:
<p>
the solder holding one of the chips melted and the ~ 	xxx
<p>
Se si prova a cercare con "/^the$", si troveranno solo le linee che consistono unicamente della parola "the".
Gli spazi bianchi in questo caso hanno importanza, quindi se una linea contiene uno spazio dopo la parola, come "the ", l'espressione non sarà trovato.

<p>

<p>
TROVARE OGNI SINGOLO CARATTERE
<p>
Al carattere .
(punto) corrisponde ogni possibile carattere.
Per esempio, l'espressione "c.m" trova una stringa in cui il primo carattere è una c, il secondo carattere è un carattere qualunque, e il terzo carattere è una m.
Esempio:
<p>
We use a computer that became the cummin winter.
~ 		 xxx		 xxx	 xxx
<p>

<p>
TROVARE CARATTERI SPECIALI
<p>
Se volete davvero trovare il carattere "." (punto), dovete "avvertire" Vim, mettendo un backslash (\) prima del punto stesso.
Se cercate "ter.", troverete questi risultati:
<p>
We use a computer that became the cummin winter.
~ 		 xxxx			 xxxx
<p>
Cercando "ter\." si trova invece solo il secondo risultato.

<p>
============================================================================== *03.10*	Marcare il testo
<p>
Quando saltate in una posizione con il comando "G", Vim ricorda la posizione occupata prima di questo salto.
Questa posizione è chiamata marcatore.
Per tornare dove eravate partiti, usate questo comando: >
<p>
``
<p>
Il carattere ` è un backtick, cioè una virgoletta singola (un accento grave).
(Sulle tastiere italiane si ottiene con "<AltGr>'" nei sistemi Linux, e con "<Alt>96" nei sistemi Windows - NdT).
Se usate lo stesso comando una seconda volta, tornerete dove eravate.
Questo perché il comando ` è un salto a se stesso, e la posizione prima del salto viene memorizzata.

<p>
Generalmente, ogni comando che muove il cursore in una linea che non sia la stessa linea di partenza, è considerato un salto.
Questo include i comandi di ricerca "/" e "n" (non importa quanto distante sia la corrispondenza), ma non le ricerche effettuate con "fx" e "tx" o i movimenti di parola "w" e "e".
Ugualmente, "j" e "k" non sono considerati un salto.
Neppure quando si usa un contatore per muovere il cursore in una posizione molto lontana.

<p>
Il comando `` salta avanti e indietro, fra due punti.
Il comando CTRL-O salta verso la precedente posizione (Suggerimento: O sta per "Older", ossia "più vecchio" in inglese).
CTRL-I salta alla posizione più recente (Suggerimento: I è immediatamente vicino a O sulla tastiera).
Considerate questa sequenza di comandi: >
<p>
33G 	/^Qui 	CTRL-O
<p>
Prima saltate alla linea 33, poi cercate una linea che inizia con "Qui".
Poi CTRL-O vi porta indietro alla linea 33.
Un altro CTRL-O vi riporta dove avete iniziato.
Se ora usate CTRL-I, tornerete nuovamente alla linea 33.
E usando un altro CTRL-I salterete alla parola "Qui" precedentemente trovata.
<p>

<p>
|	esempio testo ^	 | 	33G |	esempio testo | CTRL-O | CTRL-I 	 |	esempio testo |	 | 	 V	linea 33 testo ^	 V 	 |	esempio testo |	 | /^Qui |	esempio testo | CTRL-O | CTRL-I 	 V	Qui voi siete 	 | V 		esempio testo
<p>
Note: 	 	CTRL-I funziona allo stesso modo di <Tab>.

<p>
Il comando ":jumps" fornisce una lista delle posizioni verso le quali siete saltati.
La posizione che avete usato per ultima è segnata con ">".
<p>

<p>
MARCATORI CON NOME						*bookmark*
<p>
Vim vi permette di posizionare i vostri personali marcatori nel testo.
Il comando "ma" marca la posizione sotto il cursore come il marcatore a.
Potete posizionare 26 marcatori (usando le lettere dalla a alla z) nel vostro testo.
Non potete vederli, sono solo posizioni che Vim memorizza.
Per andare su un marcatore, usate il comando `{marcatore}, dove con {marcatore} si intende la lettera prescelta.
Così per muoversi sul marcatore a si usa: > 	`a
<p>
Il comando 'marcatore (virgoletta semplice, o apostrofo) vi posiziona invece all'inizio della linea che contiene il marcatore.
Questa è la differenza fondamentale rispetto al comando `marcatore, il quale muove sulla colonna marcata.

<p>
I marcatori possono essere veramente utili quando si lavora su due parti collegate di un file.
Supponete di avere del testo che dovete avere sott'occhio vicino all'inizio del file, mentre state lavorando su del testo vicino alla fine del file.
Muovetevi all'inizio del testo e posizionate qui il marcatore i (inizio): >
<p>
mi
<p>
Poi muovetevi sul testo dove volete lavorare e posizionate qui il marcatore f (fine): >
<p>
mf
<p>
Ora potete muovervi avanti e indietro, e quando volete vedere l'inizio del file, usate questo comando per saltare lì: >
<p>
'i
<p>
Quindi potete usare '' per saltare indietro dove eravate, oppure 'f per saltare sul testo dove state lavorando alla fine.
La scelta di i per inizio ed f per fine poteva essere diversa, queste lettere sono solo più facili da ricordare.

<p>
Potete usare questo comando per ottenere una lista dei marcatori: >
<p>
:marks
<p>
Potete notare alcuni marcatori speciali.
Fra questi:
<p>
' Posizione del cursore prima di effettuare un salto 	" Posizione del cursore quando avete editato il file l'ultima volta 	[ Inizio dell'ultimo cambiamento 	] Fine dell'ultimo cambiamento
<p>
==============================================================================
<p>
Capitolo seguente: |usr_04.txt| Fare piccole modifiche
<p>
Copyright: si veda |manual-copyright| vim:tw=78:ts=8:ft=help:norl:
<p>
Per segnalazioni scrivere a vimdoc.it at gmail dot com oppure ad Antonio Colombo azc100 at gmail dot com *usr_04.txt*	Per Vim version 7.2.
Ultima modifica: 2008 Set 06
<p>
VIM USER MANUAL - di Bram Moolenaar 	 Traduzione di questo capitolo: Bartolomeo Ravera
<p>
Fare piccole modifiche
<p>

<p>
Questo capitolo mostra diversi modi di effettuare correzioni e spostare il testo.
Vi insegnerà i tre metodi di base per modificare il testo: operatore-movimento, modo Visual e oggetti di testo.

<p>
|04.1|	Operatori e spostamenti |04.2|	Cambiare il testo |04.3|	Ripetere una modifica |04.4|	Modo Visual |04.5|	Muovere il testo |04.6|	Copiare il testo |04.7|	Usare la clipboard |04.8|	Oggetti di testo |04.9|	Modo Replace |04.10|	Conclusioni
<p>
Capitolo seguente: |usr_05.txt| Configurazioni personali Capitolo precedente: |usr_03.txt| Muoversi nel file 	 Indice: |usr_toc.txt|
<p>
============================================================================== *04.1*	Operatori e spostamenti
<p>
Nel capitolo 2 avete imparato il comando "x" per cancellare un singolo carattere.
E usando un contatore: "4x" cancella quattro caratteri.
Il comando "dw" cancella una parola.
Potete ricordare il comando "w" come il comando di movimento di una parola.
In effetti, il comando "d" può essere seguito da ogni comando di movimento, e cancella dalla posizione attuale fino a quella in cui il cursore viene spostato.
Il comando "4w", per esempio, muove il cursore di 4 parole.
Il comando d4w cancella quattro parole.

<p>
To err is human.
To really foul up you need a computer.
~ 			 ------------------> 				 d4w
<p>
To err is human.
you need a computer. ~
<p>
Vim cancella solamente dalla posizione successiva a quella da cui si trova il cursore.
Questo perché Vim sa che probabilmente non volete cancellare il primo carattere di una parola.
Se usate il comando "e" per muovervi alla fine di una parola, Vim penserà che vogliate includere l'ultimo carattere:
<p>
Vim cancella soltanto sopra la posizione su cui il movimento porta il cursore.
Ciò avviene perché Vim sa che voi probabilmente non intendete cancellare il primo carattere di una parola.
Usando il comando "e" per muovere il cursore alla fine di una parola, Vim immagina che vogliate includere l'ultimo carattere:
<p>
To err is human.
you need a computer.
~ 			--------> 			 d2e
<p>
To err is human.
a computer. ~
<p>
Se il carattere che sta sotto il cursore viene incluso o no, dipende dal comando usato per muovervi verso tale carattere.
Il manuale di riferimento lo chiama comando "esclusivo" quando il carattere non è incluso, e "inclusivo" quando lo è.

<p>
Il comando "$" sposta il cursore alla fine della linea.
Il comando "d$" cancella dalla posizione del cursore sino alla fine della linea.
Questo è un movimento inclusivo, quindi l'ultimo carattere della linea è incluso nell'operazione di cancellazione:
<p>
To err is human.
a computer.
~ 		 ------------> 			 d$
<p>
To err is human ~
<p>
C'è uno schema qui: operatore-movimento.
Voi prima scrivete un comando operatore.
Per esempio, "d" è l'operatore di cancellazione.
Allora voi scrivete un comando di movimento, come "4l" o "w".
Così potete operare su qualsiasi testo su cui possiate spostarvi.
<p>
============================================================================== *04.2*	Cambiare il testo
<p>
Un altro operatore è "c", cambio.
Questo agisce come l'operatore "d", ad eccezione del fatto che vi lascia nel modo Insert.
Per esempio, "cw" cambia una parola.
O più precisamente, cancella una parola e vi pone in modo Insert.

<p>
To err is human ~ 	 -------> 	 c2wbe<Esc>
<p>
To be human ~
<p>
Questo "c2wbe<Esc>" è composto da queste parti:
<p>
c	l'operatore di cambio 	2w	sposta avanti di due parole (vengono cancellate e parte il 		modo Insert) 	be	inserisce questo testo 	<Esc>	torna in modo Normal
<p>
Se avete fatto attenzione, avrete notato qualcosa di strano: lo spazio prima di "human" non è stato cancellato.
C'è un proverbio che dice che per ogni problema esiste una risposta semplice, chiara e sbagliata.
Come in questo caso, per questo esempio relativo al comando "cw".
Questo in realtà lavora esattamente come "ce", cambia fino alla fine di una parola.
Quindi lo spazio dopo la parola non è incluso.
Questa è una eccezione che risale al vecchio Vi.
Poiché molte persone ci si sono ormai abituate questa incoerenza è rimasta in Vim.

<p>

<p>
ULTERIORI MODIFICHE
<p>
Come "dd" cancella un'intera linea, "cc" cambia un'intera linea.
Questo comando conserva il rientro esistente (aggiungendo spazi bianchi).

<p>

<p>
Esattamente come "d$" cancella fino alla fine della linea, "c$" sostituisce fino alla fine della linea.
E' come scrivere "d$" per cancellare il testo e poi usare "a" per dare inizio al modo Insert ed aggiungere nuovo testo.

<p>

<p>
SCORCIATOIE
<p>
Alcuni comandi operatore-movimento sono di così frequente uso che sono stati attribuiti loro comandi di una sola lettera:
<p>
x equivale a dl (cancella il carattere sotto il cursore) 	X equivale a dh (cancella il carattere a sinistra del cursore) 	D equivale a d$ (cancella i caratteri sino alla fine della linea) 	C equivale a c$ (sostituisce sino alla fine della linea) 	s equivale a cl (sostituisce un solo carattere) 	S equivale a cc (sostituisce un'intera linea)
<p>

<p>
DOVE POSIZIONARE IL CONTATORE
<p>
I comandi "3dw" e "d3w" cancellano tre parole.
Cercando il pelo nell'uovo, il primo comando, "3dw" cancella una parola tre volte; il comando "d3w" cancella tre parole una volta sola.
In pratica, non vi è differenza.
Potete addirittura utilizzare due contatori.
Per esempio, "3w2d" cancella due parole, ripetendo l'azione tre volte, per un totale di sei parole.
<p>

<p>
SOSTITUIRE UN CARATTERE
<p>
Il comando "r" non è un operatore.
Questo attende che digitiate un carattere, per rimpiazzare con questo il carattere sotto il cursore.
Potete ottenere lo stesso risultato con "cl" o con il comando "s", ma con "r" non dovete premere <Esc>
<p>
there is somerhing grong here ~ 	rT	 rt rw
<p>
There is something wrong here ~
<p>
Usando un contatore con "r", molti caratteri saranno rimpiazzati con lo stesso carattere.
Ad esempio:
<p>
There is something wrong here ~ 			 5rx
<p>
There is something xxxxx here ~
<p>
Per sostituire un carattere con un'interruzione di linea, usate "r<Enter>".
Ciò cancella un solo carattere ed inserisce una interruzione di linea.
Usando un conto qui solo relativo al numero di caratteri cancellati: "4r<Enter>" sostituisce quattro caratteri con una interruzione di linea.

<p>
============================================================================== *04.3*	Ripetere una modifica
<p>
Il comando "." è uno dei più semplici ma potenti comandi in Vim.
Tale comando ripete l'ultima modifica.
Ad esempio, supponete di star lavorando su un file HTML e di voler cancellare tutte le etichette <B>.
Posizionate il cursore sul primo < e cancellate <B> con il comando "df>".
Poi spostatevi su < del prossimo </B> e cancellatelo usando il comando ".".
Il comando "." esegue l'ultimo comando di modifica (in questo caso, "df>").
Per cancellare un'altra etichetta, posizionate il cursore su < e usate il comando ".".

<p>
To <B>generate</B> a table of <B>contents ~ 	f< find first < ---> 	df> delete to >	 --> 	f< find next <	 ---------> 	.
repeat df>			 ---> 	f< find next <		 -------------> 	.
repeat df>					 -->
<p>
Il comando "." funziona su ogni comando, ad eccezione di "u" (undo), CTRL-R (redo) e dei comandi che iniziano con un due punti (:).

<p>
Un altro esempio: si vuole sostituire la parola "quattro" con "cinque".
"quattro" appare diverse volte nel vostro testo.
Potete fare ciò più velocemente con questa sequenza di comandi:
<p>
/quattro<Enter>	trova la prima stringa "quattro" 	cwcinque<Esc>	cambia la parola in "cinque" 	n		trova il prossimo "quattro" 	.		ripete il cambiamento in "cinque" 	n		trova il prossimo "quattro" 	.		ripete il cambiamento 			etc.

<p>
============================================================================== *04.4*	Modo Visual
<p>
Per cancellare voci semplici le sostituzioni degli operatori di movimento funzionano abbastanza bene.
Ma spesso non è così semplice decidere quale comando vi sposti sul testo che volete cambiare.
In questo caso potete usare il modo Visual.

<p>
Accedete al modo Visual premendo "v".
Muovete il cursore sul testo su cui volete lavorare.
Mentre fate ciò, il testo viene evidenziato.
Infine digitate il comando operatore.
Per esempio, per cancellare dalla metà di una parola alla metà di un'altra parola:
<p>
This is an examination sample of Visual mode ~ 			 ----------> 				 velllld
<p>
This is an example of Visual mode ~
<p>
Facendo questo, non dovrete conoscere esattamente quante volte digitare "l" per portarvi sulla giusta posizione.
Potete immediatamente vedere la porzione di testo che sarà cancellata quando premerete "d".

<p>
Se ad un certo punto doveste decidere di non modificare il testo evidenziato, basterà premere <Esc> e il modo Visual sarà concluso senza nessun cambiamento.

<p>

<p>
SELEZIONE DI LINEE
<p>
Se volete lavorare su un'intera linea, usate "V" per attivare il modo Visual.
Potete vedere come l'intera linea venga evidenziata, senza che il cursore sia mosso.
Muovendovi verso destra o sinistra nulla cambia.
Quando vi spostate nella riga in alto o in basso, la selezione si estende alle linee interessate, nella loro interezza.
Per esempio, selezionate tre linee con "Vjj":
<p>
+------------------------+ 			 | text more text	 | 		 >> | more text more text | | linee selezionate >> | text text text	 | | Vjj 		 >> | text more		 | V 			 | more text more	 | 			 +------------------------+
<p>

<p>
SELEZIONE DI BLOCCHI
<p>
Se volete lavorare su un blocco rettangolare di caratteri, usate CTRL-V per attivare il modo Visual.
Ciò è veramente utile quando si lavora con delle tabelle.

<p>
name		Q1	Q2	Q3 		pierre		123	455	234 		john		0	90	39 		steve		392	63	334
<p>
Per cancellare la colonna "Q2" posta in mezzo, spostate il cursore sulla "Q" di "Q2".
Premete CTRL-V per attivare modo Visual con modalità a blocco.
Ora spostate il cursore tre linee in basso con "3j" e poi sulla prossima parola con "w".
Potete vedere che viene incluso anche il primo carattere dell'ultima colonna.
Per escluderlo, usate "h".
Ora premete "d" e la colonna in mezzo è a posto.
<p>

<p>
ANDARE DALL'ALTRO LATO
<p>
Se avete già selezionato del testo in modo Visual, e vi accorgete di dover fare un cambiamento dall'altra parte della selezione, usate il comando "o" (Suggerimento: "o" sta per "other", in inglese "altra" parte).
Il cursore si posizionerà dall'altra parte, e potrete muovere il cursore per cambiare dove la selezione inizia.
Premendo "o" nuovamente, sarete portati dall'altra parte.
Quando usate la selezione con modalità a blocchi, avete quattro angoli.
"o" minuscolo vi porta sull'angolo opposto, in diagonale.
Per spostarvi sull'altro angolo sulla stessa linea, si usa "O" maiuscolo.

<p>
Note: "o" e "O" in modo Visual si comportano in modo differente dal modo Normal, nel quale aprono una nuova linea sotto o sopra il cursore.

<p>
============================================================================== *04.5*	Muovere il testo
<p>
Quando cancellate qualcosa con "d", "x", o un altro comando, il testo viene memorizzato.
Potete incollarlo nuovamente usando il comando "p".
(Vim chiama ciò "put").
Osservate come questo funziona.
Prima potete cancellare un'intera linea, posizionando il cursore sulla linea che volete cancellare e digitando "dd", Ora spostate il cursore nella posizione dove volete incollare la linea e usate il comando "p" (put).
La linea verrà inserita sulla linea sotto il cursore.
<p>
una linea	una linea	una linea 	linea 2	 dd	linea 3	 p linea 3 	linea 3			 linea 2
<p>
Poiché avete cancellato un'intera linea, il comando "p" ha posizionato la linea di testo sotto il cursore.
Se cancellate parte di una linea (una parola, per esempio), il comando "p" la incollerà esattamente dopo il cursore.

<p>
Some more boring try text to out commands.
~ 			 ----> 			 dw
<p>
Some more boring text to out commands.
~ 			 -------> 			 welp
<p>
Some more boring text to try out commands.
~
<p>

<p>
ALTRO SULL'INCOLLAGGIO
<p>
Il comando "P" incolla il testo come "p", ma prima del cursore.
Quando avrete cancellato un'intera linea con "dd", "P" la incollerà prima del cursore.
Quando avrete cancellato una parola con "dw", "P" la incollerà proprio prima del cursore.

<p>
Potete ripetere l'incollatura quante volte volete.
Verrà usato sempre lo stesso testo.

<p>
Potete usare un contatore con "p" e "P".
Il testo sarà ripetuto tante volte quante ne sono state specificate con il contatore.
Così, "dd" e poi "3p" incolla tre copie della stessa linea cancellata.

<p>

<p>
SCAMBIARE DUE CARATTERI
<p>
Capita spesso che mentre si digita, le dita corrano più velocemente del cervello (o viceversa...).
Il risultato è una cosa simile a questa: "teh" invece di "the".
Vim rende più facile correggere questo tipo di problema.
Posizionate il cursore sulla "e" di "teh" ed eseguite il comando "xp".
Questo lavora in questo modo: "x" cancella il carattere e lo pone in un registro.
"p" incolla il testo dopo il cursore, che è dopo la "h".
<p>
teh th the ~ 	 x p
<p>
============================================================================== *04.6*	Copiare il testo
<p>
Per copiare del testo da un posto ad un altro, potete cancellarlo, usare "u" per annullare la cancellazione e poi usare "p" per incollarlo dove si vuole.
C'è un metodo più semplice: usare lo "yank" (in inglese: "strappare").
L'operatore "y" copia il testo in un registro.
Poi, il comando "p" può essere usato per incollarlo.
"Strappare" è solo un sinonimo che Vim usa al posto di "copiare".
Questo perché la lettera "c" era già stata usata per l'operatore di cambiamento, mentre la lettera "y" era ancora disponibile.
Chiamando questo operatore "yank", è più facile ricordare l'uso del tasto "y".

<p>
Poiché "y" è un operatore, si usa "yw" per copiare una parola.
Come al solito, è possibile usare un contatore.
Per copiare due parole, usate "y2w".
Per esempio:
<p>
let sqr = LongVariable * ~ 		 --------------> 		 y2w
<p>
let sqr = LongVariable * ~ 			 p
<p>
let sqr = LongVariable * LongVariable ~
<p>
Notate che "yw" include lo spazio bianco dopo una parola.
Se non desiderate ciò, usate "ye".

<p>
Il comando "yy" copia un'intera linea, come "dd" cancella un'intera linea.
Contrariamente alle aspettative, mentre "D" cancella dal cursore fino alla fine della linea, "Y" funziona come "yy", cioè copia l'intera linea.

<p>
a text line yy	a text line	 a text line 	line 2			line 2		p line 2 	last line		last line	 a text line 						 last line
<p>
============================================================================== *04.7*	Usare la clipboard
<p>
Se state usando la versione GUI di Vim (gvim), potete trovare la voce "Copia" nel menù "Edit".
Prima selezionate del testo con il modo Visual, poi usate il menù Modifica/Copia.
Il testo selezionato è ora stato copiato nella clipboard (clipboard=parte della memoria in cui è temporaneamente memorizzato un testo - NdT).
Potete incollare il testo in altri programmi.
Ovviamente, anche nello stesso Vim.
<p>
Se avete copiato, da un'altra applicazione, del testo nella clipboard, potete incollarlo in Vim con il menù Modifica/Incolla.
Questo funziona in modo Normal e in modo Insert.
In modo Visual il testo selezionato è sostituito con il testo incollato.

<p>
La voce "Taglia" del menù cancella il testo prima di porlo nella clipboard.
Le voci "Copia", "Taglia" e "Incolla" sono anche disponibili nel menù a discesa.

<p>
Se il vostro Vim ha una barra degli strumenti, potete trovare queste voci anche lì.

<p>
Se non state usando la GUI, oppure se non vi piace usare il menù, dovete utilizzare un altro metodo.
Usate i soliti comandi "y" (yank) e "p" (put), ma premettete loro "* (virgolette asterisco).
Per copiare una linea nella clipboard: >
<p>
"*yy
<p>
Per trasferire del testo dalla clipboard di nuovo nel testo: >
<p>
"*p
<p>
Ciò funziona solo per le versioni di Vim che includono il supporto per la clipboard.
Potete trovare maggiori informazioni sulla clipboard nella sezione |09.3| e qui: |clipboard|.

<p>
============================================================================== *04.8*	Oggetti di testo
<p>
Se il cursore è a metà di una parola che volete cancellare, dovete tornare indietro all'inizio di questa parola prima di usare il comando "dw".
Esiste un modo più rapido: "daw".

<p>
this is some example text.
~ 		 daw
<p>
this is some text.
~
<p>
La "d" di "daw" è l'operatore di cancellazione.
"aw" è un oggetto di testo.
Suggerimento: "aw" ricorda "A Word", cioè "Una Parola" in inglese.
Per la precisione, viene cancellato anche lo spazio bianco che segue la parola (e lo spazio bianco prima della parola se ci si trova alla fine della linea).

<p>
L'uso degli oggetti di testo rappresenta un terzo modo per effettuare dei cambiamenti in Vim.
C'erano già operatore-movimento e modo Visual; ora si aggiunge alla nostra lista anche l'operatore-oggetti di testo.
E' molto simile all'operatore-movimento, ma invece di operare sul testo fra la posizione del cursore prima e dopo il comando di spostamento, l'oggetto di testo è usato come un blocco.
Non importa dove si trova il cursore all'interno dell'oggetto.

<p>
Per modificare un'intera frase, usate "cis".
Considerate questo testo:
<p>
Hello there.
This ~ 	is an example.
Just ~ 	some text.
~
<p>
Spostatevi all'inizio della seconda linea, su "is an".
Ora usate "cis":
<p>
Hello there.
Just ~ 	some text.
~
<p>
Il cursore è posizionato fra gli spazi bianchi nella prima linea.
Ora digitate la nuova frase "Another line.":
<p>
Hello there.
Another line.
Just ~ 	some text. ~
<p>
"cis" è composto dall'operatore "c" (change) e dall'oggetto di testo "is".
Questo sta per "Inner Sentence", ovvero "Frase interna", "Frase in cui è il cursore".
Esiste anche l'oggetto "as" ("a sentence", "una frase").
La differenza consiste nel fatto che "as" include lo spazio bianco dopo la frase, mentre "is" non lo fa.
Se volete cancellare una frase, contemporaneamente desiderate cancellare lo spazio bianco, quindi usate "das".
Se volete digitare del nuovo testo, lo spazio bianco può rimanere, quindi usate "cis".

<p>
Potete usare oggetti di testo anche in modo Visual.
L'oggetto di testo sarà incluso nella selezione Visuale.
Il modo Visual continuerà a permanere, cosicché potete fare questa operazione diverse volte.
Per esempio, date inizio al modo Visual con "v" e selezionate una frase con "as".
Ora potete ripetere "as" per includere altre frasi.
Infine, usate un operatore per fare ciò che desiderate con le frasi selezionate.

<p>
Potete trovare una lunga lista di oggetti di testo qui: |text-objects|.

<p>
============================================================================== *04.9*	modo Replace
<p>
Il comando "R" fa entrare Vim in modo Replace.
In questa modalità, ogni carattere digitato sostituisce quello sotto il cursore.
Questo comportamento permane fino a che non si digita <Esc>.
In questo esempio, date inizio al modo Replace sulla prima "t" di "testo":
<p>
This is text.
~
<p>
Rinteresting.<Esc>
<p>
This is interesting.
~
<p>
Avrete notato come questo comando abbia sostituito 5 caratteri nella linea con altri dodici.
Il comando "R" estende automaticamente la lunghezza della linea se questa è troppo corta per contenere i caratteri da sostituire.
Non prosegue sulla linea successiva.

<p>
Potete passare alternativamente fra modo Insert e modo Replace con il tasto <Insert>.

<p>
Quando usate <BS> (backspace) per fare delle correzioni, potete notare come venga nuovamente immesso sulla riga il vecchio testo.
Ciò funziona come un comando "undo" ("annulla") per l'ultimo carattere digitato.

<p>
============================================================================== *04.10*	Conclusioni
<p>
Gli operatori, i comandi di movimento e gli oggetti di testo vi offrono la possibilità di creare molte combinazioni.
Ora che conoscete il loro funzionamento, potete usare N operatori combinati con M comandi di movimento per ottenere N * M comandi!
<p>
Potete trovare una lista di operatori qui: |operator|
<p>
Per esempio, ci sono molti altri modi per cancellare porzioni di testo.
La lista seguente ne illustra alcuni fra i più usati:
<p>
x	cancella il carattere sotto il cursore (abbreviazione per "dl") X	cancella il carattere prima del cursore (abbreviazione per "dh") D	cancella dal cursore alla fine della linea (abbreviazione per "d$") dw	cancella dal cursore all'inizio della prossima parola db	cancella dal cursore al precedente inizio di parola.
diw	cancella la parola sotto il cursore (esclusi gli spazi bianchi) daw	cancella la parola sotto il cursore (inclusi gli spazi bianchi) dG	cancella fino alla fine del file dgg	cancella fino all'inizio del file
<p>
Usando "c" invece di "d", i comandi precedenti diventeranno comandi di cambiamento.
E così via.
<p>
Ci sono poi alcuni altri comandi usati frequentemente, che non è possibile classificare facilmente:
<p>
~	cambia da maiuscolo a minuscolo (e viceversa) il carattere sotto il cursore, e sposta il cursore al prossimo carattere.
Questo non è un operatore (a meno che no sia impostato 'tildeop'), quindi non è possibile usarlo in combinazione con un comando di movimento.
Funziona in modo Visual e modifica il maiuscolo/minuscolo per tutto il testo selezionato.

<p>
I	Avvia il modo Insert dopo aver spostato il cursore al primo carattere non-blank nella linea.

<p>
A	Avvia il modo Insert dopo aver spostato il cursore alla fine della linea.

<p>
==============================================================================
<p>
Capitolo seguente: |usr_05.txt| Configurazioni personali
<p>
Per segnalazioni scrivere a vimdoc.it at gmail dot com oppure ad Antonio Colombo azc100 at gmail dot com *usr_05.txt*	Per Vim version 7.2.
Ultima modifica: 2007 Mag 11
<p>
VIM USER MANUAL - di Bram Moolenaar 		 Traduzione di questo capitolo: Ivan Morgillo
<p>
Configurazioni personali
<p>

<p>
Vim può essere personalizzato affinché funzioni come volete.
Questo capitolo vi mostra come far partire Vim con le opzioni impostate in modi differenti.
Aggiungere plugin per estendere le capacità di Vim.
O definire le vostre macro.
<p>
|05.1|	Il file vimrc |05.2|	Spiegazione del file vimrc di esempio |05.3|	Semplici mappature |05.4|	Aggiungere un plugin |05.5|	Aggiungere un file di Aiuto |05.6|	La finestra delle opzioni |05.7|	Le opzioni più usate
<p>
Capitolo seguente: |usr_06.txt| Usare l'evidenziazione della sintassi Capitolo precedente: |usr_04.txt| Fare piccole modifiche 	 Indice: |usr_toc.txt|
<p>
============================================================================== *05.1*	Il file vimrc					*vimrc-intro*
<p>
Probabilmente siete stanchi di scrivere i comandi che usate molto spesso.
Per iniziare già con tutte le vostre opzioni preferite impostate e le vostre mappature, basta che le scriviate in un file chiamato vimrc.
Vim esegue i comandi contenuti in questo file in fase di avvio.

<p>
Se già avete un file vimrc (ad es., quando il vostro amministratore di sistema ve ne ha preparato uno), potete modificarlo in questo modo: >
<p>
:edit $MYVIMRC
<p>
Se non avete già un file vimrc, guardate |vimrc| per sapere dove potete creare un file vimrc.
Anche il comando ":version" mostra il nome del file utente vimrc che Vim cerca all'avvio.

<p>
Per i sistemi Unix viene usato sempre questo file: >
<p>
~/.vimrc
<p>
Per i sistemi MS-DOS e MS-Windows di solito si usa uno di questi: >
<p>
$HOME/_vimrc 	$VIM/_vimrc
<p>
Il file vimrc può contenere tutti i comandi che voi scrivete dopo i due punti.
I più semplici sono per le impostazioni delle opzioni.
Per esempio, se volete che Vim parta sempre con l'opzione 'incsearch' attivata, aggiungete questa riga al file vimrc: >
<p>
set incsearch
<p>
Affinché questa nuova riga abbia effetto dovete riavviare Vim.
In seguito imparerete a fare questa operazione senza riavviare Vim.

<p>
Questo capitolo spiega solo la maggior parte degli elementi di base.
Per ulteriori informazioni su come scrivere un file script per Vim: |usr_41.txt|.

<p>
============================================================================== *05.2*	Spiegazione del file vimrc di esempio 		*vimrc_example.vim*
<p>
Nel primo capitolo è stato spiegato come il file vimrc di esempio (incluso nella distribuzione di Vim) possa essere usato per lanciare Vim in modalità non-compatibile (vedere |not-compatible|).
Il file può essere trovato qui:
<p>
$VIMRUNTIME/vimrc_example.vim ~
<p>
In questa sezione spiegheremo i vari comandi usati in questo file.
Questo vi darà una mano su come impostare le vostre preferenze.
Non sarà, però, spiegato tutto.
Usate il comando ":help" per sapere di più.
> 	set nocompatible
<p>
Come detto nel primo capitolo, questi manuali spiegano come Vim funziona in modo migliore, cioè non completamente compatibile con Vi.
Disabilitando 'compatible', l'opzione 'nocompatible' si occupa di ciò.

<p>
> 	set backspace=indent,eol,start
<p>
Questo specifica dove in modo Insert <BS> può cancellare il carattere che segue il cursore.
I tre oggetti, separati dalle virgole, dicono a Vim di cancellare lo spazio bianco all'inizio della riga, l'interruzione di riga e il carattere prima del punto in cui è iniziato il modo Insert.
>
<p>
set autoindent
<p>
Questo consente a Vim di usare il rientro della riga precedente per la riga appena creata.
Per esempio quando si preme <Enter> in modo Insert, e quando si usa il comando "o" per creare una nuova riga.
>
<p>
if has("vms") 	 set nobackup 	else 	 set backup 	endif
<p>
Questo dice a Vim di creare una copia di backup di un file quando lo si sovrascrive.
Ma non entro il sistema VMS, poiché esso già conserva le vecchie versioni dei file.
Il file di backup avrà lo stesso nome del file originale con aggiunto "~".
Vedere |07.4| >
<p>
set history=50
<p>
Conserva 50 comandi e 50 stringhe di ricerca nel file di history.
Impiegate un altro numero se desiderate che vengano memorizzate più o meno linee.
>
<p>
set ruler
<p>
Mostra sempre la posizione corrente del cursore nell'angolo in basso a destra della finestra di Vim.

<p>
> 	set showcmd
<p>
Mostra un comando non completo nell'angolo in basso a destra della finestra di Vim, a sinistra del regolo.
Ad es., se scriveste "2f", Vim attenderebbe che scriviate il carattere da trovare e verrebbe mostrato "2f".
Se poi scriveste "w", verrebbe eseguito il comando e rimosso il "2f".

<p>
+-------------------------------------------------+ 	|testo entro la finestra di Vim			 | 	|~						 | 	|~						 | 	|-- VISUAL --			2f 43,8 17% | 	+-------------------------------------------------+ 	 ^^^^^^^^^^^		 ^^^^^^^^ ^^^^^^^^^^ 	 'showmode'		 'showcmd'	'ruler'
<p>
> 	set incsearch
<p>
Propone una possibile corrispondenza della stringa di ricerca mentre la state scrivendo.

<p>
> 	map Q gq
<p>
Definisce una mappatura di tasti.
Troverete di più su questo argomento nella sezione che segue.
Ciò definisce il comando "Q", per formattare con l'operatore "gq".
Questo è ciò che avveniva prima di Vim 5.0.
Altrimenti il comando "Q" fa partire il modo Ex, ma ciò non vi sarà necessario.
<p>
> 	vnoremap _g y:exe "grep /" .
escape(@", '\\/') . "/ *.c *.h"<CR>
<p>
Questa mappatura copia il testo selezionato in Visual mode e lo usa come argomento di ricerca in programmi sorgenti C.
Questa è una mappatura complessa.
Notate come le mappature possano venire impiegata per fare cose piuttosto complesse.
Tuttavia, è soltanto una sequenza di comandi che vengono eseguiti come se li scriveste direttamente.

<p>
> 	if &t_Co > 2 || has("gui_running") 	 syntax on 	 set hlsearch 	endif
<p>
Rende attiva l'evidenziazione della sintassi, ma solo se i colori sono disponibili.
Inoltre l'opzione 'hlsearch' dice a Vim di evidenziare le occorrenze dell'ultima stringa di ricerca utilizzata.
Il comando "if" è utilissimo per impostare delle opzioni soltanto se viene verificata una condizione.
Di più sull'argomento in |usr_41.txt|.
<p>
*vimrc-filetype* > 	filetype plugin indent on
<p>
Questo comando avvia tre meccanismi molto intelligenti: 1.
Riconoscimento del tipo di file.
Ogni volta che iniziate a lavorare su di un file, Vim tenta di capire di che tipo di file si tratti.
Se lavorate su "main.c", Vim noterà l'estensione ".c" e concluderà che si tratta di un file del tipo "c".
Se aprite un file che inizia con "#!/bin/sh", Vim riconoscerà un file di tipo "sh".
Il riconoscimento del tipo di file viene usato sia per l'evidenziazione della sintassi che per le altre due funzioni viste prima.
Vedere |filetypes|.

<p>
2.
Utilizzare i file di plugin per il tipo di file.
Tipi di file diversi vengono elaborati con opzioni diverse.
Ad es., lavorando con un file "c", risulta utile per impostare l'opzione 'cindent' per rientrare automaticamente le linee.
Le impostazioni di queste utili opzioni vengono fornite insieme a Vim sotto forma di plugin relativi al tipo di file.
Potete aggiungerne anche dei vostri.
Vedere |write-filetype-plugin|.
<p>
3.
Utilizzo dei file di rientro Scrivendo codice il rientro di una linea può essere spesso calcolato automaticamente.
Vim viene fornito con queste regole di rientro per un certo numero di tipi di file.
Vedere |:filetype-indent-on| e 'indentexpr'.
<p>
> 	autocmd FileType text setlocal textwidth=78
<p>
Ciò fa sì che Vim interrompa il testo per evitare linee che superino la lunghezza di 78 caratteri.
Ma solo per file che vengano riconosciuti come file di puro testo.
E' composto di due parti.
"autocmd FileType text" è un autocomando.
Dispone che venga eseguito automaticamente il comando che segue se il tipo di file viene riconosciuto come "text".
"setlocal textwidth=78" imposta a 78 l'opzione 'textwidth', soltanto entro questo file locale.

<p>
*restore-cursor* > >
<p>
autocmd BufReadPost * 	 \ if line("'\"") > 0 && line("'\"") <= line("$") | 	 \ exe "normal g`\"" | 	 \ endif
<p>
Un altro autocomando.
Questa volta viene impiegato dopo l'apertura di qualunque file.
Quella roba complicata che segue verifica se sia stato definito il segnaposto '", e conseguentemente salta ad esso.
La barra inversa all'inizio di una riga serve per continuare il comando che inizia nella riga precedente.
Ciò permette di non avere linee eccessivamente lunghe.
Vedere |line-continuation|.
Funziona soltanto entro uno script di Vim e non direttamente dalla linea di comando.
<p>
============================================================================== *05.3*	Semplici mappature
<p>
Una mappatura vi consente di raggruppare una sequenza di comandi sotto un solo tasto.
Supponiamo per esempio, che dobbiate includere certe parole tra parentesi graffe.
In altre parole dovete trasformare una parola come "amount" in "{amount}".
Con il comando :map, potete dire a Vim che il tasto F5 svolge questo lavoro.
Il comando risulterà come segue: >
<p>
:map <F5> i{<Esc>ea}<Esc> < 	Note: 	Per immettere questo comando dovrete scrivere <F5>, quattro caratteri.
Analogamente, <Esc> non si inserisce schiacciando il tasto <Esc>, ma 	scrivendo cinque caratteri.
Fate caso a questa differenza mentre 	leggete il manuale!
<p>
Scomponiamo quanto sotto: <F5>	Il tasto funzione F5.
E' il segnale di avvio che fa eseguire 		il comando quando il tasto viene premuto.

<p>
i{<Esc>	Inserisce il carattere {.
Il tasto <Esc> termina il modo 		Insert.

<p>
e		Sposta il cursore alla fine della parola.

<p>
a}<Esc>	Appone la } dopo la parola.

<p>
Dopo avere realizzato il comando ":map", tutto ciò che dovete fare per immettere {} attorno ad una parola è porre il cursore sul primo carattere e premere F5.

<p>
In questo esempio il segnale di avvio è un singolo tasto; potrebbe essere una stringa di caratteri.
Ma se usaste un comando esistente di Vim il comando stesso non sarebbe più disponibile.
Meglio evitarlo.
L'unico tasto che può essere usato per eseguire una mappatura è la barra rovesciata.
Poiché certamente vorrete definire più di una sola mappatura, aggiungete un altro carattere.
Potreste mappare "\p" per aggiungere parentesi tonde attorno ad una parola e "\c" per porvi parentesi graffe, ad es.: >
<p>
:map \p i(<Esc>ea)<Esc> 	:map \c i{<Esc>ea}<Esc>
<p>
Dovrete digitare la \ e la p rapidamente in sequenza, così Vim saprà che lavorano insieme.

<p>
Il comando ":map" (senza argomenti) elenca le vostre mappature esistenti.
Almeno quelle per il modo Normal.
Altro sulle mappature nella sezione |40.1|.

<p>
============================================================================== *05.4*	Aggiungere un plugin				*add-plugin* *plugin*
<p>
Le funzionalità di Vim possono essere estese aggiungendo plugin.
Un plugin non è altro che uno script di Vim che viene caricato automaticamente all'avvio di Vim.
Potete aggiungere facilmente un plugin inserendolo nella vostra directory dei plugin.
{non disponibile se Vim è stato compilato senza la caratteristica |+eval|}
<p>
Ci sono due tipi di plugin:
<p>
plugin globali: Usati per ogni tipo di file filetype plugin: Usati solo per un tipo di file specifico
<p>
Prima parleremo dei plugin globali, poi di quelli relativi al tipo di file |add-filetype-plugin|.

<p>

<p>
PLUGIN GLOBALI						*standard-plugin*
<p>
Avviando Vim, questi caricherà automaticamente un certo numero di plugin globali.
Non siete obbligati a fare nulla per ottenere ciò.
Aggiungono funzionalità che potrebbero servire a molti, ma che sono state implementate come script di Vim anziché venir compilate entro di esso.
Le potete trovare elencate nell'indice di help |standard-plugin-list|.
Vedere anche |load-plugins|.
<p>
*add-global-plugin* Potete creare plugin globali per aggiungere funzionalità che pensate di dover usare frequentemente durante l'utilizzo di Vim.
Servono due soli passaggi per aggiungere un plugin globale: 1.
Ottenere una copia del plugin.
2. Metterlo nella directory giusta.
<p>

<p>
COME OTTENERE UN PLUGIN GLOBALE
<p>
Dove potete trovare i plugin? - Qualcuno è compreso insieme con Vim.
Lo potete trovare nella directory $VIMRUNTIME/macros e nelle sue sub-directory.
- Scaricatelo dalla rete.
Ce n'è un'ampia collezione in http://www.vim.org.
- Ne vengono inviati molti tramite la |maillist| di Vim.
- Potreste scrivervelo anche da soli, vedere |write-plugin|.
<p>

<p>
USARE UN PLUGIN GLOBALE
<p>
Prima leggete il testo entro il plugin stesso per verificare l'esistenza di qualsiasi condizione speciale.
Poi copiate il file nella vostra directory dei plugin:
<p>
system		directory dei plugin ~ 	Unix		~/.vim/plugin/ 	PC e OS/2	$HOME/vimfiles/plugin o $VIM/vimfiles/plugin 	Amiga		s:vimfiles/plugin 	Macintosh	$VIM:vimfiles:plugin 	Mac OS X	~/.vim/plugin/ 	RISC-OS		Choices:vimfiles.plugin
<p>
Esempio per Unix (nel caso non ci sia ancora le directory dei plugin): >
<p>
mkdir ~/.vim 	mkdir ~/.vim/plugin 	cp /usr/local/share/vim/vim60/macros/justify.vim ~/.vim/plugin
<p>
Tutto qui! Ora potete impiegare i comandi definiti in questo plugin per giustificare il testo.

<p>

<p>
FILETYPE PLUGIN				*add-filetype-plugin* *ftplugins*
<p>
La distribuzione di Vim prevede un certo numero di plugin per tipi di file diversi che potete avviare con il seguente comando: >
<p>
:filetype plugin on
<p>
Tutto qui! Vedere |vimrc-filetype|.

<p>
Invece di mettere plugin direttamente nella directory plugin/, potete organizzarli meglio mettendoli in sotto-directory sotto plugin/.
Ad es., potreste usare "~/.vim/plugin/perl/*.vim" per tutti i vostri plugin Perl.

<p>
Se aveste perso uno dei plugin per un tipo di file che state usando, o ne aveste trovato uno migliore, potete aggiungerlo.
Ci sono due passaggi per aggiungere un filetype plugin: 1.
Trovare una copia del plugin.
2. Copiarlo nella directory giusta.
<p>

<p>
COME TROVARE UN FILETYPE PLUGIN
<p>
Potete trovarlo negli stessi posti dei plugin globali.
Guardate se si menziona il tipo del file, così potrete sapere se il plugin sia globale o riferito al tipo del file.
Gli script in $VIMRUNTIME/macros sono tutti globali, i filetype plugin sono in $VIMRUNTIME/ftplugin.

<p>

<p>
COME USARE UN FILETYPE PLUGIN				*ftplugin-name*
<p>
Potete aggiungere un filetype plugin copiandolo nella directory giusta.
Il nome di questa directory è nella stessa directory citata prima per i plugin globali, ma l'ultima parte è "ftplugin".
Supponiamo che abbiate trovato un plugin per il tipo di file "stuff", e stiate usando un sistema Unix.
Potete spostare questo file nella directory ftplugin: >
<p>
mv thefile ~/.vim/ftplugin/stuff.vim
<p>
Se tale file esistesse già vorrebbe dire che avete già un plugin per "stuff".
Potreste verificare che il plugin esistente non confligga con quello che state aggiungendo.
Se risultasse OK, potreste dargli un altro nome: >
<p>
mv thefile ~/.vim/ftplugin/stuff_too.vim
<p>
L'underscore viene usato per separare il nome del tipo di file dal resto, che può essere a piacere.
Se usaste "otherstuff.vim" non funzionerebbe, sarebbe caricato per il filetype "otherstuff".

<p>
Su MS-DOS non potete usare nomi lunghi.
Vi trovereste nei guai aggiungendo un secondo plugin il cui tipo di file avesse più di sei caratteri.
Potete adoperare un'altra directory per aggirare ciò: >
<p>
mkdir $VIM/vimfiles/ftplugin/fortran 	copy thefile $VIM/vimfiles/ftplugin/fortran/too.vim
<p>
I nomi generici per i filetype plugin sono: >
<p>
ftplugin/<filetype>.vim 	ftplugin/<filetype>_<name>.vim 	ftplugin/<filetype>/<name>.vim
<p>
Qui "<name>" può essere qualsiasi nome preferiate.
Esempi per il tipo di file "stuff" su Unix: >
<p>
~/.vim/ftplugin/stuff.vim 	~/.vim/ftplugin/stuff_def.vim 	~/.vim/ftplugin/stuff/header.vim
<p>
La parte <filetype> è il nome del tipo di file per cui il plugin deve essere usato.
Solo file di questo tipo utilizzeranno le impostazioni del plugin.
La parte <name> del file plugin non è un problema, potete usarla in molti plugin per lo stesso tipo di file.
Note Il nome deve terminare in ".vim".
<p>

<p>
Ulteriori letture: |filetype-plugins|	Documentazione per i filetype plugin ed informazioni 			su come evitare che la mappatura causi problemi.
|load-plugins|		Quando i plugin globali vengono caricati all'avvio.
|ftplugin-overrule|	Come forzare le impostazioni di un plugin globale.
|write-plugin|		Come scrivere uno script di plugin.
|plugin-details|	Per ulteriori informazioni su come usare i plugin o 			se un plugin non vi funzionasse.
|new-filetype|		Come riconoscere un nuovo filetype.

<p>
============================================================================== *05.5*	Aggiungere un file di Aiuto	 *add-local-help* *matchit-install*
<p>
Se siete fortunati, il plugin che avete installato avrà con sè un file di help.
Adesso spiegheremo come installarlo, così potrete trovare facilmente aiuto per i vostri nuovi plugin.
Usiamo il plugin "matchit.vim" come esempio (viene fornito con Vim).
Questo plugin fa sì che il comando "%" salti ai tag HTML, if/else/endif negli scripts di Vim, etc.
Utilissimo, anche se non compatibile con precedenti versioni di vim (e per questo motivo non viene abilitato di default).
Questo plugin viene fornito corredato della documentazione: "matchit.txt".
Mettiamo la prima copia del plugin nella directory giusta.
Questa volta lo faremo entro Vim, per poter usare $VIMRUNTIME.
(Potete saltare qualche comando "mkdir" se avete già la directory.) >
<p>
:!mkdir ~/.vim 	:!mkdir ~/.vim/plugin 	:!cp $VIMRUNTIME/macros/matchit.vim ~/.vim/plugin
<p>
Il comando "cp" vale in ambiente Unix, in MS-DOS si può usare "copy".

<p>
Ora create una directory "doc" entro una delle directory entro il 'runtimepath'.

<p>
:!mkdir ~/.vim/doc
<p>
Copiate il file di help entro la directory "doc".
>
<p>
:!cp $VIMRUNTIME/macros/matchit.txt ~/.vim/doc
<p>
Eccovi il trucco che vi consente di saltare sugli oggetti del nuovo file di help: generate il file locale dei tag con il comando |:helptags|.
>
<p>
:helptags ~/.vim/doc
<p>
Ora potete usare il comando >
<p>
:help g%
<p>
per trovare aiuto per "g%" nel file di help che avete appena aggiunto.
Potete vedere un accesso per il file di help locale facendo: >
<p>
:help local-additions
<p>
Le linee del titolo dai file di help locali verrano automagicamente aggiunte a questa sezione.
Lì potrete vedere quali file locali di help siano stati aggiunti e saltare ad essi attraversi il loro tag.

<p>
Per scrivere un file locale di help vedere |write-local-help|.

<p>
============================================================================== *05.6*	La finestra delle opzioni
<p>
Se state cercando un'opzione che faccia ciò che vi serve, la potreste trovare qui nei file di help: |options|.
Un altro modo è quello di usare questo comando: >
<p>
:options
<p>
Ciò aprirà una nuova finestra con una lista di opzioni ed una linea di commento.
Le opzioni sono raggruppate per argomento.
Portate il cursore sull'argomento e premete <Enter> per andare là.
Premete <Enter> un'altra volta per tornare indietro.
Oppure usate CTRL-O.
<p>
Potete cambiare il valore di un'opzione.
Ad es., spostatevi sull'argomento "displaying text".
Poi muovete il cursore più in basso, su questa linea:
<p>
set wrap	nowrap ~
<p>
Premendo <Enter>, la linea cambierà in :
<p>
set nowrap	wrap ~
<p>
L'opzione verrà disattivata.

<p>
Immediatamente sopra questa linea c'è una breve descrizione dell'opzione 'wrap'.
Spostate il cursore in alto di una linea per porlo entro questa riga.
Adesso premete <Enter> e salterete all'help complessivo sull'opzione 'wrap'.
<p>
Per opzioni che prevedono un argomento numerico o di stringa, potete mettere un nuovo valore.
Poi premete <Enter> per applicare il nuovo valore.
Ad es., per spostare il cursore qualche linea più sopra:
<p>
set so=0 ~
<p>
Ponete il cursore sotto lo zero con "$".
Cambiatelo con cinque attraverso "r5".
Ora premete <Enter> per assegnare il nuovo valore.
Ora muovendo il cursore attorno noterete che il testo inizia a scorrere prima che abbiate trovato il margine.
Ciò è quanto fa l'opzione 'scrolloff', che specifica un offset rispetto al bordo della finestra dove inizia lo scorrimento.

<p>
============================================================================== *05.7*	Le opzioni più usate
<p>
C'è un numero enorme di opzioni.
Molte di esse non le userete quasi mai.
Alcune delle più utili le citeremo qui.
Non dimenticate che potete avere maggiore aiuto su queste opzioni tramite il comando ":help", racchiudendo il nome dell'opzione tra due virgolette singole.
Ad es.: >
<p>
:help 'wrap'
<p>
Nel caso aveste smarrito il valore di un'opzione, potete riportarlo al valore di default scrivendo un ampersand (&) dopo il nome dell'opzione.
Esempio: >
<p>
:set iskeyword&
<p>

<p>
LINEE NON SPEZZATE
<p>
Vim normalmente spezza le linee lunghe, affinché possiate vedere tutto del testo.
Talvolta è meglio lasciare che il testo continui oltre il bordo destro della finestra.
Vi toccherà scorrere il testo da sinistra a destra per vedere tutta la lunga linea.
Disattivate il wrapping con questo comando: >
<p>
:set nowrap
<p>
Vim vi consentirà di spostarvi lungo il testo e raggiungere anche quello che non viene mostrato.
Per visualizzare dieci caratteri oltre il bordo della finestra fate così: >
<p>
:set sidescroll=10
<p>
Ciò non altera il testo entro il file, solo il modo come esso viene mostrato.

<p>

<p>
AMPLIARE IL CAMPO D'AZIONE DEI COMANDI DI MOVIMENTO
<p>
Molti comandi per spostarsi attraverso il testo non vanno oltre l'inizio o la fine della linea.
Potete cambiare ciò con l'opzione 'whichwrap'.
Quanto segue la imposta al valore di default: >
<p>
:set whichwrap=b,s
<p>
Ciò permette al tasto <BS>, quando usato all'inizio di una linea, di muovere il cursore alla fine della linea precedente.
Ed il tasto <Space> sposterà il cursore dalla fine della linea all'inizio della successiva.

<p>
Per consentire ai tasti cursore <Left> e <Right> di avere il medesimo comportamento, usate questo comando: >
<p>
:set whichwrap=b,s,<,>
<p>
Ciò tuttavia soltanto nel modo Normal.
Per permettere a <Left> e <Right> di fare ciò in modo Insert fate così: >
<p>
:set whichwrap=b,s,<,>,[,]
<p>
Ci sono pochi altri flag che si possono aggiungere, vedere 'whichwrap'.

<p>

<p>
VEDERE LE TABULAZIONI
<p>
Quando ci sono delle tabulazioni [Tab] entro un file non potete vedere dove siano.
Per renderle visibili: >
<p>
:set list
<p>
Adesso ogni Tab verrà mostrato come ^I.
Ed un carattere $ verrà mostrato alla fine di ogni linea, così potrete vedere eventuali spazi inutili alla fine della linea che altrimenti non sarebbero visibili.
Uno svantaggio è che ciò diventa noioso se ci sono molti Tab entro un file.
Se avete un terminale a colori o state usando la GUI, Vim può mostrare spazi e Tab come caratteri evidenziati.
Usate l'opzione 'listchars': >
<p>
:set listchars=tab:>-,trail:-
<p>
Adesso ogni Tab verrà mostrato come ">---" (con un numero variabile di "-") e gli spazi inutili come "-".
Va molto meglio, non è vero?
<p>

<p>
PAROLE CHIAVE
<p>
L'opzione 'iskeyword' specifica quali caratteri possano apparire entro una parola: >
<p>
:set iskeyword <	 iskeyword=@,48-57,_,192-255 ~
<p>
La "@" sta per tutte le lettere dell'alfabeto.
"48-57" sta per i caratteri ASCII da 48 a 57, che sono i numeri da 0 a 9.
"192-255" sono i caratteri stampabili latini.
Talvolta vorrete includere una linea nella parole chiave, per fare sì che comandi come "w" considerino "upper-case" come una sola parola.
Potete farlo così: >
<p>
:set iskeyword+=- 	:set iskeyword <	 iskeyword=@,48-57,_,192-255,- ~
<p>
Se osservate il nuovo valore, vedrete che Vim ha aggiunto una virgola al vostro posto.
Per eliminare un carattere usate "-=".
Ad es., per rimuovere l'underscore: >
<p>
:set iskeyword-=_ 	:set iskeyword <	 iskeyword=@,48-57,192-255,- ~
<p>
Questa volta una virgola verrà cancellata automaticamente.

<p>

<p>
SPAZIO PER LE COMUNICAZIONI
<p>
Quando avviate Vim c'è una linea in basso che viene usata per i messaggi.
Se un messaggio fosse lungo, verrebbe troncato, così potreste vederne solo una parte, oppure il testo scorrerebbe e voi dovreste premere <Enter> per continuare.
Potete impostare l'opzione 'cmdheight' per il numero di linee da usare per i messaggi.
Esempio: >
<p>
:set cmdheight=3
<p>
Significa che ci sarà meno spazio per scrivere del testo, si tratta di un compromesso.

<p>
==============================================================================
<p>
Capitolo seguente: |usr_06.txt| Usare l'evidenziazione della sintassi
<p>
Copyright: vedere |manual-copyright| vim:tw=78:ts=8:ft=help:norl:
<p>
Per segnalazioni scrivere a vimdoc.it at gmail dot com oppure ad Antonio Colombo azc100 at gmail dot com *usr_06.txt*	Per Vim version 7.2.
Ultima modifica: 2006 Apr 24
<p>
VIM USER MANUAL - di Bram Moolenaar 	 Traduzione di questo capitolo: Alessandro Melillo
<p>
Usare l'evidenziazione della sintassi
<p>

<p>
Il testo in bianco e nero è noioso.
Col colore, il vostro file prende vita.
E non solo ha un bell'aspetto, ma velocizza anche il vostro lavoro.
Cambiate i colori utilizzati per i diversi tipi di testo.
Stampate i vostri testi, con i colori che vedete a schermo.
<p>
|06.1|	Abilitare l'evidenziazione |06.2|	Nessun colore o colori sbagliati? |06.3|	Colori diversi |06.4|	Con o senza i colori |06.5|	Stampare a colori |06.6|	Ulteriori letture
<p>
Capitolo seguente: |usr_07.txt| Elaborare più di un file Capitolo precedente: |usr_05.txt| Configurazioni personali 	 Indice: |usr_toc.txt|
<p>
============================================================================== *06.1*	Abilitare l'evidenziazione
<p>
Basta un semplice comando:
<p>
:syntax enable
<p>
Dovrebbe funzionare nella maggior parte dei casi avere per avere i colori nei vostri file.
Vim individuerà automaticamente il tipo di file e caricherà la giusta evidenziazione della sintassi.
I commenti diventeranno blu, le parole chiave marroni e le stringhe rosse.
Questo rende semplice revisionare il file.
Dopo un pò vi renderete conto che il testo in bianco e nero vi rallenta!
<p>
Se volete utilizzare sempre l'evidenziazione della sintassi, mettete il comando ":syntax enable" nel vostro |vimrc|.

<p>
Se volete utilizzarlo solo quando il terminale supporta il colore, potete inserire in |vimrc| : >
<p>
if &t_Co > 1 	 syntax enable 	endif
<p>
Se volete l'evidenziazione solo nella versione GUI, mettete il comando "syntax enable" nel vostro |gvimrc| .

<p>
============================================================================== *06.2*	Nessun colore o colori sbagliati?
<p>
I motivi possono essere diversi:
<p>
- Il vostro terminale non supporta il colore.
Vim utilizzerà il grassetto, il corsivo e il sottolineato, anche se 	il risultato non ha un bell'aspetto.
Probabilmente vorrete provare un 	terminale col colore.
Per Unix, raccomando xterm del progetto 	XFree86: |xfree-xterm|.

<p>
- Il vostro terminale supporta il colore, ma Vim non lo sa.
Assicuratevi del corretto settaggio di $TERM.
Per esempio, usando un 	xterm che supporta il colore: >
<p>
setenv TERM xterm-color < 	o (a secondo della shell): >
<p>
TERM=xterm-color; export TERM
<p>
<	Il nome del terminale deve corrispondere a quello che state usando.
Se ancora non funziona, date un'occhiata a |xterm-color|, che 	illustra alcuni modi di far sì che VIM mostri i colori (non solo per 	un xterm).

<p>
- Il tipo di file non viene riconosciuto.
In fondo, Vim non conosce tutti i tipi di file e talvolta è quasi 	impossibile dire quale sia il linguaggio del file.
Provate questo 	comando: >
<p>
:set filetype < 	Se il risultato è "filetype=" allora il problema è senza dubbio che 	Vim non sa che tipo di file sia.
Potete impostare il tipo file 	manualmente: >
<p>
:set filetype=fortran < 	Per vedere quali tipi sono disponibili, guardate nella directory 	$VIMRUNTIME/syntax.
Per la GUI potete usare il menù Sintassi.
Settare il tipo di file può essere fatto anche con una |modeline|, in 	modo che il file venga evidenziato ogni volta che lo modificate.
Per 	esempio, questa riga può essere usata in un Makefile (mettetela 	vicino all'inizio o alla fine del file): >
<p>
# vim: syntax=make
<p>
<	 	Potreste riuscire a determinare da soli il tipo di file.
Spesso si 	può usare l'estensione (dopo il punto).
Vedete |new-filetype| per sapere come dire a Vim di individuare il 	tipo di file.

<p>
- Non è definita una evidenziazione per il vostro tipo di file.
Potreste provare ad usare un tipo simile impostandolo manualmente come 	spiegato sopra.
Se il risultato non fosse soddisfacente, potreste 	scrivervi il vostro file di sintassi.
Vedere |mysyntaxfile|.
<p>
Oppure i colori potrebbero essere sbagliati:
<p>
- Il testo colorato è molto difficile da leggere.
Vim individua il colore del vostro sfondo.
Se è nero (o un altro 	colore scuro) utilizza colori chiari per il testo.
Se è bianco (o un 	altro colore chiaro) utilizza colori scuri per il testo.
Se Vim 	sbaglia a determinare il colore di sfondo, il testo sarà difficile da 	leggere.
Per risolvere questo inconveniente, impostate l'opzione 	'background'.
Per uno sfondo scuro: >
<p>
:set background=dark
<p>
<	E per uno sfondo chiaro: >
<p>
:set background=light <	 	Assicuratevi di impostarlo _prima_ del comando ":syntax enable", 	altrimenti i colori saranno già stati impostati.
Potreste fare un 	":syntax reset" dopo aver impostato "background" per far sì che Vim 	reimposti i colori.

<p>
- I colori sono sbagliati quando scorrete dal basso all'alto.
Vim non legge l'intero file per scansionare il testo.
Inizia a 	scansionarlo in qualsiasi punto vi troviate.
Questo fa risparmiare un 	mucchio di tempo, ma a volte i colori risultano sbagliati.
Una 	semplice correzione è premere CTRL-L.
O scorrere un po' indietro e 	poi ancora un po' avanti.
Per una correzione seria, vedete |:syn-sync|.
Alcuni file di sintassi 	hanno un modo per far sì che guardi ben più indietro, vedete l'help 	dello specifico file di sintassi.
Per esempio, |tex.vim| per la 	sintassi TeX.

<p>
============================================================================== *06.3*	Colori Diversi				*:syn-default-override*
<p>
Se non vi piacciono i colori di default, potete scegliere un altro schema.
Nella GUI usate il menù Edit/Color Scheme.
Potete anche scrivere il comando: >
<p>
:colorscheme evening
<p>
"evening" è il nome dello schema.
Ce ne sono diversi altri che potreste voler provare.
Guardate nella directory $VIMRUNTIME/colors.
<p>
Quando avete trovato lo schema che vi piace aggiungete il comando ":colorscheme" al vostro vimrc.

<p>
Potreste anche scrivere da soli il vostro schema.
Ecco come:
<p>
1.
Selezionate uno schema che ci si avvicina.
Copiate questo file nella vostra directory di Vim. Per Unix, dovrebbe bastare questo: >
<p>
!mkdir ~/.vim/colors 	!cp $VIMRUNTIME/colors/morning.vim ~/.vim/colors/mine.vim < Questo si fa da Vim, visto che conosce il valore di $VIMRUNTIME.

<p>
2.
Modificate il file dello schema. Queste voci sono utili:
<p>
term		attributi in un terminale in bianco e nero 	cterm		attributi in un terminale a colori 	ctermfg		colore di primo piano in un terminale a colori 	ctermbg		colore di sfondo in un terminale a colori 	gui		attributi nella GUI 	guifg		colore di primo piano nella GUI 	guibg		colore di sfondo nella GUI
<p>
Per esempio, per rendere verdi i commenti: >
<p>
:highlight Comment ctermfg=green guifg=green < Gli attributi utilizzabili per "cterm" e "gui" sono "bold" e "underline".
Se li volete entrambi, usate "bold,underline".
Per maggiori dettagli, vedete il comando |:highlight|.

<p>
3.
Dite a Vim di usare il vostro schema di colori.
Mettete questa riga nel vostro |vimrc|: >
<p>
colorscheme mine
<p>
Se volete vedere come appaiono le combinazioni di colori più usate, utilizzate questo comando: >
<p>
:runtime syntax/colortest.vim
<p>
Vedrete del testo in varie combinazioni di colori.
Potete quindi scegliere quelle più leggibili e carine.

<p>
============================================================================== *06.4*	Con o senza i colori
<p>
Mostrare il testo a colori impiega molte risorse.
Se trovate che sia troppo lento, potete disabilitare l'evidenziazione per un istante: >
<p>
:syntax clear
<p>
Quando modificate un altro file (o lo stesso) i colori torneranno.

<p>
*:syn-off*
<p>
Se volete bloccare definitivamente l'evidenziazione usate: >
<p>
:syntax off
<p>
Questo disabiliterà completamente l'evidenziazione della sintassi e la rimuoverà immediatamente da tutti i buffer.

<p>
*:syn-manual*
<p>
Se volete abilitare l'evidenziazione solo per delle determinate righe, usate questo: >
<p>
:syntax manual
<p>
Questo abiliterà l'evidenziazione della sintassi, ma non la userà automaticamente quando si inizia a modificare un buffer.
Per attivarla nel buffer corrente, impostate l'opzione 'syntax': >
<p>
:set syntax=ON < ============================================================================== *06.5*	 Stampare con i colori				*syntax-printing*
<p>
Nella versione per MS-Windows potete stampare il file corrente con questo comando: >
<p>
:hardcopy
<p>
Otterrete la solita finestra di dialogo della stampante, dove potrete selezionare la stampante e alcune impostazioni.
Se avete una stampante a colori, l'output su carta dovrebbe risultare lo stesso di quello a schermo con Vim.
Ma se utilizzate uno sfondo scuro i colori verranno modificati per avere un buon aspetto su carta bianca.

<p>
Ci sono diverse opzioni che possono cambiare il modo in cui Vim stampa: 	'printdevice' 	'printheader' 	'printfont' 	'printoptions'
<p>
Per stampare solo un intervallo di righe, utilizzate la modalità Visual per selezionare le linee e poi usate il comando: >
<p>
v100j:hardcopy
<p>
"v" inizializza il Visual mode.
"100j" si sposta in basso di 100 righe, evidenziandole.
Infine ":hardcopy" le stampa.
Ovviamente potete usare altri comandi per spostarvi in Visual mode.
<p>
Questo funziona anche sotto Unix se avete una stampante PostScript.
Altrimenti c'è bisogno di un po' più di lavoro.
Dovete prima convertire il testo in HTML, e poi stamparlo da un browser come Netscape.

<p>
Convertite il file corrente in HTML con questo comando: >
<p>
:source $VIMRUNTIME/syntax/2html.vim
<p>
Sentirete che sta macinando dati, e potrebbe essere necessario molto tempo per un file di grandi dimensioni.
Poco dopo, la finestra mostrerà il codice HTML.
Adesso salvatelo da qualche parte (non importa dove, dopo lo cancellerete): > 	:write main.c.html
<p>
Aprite questo file nel vostro browser preferito e stampatelo da lì.
Se tutto va bene, l'output dovrebbe avere lo stesso aspetto che ha dentro Vim.
Vedete |2html.vim| per i dettagli.
Non dimenticate di cancellare l'HTML quando avete finito.

<p>
Invece di stampare, potreste anche mettere il file HTML su un web server, e lasciare che altri vedano il testo a colori.

<p>
============================================================================== *06.6*	Ulteriori letture
<p>
|usr_44.txt| Evidenziazione della vostra sintassi |syntax| Tutti i dettagli.

<p>
==============================================================================
<p>
Capitolo seguente: |usr_07.txt| Elaborare più di un file
<p>
Per segnalazioni scrivere a vimdoc.it at gmail dot com oppure ad Antonio Colombo azc100 at gmail dot com *usr_07.txt*	Per Vim version 7.2.
Ultima modifica: 2006 Apr 24
<p>
VIM USER MANUAL - di Bram Moolenaar 	 Traduzione di questo capitolo: Giuliano Bordonaro
<p>
Elaborare più di un file
<p>

<p>
Non importa quanti file abbiate, potete elaborarli tutti senza lasciare Vim.
Stabilire una lista di file da elaborare e saltare dall'uno all'altro.
Copiare testo da un file ed inserirlo entro un altro.

<p>
|07.1|	Elaborare un altro file |07.2|	Una lista di file |07.3|	Saltare da file a file |07.4|	File di backup |07.5|	Copiare testo tra più file |07.6|	Visualizzare un file |07.7|	Rinominare un file
<p>
Capitolo seguente: |usr_08.txt| Dividere le finestre Capitolo precedente: |usr_06.txt| Usare l'evidenziazione della sintassi 	 Indice: |usr_toc.txt|
<p>
============================================================================== *07.1*	Elaborare un altro file
<p>
Innanzi tutto bisogna avviare Vim per ogni file da modificare.
C'è un modo semplice.
Per iniziare a lavorare su di un altro file usate questo comando: >
<p>
:edit foo.txt
<p>
Ovviamente potete utilizzare un qualunque altro nome di file invece di "foo.txt".
Vim chiuderà il file attualmente aperto ed aprirà quello nuovo.
Se il file attualmente aperto avesse delle modifiche non ancora salvate, comunque, Vim mostrerebbe un messaggio di errore e non aprirebbe il nuovo file:
<p>
E37: Non salvato dopo modifica (aggiungi ! per eseguire comunque) ~
<p>
Note: 	Vim fornisce un codice identificativo di errore prima di ciascun 	messaggio di errore.
Se non doveste comprendere questo messaggio o da 	cosa esso fosse causato, vedere nel sistema di aiuto cercando tale 	codice identificativo.
Nel caso presente: >
<p>
:help E37
<p>
Ora vi sono diverse alternative.
Potete salvare il file con il comando: >
<p>
:write
<p>
Ovvero forzare Vim ad ignorare i cambiamenti ed aprire comunque il secondo file, usando il carattere (!): >
<p>
:edit! foo.txt
<p>
Se voleste modificare un altro file ma non salvare subito le modifiche dell'attuale, potete nasconderlo: >
<p>
:hide edit foo.txt
<p>
Il testo modificato è ancora lì, ma non potete vederlo.
Ciò verrà spiegato più avanti nella sezione |22.4|: La lista dei buffer
<p>
============================================================================== *07.2*	Una lista di file
<p>
Potete avviare Vim per modificare un gruppo di file.
Ad esempio: >
<p>
vim one.c two.c three.c
<p>
Questo comando avvia Vim e gli dice che verranno modificati tre file.
Vim fa vedere solo il primo file.
Dopo avere effettuato le dovute modifiche, per passare al prossimo file usate il comando: >
<p>
:next
<p>
Se ci fossero modifiche non salvate nel file corrente, otterreste un messaggio di errore ed il comando ":next" non funzionerebbe.
E' esattamente come avveniva con il comando ":edit", descritto nella precedente sezione.
Per lasciar perdere le modifiche: >
<p>
:next!
<p>
Ma di solito vorrete salvare le modifiche prima di passare al prossimo file.
Ecco un comando speciale per ottenere ciò: >
<p>
:wnext
<p>
Questo equivale ad usare due distinti comandi: >
<p>
:write 	:next
<p>

<p>
DOVE MI TROVO?
<p>
Per vedere quale file della lista sia attualmente in corso di modifica, guardate il titolo della finestra.
Potrebbe esserci qualcosa come "(2 di 3)".
Ciò significa che state modificando il secondo file di una lista che ne comprende tre.
Se volete vedere l'elenco dei file, usate il comando: >
<p>
:args
<p>
E' l'abbreviazione di "arguments".
Il risultato potrebbe assomigliare a questo: >
<p>
one.c [two.c] three.c ~
<p>
Sono i file che sono stati aperti con Vim.
Quello su cui state lavorando attualmente, "two.c", è racchiuso tra parentesi quadre.

<p>

<p>
SPOSTARSI SU ALTRI ARGOMENTI
<p>
Per tornare indietro di un file: >
<p>
:previous
<p>
E' esattamente come il comando ":next", eccetto che va nella direzione opposta.
Inoltre, ecco un comando abbreviato per salvare il file prima di muovervi a quello precedente: >
<p>
:wprevious
<p>
Per andare all'ultimo file della lista: >
<p>
:last
<p>
E per tornare al primo: >
<p>
:first
<p>
Però non esistono i comandi ":wlast" o ":wfirst"!
<p>
Potete usare un contatore per specificare di quanti file spostarvi con i comandi ":next" e ":previous".
Per saltare avanti di due file: >
<p>
:2next
<p>

<p>
SALVATAGGIO AUTOMATICO
<p>
Spostandovi tra i file e modificandoli, dovete rammentare di impiegare ":write".
Altrimenti apparirà il solito messaggio di errore.
Se siete certi di voler salvare comunque le modifiche, potete indicare a Vim di salvare automaticamente, in questo modo: >
<p>
:set autowrite
<p>
Nel caso in cui invece stiate modificando un file che potreste decidere di non salvare, disattivate il salvataggio automatico con: >
<p>
:set noautowrite
<p>

<p>
LAVORARE CON UN'ALTRA LISTA DI FILE
<p>
Potete ridefinire la lista dei file senza uscire da Vim e doverlo poi riavviare.
Per editare altri tre file, usate questo comando: >
<p>
:args five.c six.c seven.h
<p>
Oppure con una wildcard, come nei comandi di shell: >
<p>
:args *.txt
<p>
Vim si porterà sul primo file dell'elenco.
Se il file attuale avesse subito modifiche, potete prima salvarlo, oppure usare ":args!" (con aggiunto il !) per tralasciare le modifiche.

<p>

<p>
PER MODIFICARE L'ULTIMO FILE? 							*arglist-quit* Quando si lavora con un elenco di file, Vim prevede che essi debbano essere modificati tutti.
Per prevenire l'eventualità di uscire intempestivamente, nel caso non abbiate raggiunto l'ultimo file dell'elenco, vi verrà mostrato il seguente messaggio di errore: >
<p>
E173: ancora 46 file da elaborare
<p>
Se intendete uscire comunque, ripetete il comando.
In questo modo, funzionerà (ovviamente, solo se non saranno stati immessi altri comandi nel frattempo).

<p>
============================================================================== *07.3*	Saltare da file a file
<p>
Per spostarvi rapidamente tra due file, premete CTRL-^ (nelle tastiere English-US il ^ si trova sopra il tasto del 6, in quelle italiane sopra il tasto della "i accentata").
Ad esempio: >
<p>
:args one.c two.c three.c
<p>
Attualmente siamo in one.c.
>
<p>
:next
<p>
Adesso ci si trova in two.c.
Ora con CTRL-^ si torna a one.c.
Un altro CTRL-^ e nuovamente si è in two.c.
Ancora CTRL-^ e ci si trova di nuovo in one.c. Se adesso si scrive: >
<p>
:next
<p>
ci si trova in three.c.
Notate come il comando CTRL-^ non cambi l'idea di dove ci si trovi nell'elenco dei file.
Solo comandi come ":next" e ":previous" lo fanno.

<p>
Il file precedentemente modificato viene chiamato file "alternate".
Se si fosse appena avviato Vim, CTRL-^ non funzionerebbe, perché non esiste un file precedente.

<p>

<p>
MARCATORI PREDEFINITI
<p>
Dopo essere passati ad un altro file, possono essere impiegati due marcatori predefiniti molto utili: >
<p>
`"
<p>
Ciò riposizionerà il cursore nella posizione che aveva prima che si fosse lasciato quel file.
Un altro marcatore ricorda la posizione dove è avvenuta l'ultima modifica: >
<p>
`.

<p>
Immaginate di lavorare con il file "one.txt".
Avete usato il tasto "x" per cancellare un carattere.
Poi vi siete spostati sull'ultima riga con "G" e avete salvato il file con ":w".
In seguito modificate molti altri file, e poi digitate ":edit one.txt" per ritornare a "one.txt".
Se ora usate `" Vim tornerà all'ultima linea del file.
Usando `.
tornerete alla posizione dove il carattere era stato cancellato.
Allo stesso modo, spostandovi attraverso il file, `" e `.
vi riporteranno nella posizione ricordata. Almeno sino a quando verrà effettuata un'altra modifica o si chiuderà il file.
<p>

<p>
MARCATURA DI UN FILE
<p>
Nel capitolo 4 è stato spiegato come porre un marcatore in un file con "mx" e saltare a quella posizione con "`x".
Ciò funziona per un solo file.
Se si lavorasse con un altro file e si mettessero marcatori in esso, questi sarebbero specifici per questo file.
Sinora sono stati usati marcatori con una lettera minuscola.
Possono esservi anche marcatori con lettere maiuscole.
Questi sono globali, possono essere usati da qualsiasi file.
Ad esempio, immaginate di lavorare con il file "foo.txt".
Spostatevi a metà del file ("50%") e ponete lì il marcatore F (F per foo): >
<p>
50%mF
<p>
Adesso modificate il file "bar.txt" e mettete il marcatore B (B per bar) alla sua ultima linea: >
<p>
GmB
<p>
Adesso potete impiegare il comando "'F" per tornare a metà di foo.txt.
Oppure editare un altro file, digitare "'B" e ritrovarvi nuovamente alla fine di bar.txt.

<p>
La marcatura dei file verrà ricordata sino a che essa non sia stata posta altrove.
Così si può mettere il marcatore, lavorare per ore e poter ancora tornare a quel marcatore.
E' spesso utile pensare ad un collegamento tra la lettera usata per segnare ed il posto ove essa si trova.
Ad esempio, impiegate il marcatore H nell'header di un file , M in un makefile e C in un file in codice C.

<p>
Per vedere dove si trovi un marcatore specifico, dovete fornire un argomento al comando ":marks": >
<p>
:marks M
<p>
Potete fornire anche più argomenti: >
<p>
:marks MCP
<p>
Non dimenticate che potete usare CTRL-O e CTRL-I per saltare a posizioni più vecchie o più nuove senza porvi dei marcatori.

<p>
============================================================================== *07.4*	File di backup
<p>
Di norma Vim non genera file di backup.
Se si volesse averne, basta eseguire il seguente comando: >
<p>
:set backup
<p>
Il nome del file di backup è lo stesso del file originale con una ~ aggiunta in coda.
Se il file si chiamasse data.txt, ad esempio, il file di backup si chiamerebbe data.txt~.
Se non gradiste il fatto che i file di backup terminino con ~, potete cambiare l'estensione: >
<p>
:set backupext=.bak
<p>
Verrà impiegato data.txt.bak invece di data.txt~.
Un'altra opzione utile è 'backupdir'.
Specifica dove scrivere il file di backup.
L'impostazione predefinita, ovvero scrivere il backup nella stessa directory del file originale, potrebbe, nella maggior parte dei casi, essere la cosa giusta.

<p>
Note: 	Se l'opzione 'backup' non fosse impostata ma la 'writebackup' sì, 	Vim creerà comunque un file di backup.
Tuttavia questo verrà 	cancellato quando il file sarà stato salvato.
Ciò funziona come 	una garanzia contro la perdita del file originale qualora il 	salvataggio fallisse per qualche ragione (il disco pieno è una 	delle cause più comuni; un colpo di fulmine potrebbe essere 	un'altra causa, sebbene meno frequente).

<p>

<p>
RECUPERARE IL FILE ORIGINALE
<p>
Se state editando un file sorgente, potreste voler recuperare il file come era prima delle modifiche effettuate.
Ma il file di backup viene sovrascritto ogni qualvolta salvate il file.
Così esso conterrà solo la versione precedente e non la prima in assoluto.
Per ottenere che Vim recuperi il file originale, impostate l'opzione 'patchmode'.
Ciò specifica l'estensione usata per il primo backup.
Solitamente si farà così: >
<p>
:set patchmode=.orig
<p>
Quando modificate per la prima volta il file data.txt, operando cambiamenti e salvando il file, Vim tiene una copia del file non modificato con il nome "data.txt.orig".
Se modificate ancora il file, Vim vi informerà che "data.txt.orig" esiste già e lo lascerà così com'è.
I backup successivi verranno chiamati "data.txt~" (o in qualunque altro modo aveste specificato mediante 'backupext').
Lasciando vuoto 'patchmode' (questo è il default), il file originale non verrà recuperato.

<p>
============================================================================== *07.5*	Copiare testo tra più file
<p>
Spieghiamo ora come copiare del testo da un file ad un altro.
Cominciamo con un esempio facile.
Aprite il file che contiene il testo che volete copiare.
Portate il cursore all'inizio del testo e premete "v".
Ciò avvia il Visual mode.
Spostate ora il cursore alla fine del testo e premete "y" (y sta per "yank", cioè copia). Questo copierà il testo selezionato.
<p>
Per copiare il paragrafo precedente potete usare: >
<p>
:edit questofile 	/Spieghiamo 	vjjjj$y
<p>
Poi aprite il file dove intendete incollare il testo.
Portate il cursore sul carattere dopo il quale volete far apparire il testo.
Usate "p" per incollarvi il testo: >
<p>
:edit altrofile 	/Qui 	p
<p>
Logicamente si possono usare molti altri comandi per copiare (yank) il testo.
Ad esempio, per selezionare intere linee, attivate il Visual mode con "V".
Oppure, usate CTRL-V per selezionare un blocco rettangolare.
Oppure usate "Y" per copiare una sola linea, "yaw" per copiare una parola (yank-a-word), etc.
Il comando "p" incolla (puts) il testo dopo il cursore.
Usate "P" per incollarlo prima del cursore.
Si noti che Vim ricorda se si è copiata qualche linea od un blocco, e lo re-incolla allo stesso modo.

<p>

<p>
USARE I REGISTRI
<p>
Se si dovessero copiare molti pezzi di testo da un file ad un altro, il passare da un file all'altro e lo scrivere il file destinazione richiede un mucchio di tempo.
Per evitare ciò si può copiare ogni pezzo di testo entro un registro.
Un registro è un posto dove Vim conserva del testo.
Per ora useremo dei registri chiamati da a sino a z (in seguito si scoprirà che ne esistono altri).
Copiate una frase nel registro f (f per first): >
<p>
"fyas
<p>
Il comando "yas" copia (yank) una frase, come visto prima.
"f indica a Vim quale parte del testo dovrà essere posta entro il registro f.
Deve venire prima del comando yank.
Ora si copino tre intere linee nel registro l (l per line): >
<p>
"l3Y
<p>
Il numero di linee da copiare può venire anche prima di "l, se necessario.
Per copiare un blocco di testo nel registro b (b per block): >
<p>
CTRL-Vjjww"by
<p>
Notate che la specifica del registro "b va posta proprio prima del comando "y".
Ciò è necessario.
Se venisse posta dopo di esso, non funzionerebbe.
Ora tre frammenti di testo si trovano entro i registri f, l e b. Aprite un altro file e spostatevi in esso nel punto dove volete porre il testo: >
<p>
"fp
<p>
Anche ora la specifica "f del registro viene prima del comando "p".
I registri possono essere incollati in ogni ordine.
Ed il testo resterà entro i registri sino a quando non vi verrà copiato qualcosa d'altro.
Così lo si potrà incollare tutte le volte che si vorrà.

<p>
Quando viene cancellato del testo, si può anche specificare un registro.
Ciò può essere usato per spostare del testo altrove.
Ad esempio, per cancellare una parola (delete-a-word) e scriverla nel registro w: >
<p>
"wdaw
<p>
Come sempre la specifica del registro viene prima del comando di cancellazione (delete) "d".

<p>

<p>
ACCODARE AD UN FILE
<p>
Se si volessero riunire diverse linee di testo entro un solo file, si potrebbe usare il seguente comando: >
<p>
:write >> logfile
<p>
Verrà scritto il testo del file corrente in coda a "logfile".
Così il testo verrà accodato.
Ciò eviterà di dover copiare le linee, aprire il log file ed incollarle in esso.
Verranno saltati due passaggi.
Ma si può accodare soltanto alla fine del file.
Per accodare solo alcune linee, si selezionino nel Visual mode prima di scrivere ":write".
Nel capitolo 10 saranno spiegati altri modi per selezionare gruppi di linee.

<p>
============================================================================== *07.6*	Visualizzare un file
<p>
Talvolta si vuole solo vedere cosa contenga un file, senza volerlo modificare.
C'è il rischio di scrivere ":w" senza pensarci e sovrascrivere il file originale inavvertitamente.
Per evitare ciò, aprite il file in sola lettura (read-only).
Per avviare Vim nel modo readonly, si adoperi il seguente comando: >
<p>
vim -R file
<p>
Su Unix il seguente comando farebbe la stessa cosa: >
<p>
view file
<p>
Il file "file" è ora aperto nel modo read-only.
Se si provasse ad usare ":w" si otterrebbe solo un messaggio di errore ed il file non verrebbe sovrascritto.
Se si provasse ad effettuare una modifica al file, Vim darebbe il seguente avviso:
<p>
W10: Warning: Changing a readonly file ~
<p>
Il cambio però può essere fatto.
Ciò permette di formattare il file, per esempio, per poterlo leggere facilmente.
Se venissero effettuate delle modifiche ad un file, scordandosi che esso era read-only, si potrebbe comunque tranquillamente scriverlo.
Aggiungete al comando un ! per forzare la scrittura.

<p>
Se si volesse realmente proibire di modificare un file bisognerebbe scrivere così: >
<p>
vim -M file
<p>
Così qualsiasi tentativo di modifica sarà inutile.
I file di help sono così, per esempio.
Se si prova a modificarli si ottiene questo messaggio di errore:
<p>
E21: Non posso fare modifiche, 'modifiable' è inibito ~
<p>
Si può usare l'argomento -M per avviare Vim in sola lettura.
Ciò però soltanto sino a quando lo si voglia; questi comandi rimuovono la protezione: >
<p>
:set modifiable 	:set write
<p>
============================================================================== *07.7*	Rinominare un file
<p>
Un modo semplice per iniziare a scrivere un nuovo testo è impiegare un file esistente che contenga il più possibile di quanto sia necessario.
Ad esempio, si inizi a scrivere un nuovo programma per spostare un file.
Sapete già di avere un programma che copia dei file, così iniziate con: >
<p>
:edit copy.c
<p>
Cancellate tutto ciò che non vi è necessario.
Adesso dovete salvare il file con un nuovo nome.
Il comando ":saveas" serve a ciò: >
<p>
:saveas move.c
<p>
Vim salverà il file con il nome dato ed aprirà quel file.
Così la prossima volta che scriverete ":write", Vim salverà "move.c".
"copy.c" rimarrà non modificato.
Quando volete cambiare il nome del file che avete aperto, ma non salvare il file con il vecchio nome, usate questo comando: >
<p>
:file move.c
<p>
Vim segnerà il file come "non elaborato".
Significa che Vim sa che questo non è il file che era stato aperto.
Quando salverete il file potreste ottenere questo messaggio:
<p>
E13: File esistente (aggiungi ! per riscriverlo) ~
<p>
Ciò vi eviterà di sovrascrivere accidentalmente un altro file.

<p>
==============================================================================
<p>
Capitolo seguente: |usr_08.txt| Dividere le finestre
<p>
Copyright: vedere |manual-copyright| vim:tw=78:ts=8:ft=help:norl:
<p>
Per segnalazioni scrivere a vimdoc.it at gmail dot com oppure ad Antonio Colombo azc100 at gmail dot com *usr_08.txt*	Per Vim version 7.2.
Ultima modifica: 2006 Lug 18
<p>
VIM USER MANUAL - di Bram Moolenaar 	 Traduzione di questo capitolo: Valentino Squilloni
<p>
Dividere le finestre
<p>

<p>
Poter osservare due diversi file, uno sopra l'altro.
Oppure vedere contemporaneamente due diversi punti dello stesso file.
Confrontare due file diversi mettendoli l'uno affianco all'altro.
Tutto ciò è possibile dividendo in più parti la finestra.

<p>
|08.1| Dividere una finestra |08.2| Dividere una finestra aprendo un altro file |08.3| Dimensioni della finestra |08.4| Tagli verticali |08.5| Muovere le finestre |08.6| Comandi per tutte le finestre |08.7| Evidenziare le differenze con vimdiff |08.8| Varie ed eventuali |08.9| Linguette
<p>
Capitolo seguente: |usr_09.txt| Usare la GUI Capitolo precedente: |usr_07.txt| Elaborare più di un file Indici: |usr_toc.txt|
<p>
============================================================================== *08.1*	Dividere una finestra
<p>
Il modo più semplice per aprire una nuova finestra è quello di usare il seguente comando: >
<p>
:split
<p>
Questo comando divide lo schermo in due finestre e posiziona il cursore nella finestra più in alto:
<p>
+----------------------------------+ |/* file one.c */ | |~ | |~ | |one.c=============================| |/* file one.c */ | |~ | |one.c=============================| | | +----------------------------------+
<p>
Quello che vedrete qui sono due finestre aperte sullo stesso file.
La linea con "====" è la linea di status.
Essa ci dà informazioni sulla finestra sovrastante.
(In pratica la linea di status si presenterà con colori opposti a quelli dello schermo.) Le due finestre permettono di vedere due parti dello stesso file.
Ad esempio, sarà possibile far mostrare alla finestra in alto la dichiarazione delle variabili di un programma, ed a quella in basso il codice che utilizza quelle variabili.

<p>
Il comando CTRL-W w viene usato per saltare fra le finestre.
Se siete nella finestra in alto, CTRL-W w salterà alla finestra sottostante.
Se siete nell'ultima finestra (quella più in basso) CTRL-W w salterà alla prima.
(CTRL-W CTRL-W fa la stessa cosa, nel caso il tasto CTRL venga rilasciato un pelo troppo tardi.)
<p>

<p>
CHIUDERE LA FINESTRA
<p>
Per chiudere una finestra, si usa il comando: >
<p>
:close
<p>
In realtà, ogni comando che chiude l'editing di un file funzionerà, come ":quit" e "ZZ".
Ma ":close" previene l' uscita accidentale da Vim quando si chiude l'ultima finestra.

<p>

<p>
CHIUDERE TUTTE LE ALTRE FINESTRE
<p>
Se avete aperto un mucchio di finestre, ma ora volete concentrarvi solo su una di esse, questo comando vi sarà utile: >
<p>
:only
<p>
Questo chiuderà tutte le finestre, a parte quella corrente (quella dove è presente il cursore).
Se qualcuna delle altre finestre ha avuto dei cambiamenti, avrete un errore e quelle finestre non verranno chiuse.

<p>
============================================================================== *08.2*	Dividere una finestra aprendo un altro file
<p>
Il comando seguente apre una seconda finestra e inizia ad editare in essa il file dato: >
<p>
:split two.c
<p>
Se state editando one.c, allora il risultato del comando sarà circa così:
<p>
+----------------------------------+ |/* file two.c */ | |~ | |~ | |two.c=============================| |/* file one.c */ | |~ | |one.c=============================| | | +----------------------------------+
<p>
Per aprire una finestra su un nuovo file vuoto, usate questo: >
<p>
:new
<p>
Potete ripetere i comandi ":split" e ":new" per creare quante finestre volete.

<p>
============================================================================== *08.3*	Dimensioni della finestra
<p>
Il comando ":split" può avere un argomento numerico.
Se viene specificato, questo sarà l'altezza della nuova finestra.
Per esempio, il comando seguente apre una nuova finestra alta tre linee e inizia a editarvi il file alpha.c: >
<p>
:3split alpha.c
<p>
Per le finestre già esistenti potete cambiarne le dimensioni in diversi modi.
Se avete un mouse funzionante, è facile: basta muovere il cursore sulla linea di status che separa le due finestre, e trascinarla in alto o in basso.

<p>
Per aumentare la dimensione di una finestra: >
<p>
CTRL-W +
<p>
Per diminuirla: >
<p>
CTRL-W -
<p>

<p>
Entrambi i comandi prendono un numero e aumentano o diminuiscono l'altezza della colonna di quel numero di linee.
In questo modo "4 CTRL-W +" da sì che la finestra diventi 4 linee più alta.

<p>
Per impostare l'altezza della finestra ad un numero specificato di linee: >
<p>
{altezza}CTRL-W _
<p>
Cioè: un numero {altezza}, CTRL-W e un underscore (il tasto - con Shift premuto sulle tastiere English-US).
Per rendere una finestra più alta possibile, si usa il comando CTRL-W _ senza un numero prima.

<p>

<p>
USARE IL MOUSE
<p>
In Vim potete fare un sacco di cose molto velocemente direttamente con la tastiera.
Sfortunatamente, i comandi per ridimensionare la finestra richiedono numerose pressioni dei tasti.
In questo caso, usare il mouse è più veloce.
Posizionate il mouse sulla linea di status.
Ora premete il tasto sinistro del mouse e trascinate.
La linea di status si muoverà, facendo diventare la finestra da una parte più alta e quella dall'altra più bassa.
<p>

<p>
OPZIONI
<p>
L'opzione 'winheight' è usata per impostare l'altezza minima desiderata di una finestra e 'winminheight' per l'altezza minima consentita di una finestra.
Allo stesso modo c'è 'winwidth' per la larghezza minima desiderata e 'winminwidth' per la minima larghezza consentita.
L'opzione 'equalalways', quando è impostata, fa sì che Vim aggiusti le altezze delle finestre quando viene chiusa o aperta una finestra per uniformarle.

<p>
============================================================================== *08.4*	Tagli verticali
<p>
Il comando ":split" crea la finestra nuova sopra a quella corrente.
Invece per far comparire la nuova finestra alla sinistra di quella già presente, si usa: >
<p>
:vsplit
<p>
oppure: >
<p>
:vsplit two.c
<p>
Il risultato sarà simile a questo:
<p>
+--------------------------------------+ |/* file two.c */ |/* file one.c */ | |~ |~ | |~ |~ | |~ |~ | |two.c===============one.c=============| | | +--------------------------------------+
<p>

<p>
In pratica, le colonna di | al centro dello schermo sarà in colori opposti a quelli dello schermo.
Viene chiamata separatore verticale.
Serve a separare le due finestre alla destra e alla sinistra di essa.
<p>
C'è anche il comando ":vnew", che taglia verticalmente la finestra aprendo un nuovo file vuoto.
Un altro modo di ottenere ciò: >
<p>
:vertical new
<p>
Il comando ":vertical" può esser inserito prima di un altro comando che divide una finestra.
Questo farà sì che quel comando divida la finestra in verticale invece che in orizzontale.
(Se il comando non divide finestre, non verrà influenzato da esso.)
<p>
MUOVERSI FRA LE FINESTRE
<p>
Poiché si può dividere più volte la finestra in orizzontale e in verticale, è possibile creare quasi ogni tipo di schema.
Potete poi usare questi comandi per muovervi da una finestra all'altra:
<p>
CTRL-W h muove verso la finestra a sinistra CTRL-W j muove verso la finestra di sotto CTRL-W k muove verso la finestra di sopra CTRL-W l muove verso la finestra a destra
<p>
CTRL-W t muove verso la finestra più in alto CTRL-W b muove verso la finestra più in basso
<p>
Noterete che le stesse lettere sono usate per muovere il cursore.
E anche le frecce possono essere usate, se preferite.
Ulteriori comandi per muoversi verso altre finestre: |Q_wi|..

<p>
============================================================================== *08.5*	Muovere le finestre
<p>
Avete tagliato alcune finestre, ma ora sono nel posto sbagliato.
Quindi avrete bisogno di un comando per muovere la finestra in un altro posto.
Ad esempio, avete tre finestre messe in questo modo:
<p>
+----------------------------------+ |/* file two.c */ | |~ | |~ | |two.c=============================| |/* file three.c */ | |~ | |~ | |three.c===========================| |/* file one.c */ | |~ | |one.c=============================| | | +----------------------------------+
<p>
Chiaramente l'ultima in basso dovrebbe stare nel posto più in alto.
Allora muovetevi verso quella finestra (usando CTRL-W w) e usate questo comando: >
<p>
CTRL-W K
<p>
Questo comando usa la lettera maiuscola K.
Quello che succede è che la finestra in questione viene spostata nel punto più alto.
Noterete che K è usata ancora per muoversi verso l'alto.
Se ci sono dei tagli verticali, CTRL-W K muoverà la finestra corrente nel punto più in alto e le farà occupare l'intera larghezza della finestra di Vim.
Se questo è il vostro layout:
<p>
+-------------------------------------------+ |/* two.c */ |/* three.c */ |/* one.c */ | |~ |~ |~ | |~ |~ |~ | |~ |~ |~ | |~ |~ |~ | |~ |~ |~ | |two.c=========three.c=========one.c========| | | +-------------------------------------------+
<p>
Allora usando CTRL-W K sulla finestra al centro (three.c) avrà come risultato:
<p>
+-------------------------------------------+ |/* three.c */ | |~ | |~ | |three.c====================================| |/* two.c */ |/* one.c */ | |~ |~ | |two.c==================one.c===============| | | +-------------------------------------------+
<p>
Gli altri tre comandi simili (e probabilmente ora già ve li immaginate) sono:
<p>
CTRL-W H muove la finestra nel punto più a sinistra CTRL-W J muove la finestra nel punto più in basso CTRL-W L muove la finestra nel punto più a destra
<p>
============================================================================== *08.6*	Comandi per tutte le finestre
<p>
Quando avete molte finestre aperte e volete uscire da Vim, potete chiudere separatamente ogni finestra.
Un modo più veloce per fare la stessa cosa è il comando: >
<p>
:qall
<p>
Che sta per "quit all".
Se qualche finestra contiene delle modifiche, Vim non uscirà.
Il cursore sarà automaticamente posizionato in una di queste finestre che hanno subito modifiche.
Potete usare ":write" per salvare i cambiamenti fatti, oppure ":quit!" per buttarli via.

<p>
Se sapete che ci sono più finestre da salvare, e le volete salvare tutte, usate questo comando: >
<p>
:wall
<p>
Che sta per "write all".
In realtà va a scrivere solo quei file che hanno subito delle modifiche.
Vim sa che non ha senso scrivere un file che non è stato modificato.
C'è anche la combinazione di ":qall" e ":wall": il comando "scrivi tutto ed esci": >
<p>
:wqall
<p>
Che salva tutti i file modificati e chiude Vim.
Infine, c'è un comando per chiudere Vim e ignorare tutti i cambiamenti fatti: >
<p>
:qall!
<p>
Attenzione, non c'è il modo di annullare questo comando!
<p>
APRIRE UNA FINESTRA PER OGNI ARGOMENTO
<p>
Per far sì che Vim apra una finestra per ogni file, lo si fa partire con l'argomento "-o": >
<p>
vim -o one.txt two.txt three.txt
<p>
Il risultato sarà:
<p>
+-------------------------------+ 	|file one.txt			| 	|~				| 	|one.txt========================| 	|file two.txt			| 	|~				| 	|two.txt========================| 	|file three.txt			| 	|~				| 	|three.txt======================| 	|				| 	+-------------------------------+
<p>
L'argomento "-O" è usato per avere finestre separate verticalmente.
Quando Vim è già in esecuzione, il comando ":all" apre una finestra per ogni file nella lista degli argomenti.
":vertical all" fa la stessa cosa ma con tagli verticali.

<p>
============================================================================== *08.7*	Evidenziare le differenze con vimdiff
<p>
C'è un modo speciale di far partire Vim, che mostra le differenze fra due file.
Prendiamo ad esempio il file "main.c" e inseriamo qualche carattere in una linea.
Salviamo il file con l'opzione 'backup' attiva, così che il file di backup "main.c~" conterrà la versione precedente del file.
Scrivete questo comando in una shell (non in Vim): >
<p>
vimdiff main.c~ main.c
<p>
Vim partirà con due finestre una al fianco dell'altra.
Voi vedrete solo la linea in cui avete aggiunto i caratteri, e qualche linea sopra e sotto di essa.

<p>
VV		 VV 	+-----------------------------------------+ 	|+ +--123 lines: /* a|+ +--123 lines: /* a| <- piegatura 	| testo	 |	testo		 | 	| testo	 |	testo		 | 	| testo	 |	testo		 | 	| testo	 |	testo cambiato | <- linea cambiata 	| testo	 |	testo		 | 	| testo	 |	------------------| <- linea cancellata 	| testo	 |	testo		 | 	| testo	 |	testo		 | 	| testo	 |	testo		 | 	|+ +--432 lines: test|+ +--432 lines: test| <- piegatura 	| ~		 |	~		 | 	| ~		 |	~		 | 	|main.c~==============main.c==============| 	|					 | 	+-----------------------------------------+
<p>
(Questa figura non mostra le parti evidenziate, usate direttamente vimdiff per una resa migliore.)
<p>
Le linee che non erano state modificate sono collassate in una riga.
Questo è chiamato una piega chiusa (closed fold).
Nella figura sono indicate con "<- piegatura".
Sebbene la prima linea piegata rappresenti 123 linee di testo, queste linee sono uguali in entrambi i file.
La linea contrassegnata con "<- linea cambiata" è evidenziate, e il testo inserito viene visualizzato in un altro colore.
Questo mostra in modo chiaro le differenze fra i due file.
La linea che è stata cancellata è mostrata con "---" nella finestra di main.c.
Notate il contrassegno "<- linea cancellata" nella figura.
Questi caratteri non sono veramente lì.
Servono solo a riempire main.c, in modo che mostri lo stesso numero di linee dell'altra finestra.
<p>

<p>
LA COLONNA PIEGA
<p>
Ogni finestra ha una colonna sulla sinistra con lo sfondo leggermente differente.
Nella figura sopra queste colonne sono indicate con "VV".
Noterete un carattere "+" all'inizio di ogni piega chiusa.
Muovete il mouse su quel "+" e fate clic col pulsante sinistro.
La piega si distenderà, e potrete vedere il testo che contiene.
La colonna piega contiene un segno di "-" per ogni piegatura aperta.
Se fate clic su quel simbolo meno, la piega si chiuderà.
Ovviamente questo sarà possibile solo se avete un mouse funzionante.
Altrimenti, potete comunque usare "zo" per aprire una piegatura, e "zc" per chiuderla.

<p>

<p>
EVIDENZIARE LE DIFFERENZE IN VIM
<p>
La modalità diff può essere attivata in un altro modo, direttamente da dentro a Vim.
Editate il file "main.c", poi dividete la finestra e mostrate le differenze: >
<p>
:edit main.c :vertical diffsplit main.c~
<p>
Il comando ":vertical" viene usato per far sì che la finestra venga tagliata verticalmente.
Se lo omettete, avrete un taglio orizzontale.
<p>
Se avete un file patch o diff, potete usare un terzo modo per far partire la modalità diff.
Innanzitutto editate il file a cui le patch andranno applicate.
Poi dite a Vim il nome del file di patch: >
<p>
:edit main.c :vertical diffpatch main.c.diff
<p>
ATTENZIONE: Il file patch deve contenere solo una patch per il file che state editando.
Altrimenti avrete molti messaggi di errore, e alcuni file potrebbero essere aggiornati dalla patch in modo inaspettato.
La patch verrà applicata solo al file all'interno di Vim.
Il file sul vostro hard disk resterà immutato (fino a che deciderete di salvare il file).

<p>

<p>
TENERE UNITO LO SCORRIMENTO
<p>
Quando i file hanno più di una variazione, potete scrollare nel solito modo.
Vim cercherà di tenere allineato l'inizio di entrambe le finestre, per mostrare semplicemente le differenze, lato a lato.
Se volete disabilitare temporaneamente questa caratteristica, usate questo comando: >
<p>
:set noscrollbind
<p>

<p>
SALTARE ALLE DIFFERENZE
<p>
Se in qualche maniera avete disabilitato la funzione di piegatura, potrebbe essere difficile trovare le differenze.
Usate questo comando per saltare in avanti alla prossima differenza: >
<p>
]c
<p>
Per andare nell'altra direzione (verso l'alto) usare : >
<p>
[c
<p>
Mettere come prefisso un numero per saltare più volte.

<p>

<p>
ELIMINARE LE DIFFERENZE
<p>
Potete spostare delle parti di testo da una finestra all'altra.
Questo fa sì che siano rimosse le differenze, oppure che siano aggiunte le parti nuove.
Vim non tiene aggiornate le differenze in ogni occasione.
Per aggiornarle, usate questo comando: >
<p>
:diffupdate
<p>
Per eliminare una differenza, potete spostare il testo all'interno di un blocco evidenziato da una finestra all'altra.
Prendete ad esempio i file "main.c" e "main.c~" citati precedentemente.
Spostate il cursore sulla finestra di sinistra, sopra alla linea che nell'altra finestra era stata cancellata.
Ora usate questo comando: >
<p>
dp
<p>
Le differenze verranno rimosse mettendo il testo della finestra corrente nell'altra finestra.
"dp" sta per "diff put" (inserisci la differenza).
Potete anche fare la stessa cosa in un'altra maniera.
Spostate il cursore nella finestra di destra, sulla linea dove era stati inseriti dei "cambiamenti".
Ora usate questo comando: >
<p>
do
<p>
Le differenze in questo caso saranno rimosse prendendo la parte di testo dall'altra finestra.
Poiché a questo punto non ci saranno più differenze, Vim racchiuderà tutto il testo in una piega chiusa.
"do" sta per "diff obtain" (prendi le differenze).
"dg" sarebbe stato meglio, ma aveva già un significato diverso ("dgg" cancella tutto dal cursore fino alla prima linea compresa).

<p>
Per maggiori dettagli sulla modalità diff, vedere |vimdiff|.

<p>
============================================================================== *08.8*	Varie ed eventuali
<p>
L'opzione 'laststatus' può essere usata per specificare se e quando l'ultima finestra debba avere la linea di status:
<p>
0 mai 1 solo quando ci sono finestre divise (default) 2 sempre
<p>
Molti comandi che editano un altro file hanno una variante che divide la finestra.
Per i comandi nella linea dei comandi questo viene fatto preponendo una "s".
Ad esempio: ":tag" salta ad un certo punto contrassegnato, ":stag" divide in due la finestra e salta a quel punto.
Per i comandi in modalità normale viene preposta la combinazione CTRL-W.
CTRL-^ salta al file alternato, CTRL-W CTRL-^ divide in due la finestra ed edita il file alternato.

<p>
L'opzione 'splitbelow' può essere impostata per far sì che la finestra nuova appaia sotto alla finestra corrente.
L'opzione 'splitright' analogamente fa sì che appaia alla destra della finestra corrente.

<p>
Quando si divide in due la finestra si può premettere al comando un modificatore per decidere dove apparirà la finestra:
<p>
:leftabove {comando} a sinistra o sopra la finestra corrente :aboveleft {comando} idem :rightbelow {comando} a destra o sotto la finestra corrente :belowright {comando} idem :topleft {comando} nel punto più in alto o a sinistra della 			 finestra di Vim 	:botright {comando} nel punto più in alto o alla destra della 			 finestra di Vim
<p>

<p>
============================================================================== *08.9*	Linguette
<p>
Avrete notato che le finestre non si sovrappongono mai.
Questo implica che potete velocemente esaurire lo spazio sullo schermo.
La soluzione a questo si chiama Linguette.

<p>
Supponete di stare modificando "file_uno".
Per creare una nuova Linguetta, usate questo comando: >
<p>
:tabedit file_due
<p>
Questo comincerà a modificare "file_due" in una finestra grande come l'intera finestra di Vim.
Noterete una linguetta in alto coi nomi dei due file:
<p>
+----------------------------------+ 	| file_uno | /file_due/ __________X| (file_due è in grassetto) 	|/* file_due */			 | 	|due				 | 	|due				 | 	|~				 | 	|~				 | 	|~				 | 	|				 | 	+----------------------------------+
<p>
Avete ora due Linguette.
La prima contiene una finestra per "file_uno" e la seconda una finestra per "file_due".
Sono come due pagine una sopra l'altra, con una linguetta che esce da ogni pagina, e mostra il nome del file.

<p>
Ora, fate clic col mouse su "file_uno" nella linea in alto.
Otterrete:
<p>
+----------------------------------+ 	| /file_uno/ | file_due __________X| (file_uno è in grassetto) 	|/* file_uno */			 | 	|uno				 | 	|uno				 | 	|~				 | 	|~				 | 	|~				 | 	|				 | 	+----------------------------------+
<p>
Quindi potete passare da una Linguetta all'altra facendo clic sull'etichetta corrispondente nella linea in alto.
Se non avete un mouse o non volete usarlo, potete usare il comando "gt".
Per ricordarlo: Goto Tab.
<p>
Ora creiamo un'altra Linguetta col comando: >
<p>
:tab split
<p>
Questo crea una nuova Linguetta con una finestra che sta modificando lo stesso buffer della finestra in cui ci trovavamo:
<p>
+-------------------------------------+ 	| file_uno | /file_uno/ | file_due __X| (file_uno è in grassetto) 	|/* file_uno */			 | 	|uno				 | 	|uno				 | 	|~				 | 	|~				 | 	|~				 | 	|				 | 	+-------------------------------------+
<p>
Potete mettere ":tab" prima di ogni comando Ex che apre una finestra.
La finestra verrà aperta in una nuova linguetta.
Altro esempio: >
<p>
:tab help gt
<p>
Mostrerà il testo di help per "gt" in una nuova linguetta.

<p>
Ci sono alcune altre cose possibili con le Linguette:
<p>
- fare clic col mouse nello spazio dopo l'ultima etichetta 	La successiva linguetta sarà scelta, come con "gt".

<p>
- fare clic col mouse sulla "X" nell'angolo in alto a destra 	La Linguetta corrente sarà chiusa.
Tranne che ci siano modifiche 	non salvate nella Linguetta corrente.

<p>
- fare clic due volte col mouse sulla linea in alto 	Una nuova linguetta verrà creata.

<p>
- il comando "tabonly" 	Chiude tutte le Linguette, meno quella corrente.
Tranne che ci siano 	modifiche non salvate nella Linguetta corrente.

<p>
Per maggiori informazioni sulle linguette si veda |tab-page|.

<p>
==============================================================================
<p>
Capitolo seguente: |usr_09.txt| Usare la GUI
<p>
Per segnalazioni scrivere a vimdoc.it at gmail dot com oppure ad Antonio Colombo azc100 at gmail dot com *usr_09.txt*	Per Vim version 7.2.
Ultima modifica: 2006 Apr 24
<p>
VIM USER MANUAL - di Bram Moolenaar 		Traduzione di questo capitolo: Giorgio Luciano
<p>
Usare la GUI
<p>

<p>
Vim funziona usando un normale terminale.
Gvim può fare le stesse cose e qualcosina di più.
La GUI offre dei menù, una barra degli strumenti, delle barre di scorrimento ed altri elementi.
Questo capitolo è dedicato a tutte queste cose extra che la GUI offre.

<p>
|09.1|	Parti dell'interfaccia grafica (GUI) |09.2|	Usare il mouse |09.3|	Appunti (clipboard) |09.4|	Selezioni (Select mode)
<p>
Capitolo seguente: |usr_10.txt| Fare grandi modifiche Capitolo precedente: |usr_08.txt| Dividere le finestre 	 Indice: |usr_toc.txt|
<p>
============================================================================== *09.1*	Parti dell'interfaccia grafica (GUI)
<p>
Potreste avere sul desktop un'icona per avviare Gvim.
Altrimenti lo potrebbe fare uno di questi comandi: >
<p>
gvim file.txt 	vim -g file.txt
<p>
Se non funzionasse, non avete una versione di Vim con interfaccia grafica.
Prima dovete installarne una.
Vim aprirà una finestra e vi farà vedere il "file.txt" in essa.
Come appaia la finestra dipende dalla versione di Vim.
Potrebbe assomigliare all'immagine seguente (per quanto ciò possa essere visualizzato in ASCII!).
[le etichette in italiano nel seguito sono abbreviate - NdT]
<p>
+----------------------------------------------------+ | file.txt + (~/dir) - VIM			 X |<- titolo della finestra +----------------------------------------------------+ | File	Mod.
Stru.
Sinta.
Buffer Finest.
Aiuto |<- menù +----------------------------------------------------+ | aaa bbb ccc ddd eee fff	ggg hhh iii jjj |<- barra degli strumenti | aaa bbb ccc ddd eee fff	ggg hhh iii jjj | (toolbar) +----------------------------------------------------+ | file text					 | ^ | | ~						 | # | | ~						 | # |<- barra di scorrimento | ~						 | # | | ~						 | # | | ~						 | # | |						 | V | +----------------------------------------------------+
<p>
La maggior parte dello spazio a disposizione viene occupato dal file di testo.
Questo mostra il file allo stesso modo che in un terminale.
Forse con qualche colore diverso ed un altro font.

<p>

<p>
TITOLO DELLA FINESTRA
<p>
Nel punto più alto viene mostrato il titolo della finestra.
Viene disegnato dal vostro sistema window.
Vim imposterà il titolo per mostrare il nome del file corrente.
Prima viene il nome del file.
Poi alcuni caratteri speciali ed il nome della directory tra parentesi.
Possono essere presenti questi caratteri speciali:
<p>
-	Il file non può essere modificato (i.e., il file di help) 	+	Il file contiene dei cambiamenti 	=	il file è di sola lettura (read-only) 	=+	Il file è di sola lettura e contiene tuttavia dei cambiamenti
<p>
Se non viene visualizzato nulla avete un file comune e non modificato.

<p>

<p>
LA BARRA DEL MENU'
<p>
Sapete come funziona un menù, vero? Vim ha i soliti elementi, più qualcosa d'altro.
Esploratelo per avere un'idea di come possiate adoperarlo.
Un sottomenù importante è Modifica/Impostazioni Globali.
Dovreste trovare questi comandi:
<p>
Barra Strumenti Sì/No per visualizzare o nascondere la barra degli 				 strumenti (toolbar) 	Barra Sc.
in fondo Sì/No per visualizzare o nascondere la barra di 				 scorrimento in fondo 	Barra Sc.
a sinis.
Sì/No per visualizzare o nascondere la barra di 				 scorrimento a sinistra 	Barra Sc.
a destr.
Sì/No per visualizzare o nascondere la barra di 				 scorrimento a destra
<p>
Nella maggior parte dei sistemi potrete staccare i menù.
Selezionate il primo elemento del menù, quello che appare come una linea tratteggiata.
Otterrete una finestra separata con gli elementi del menù.
Rimarrà appesa sino a quando chiuderete la finestra.

<p>

<p>
LA BARRA DEGLI STRUMENTI (toolbar)
<p>
Contiene le icone dei comandi usati più di frequente.
Si spera che le icone siano autoesplicanti.
Ci sono didascalie per ottenere informazioni aggiuntive (muovete il puntatore del mouse su un'icona senza fare clic e aspettate per un secondo).

<p>
L'elemento del menù "Modifica/Impostazioni Globali/Barra Strumenti Sì/No" può essere usato per far scomparire la barra degli strumenti (toolbar).
Se non volete la barra degli strumenti usate questo comando nel vostro file vimrc: >
<p>
:set guioptions-=T
<p>
Ciò rimuove l'attributo 'T' dall'opzione 'guioptions'.
Anche altre parti della GUI possono venir abilitate o disabilitate con questa opzione.
Consultate l'help per ciò.

<p>

<p>
LE BARRE DI SCORRIMENTO (scrollbar)
<p>
Di default c'è una barra di scorrimento sulla destra.
E' la cosa più ovvia.
Quando dividete la finestra, ogni singola finestra avrà la propria scrollbar.
Potete far apparire una scrollbar orizzontale con l'elemento del menù Modifica/Impostazioni Globali/Barra Scorrimento in fondo Sì/No.
Ciò è utile in diff mode, o quando l'opzione 'wrap' fosse stata reimpostata (ne parleremo più avanti).

<p>
Quando ci sono finestre affiancate verticalmente, solo la finestra di destra avrà la scrollbar.
Comunque, quando muovete il cursore sulla finestra a sinistra, sarà questa ad essere controllata dalla scrollbar.
Ciò richiede un po' di tempo per essere effettuato.
Quando lavorate con finestre separate verticalmente, considerate di aggiungere una scrollbar sulla sinistra.
Ciò può essere fatto con un elemento del menù, o con l'opzione 'guioptions': >
<p>
:set guioptions+=l
<p>
Questo aggiunge l'attributo 'l' alle 'guioptions'.

<p>
============================================================================== *09.2*	Usare il mouse
<p>
Gli standard sono meravigliosi.
In Microsoft Windows, potete usare il mouse per selezionare in modo standard.
Anche X Window ha un sistema standard per usare il mouse.
Sfortunatamente questi due standard non sono uguali.
Fortunatamente potete personalizzare Vim.
Potete ottenere che il mouse appaia funzionare come un mouse X Window system, oppure come un mouse Microsoft Windows.
Il seguente comando fa funzionare il mouse come un X Window mouse.

<p>
Potete scegliere di usare i seguenti comandi Per avere il funzionamento standard di X Window : >
<p>
:behave xterm
<p>
Il seguente comando farà lavorare il mouse come in Microsoft Windows : >
<p>
:behave mswin
<p>
Il comportamento di default del mouse sui sistemi UNIX è xterm.
Il comportamento di default su un sistema Microsoft Windows viene selezionato durante il processo di installazione.
Per i dettagli su cosa siano i due comportamenti vedere |:behave|.
Qui segue un sommario.
<p>

<p>
COMPORTAMENTO DEL MOUSE XTERM
<p>
clic tasto sinistro		posizione del cursore trascinamento tasto sinistro	selezione testo in Visual mode clic tasto sinistro, con Shift	estende la selezione del testo fino al 				puntatore del mouse clic tasto centrale		incolla il testo dalla clipboard clic tasto destro		visualizza un menù a pop-up
<p>

<p>
COMPORTAMENTO DEL MOUSE MSWIN
<p>
clic tasto sinistro		posizione del cursore trascinamento tasto sinistro	seleziona testo in Select mode (v.
|09.4|) clic tasto sinistro, con Shift	estende la selezione del testo fino al 				puntatore del mouse clic tasto centrale		incolla il testo dalla clipboard clic tasto destro		visualizza un menù a pop-up
<p>

<p>
Il mouse può venire ulteriormente messo a punto.
Provate queste opzioni se volete cambiare il modo in cui funziona il vostro mouse:
<p>
'mouse'			in che modo il mouse è usato da Vim 	'mousemodel'		che effetto ha il clic del mouse 	'mousetime'		intervallo di tempo per il doppio clic 	'mousehide'		nasconde il mouse durante la digitazione 	'selectmode'		per scegliere se il mouse parta in Select o 				Visual mode
<p>
============================================================================== *09.3*	Appunti (clipboard)
<p>
Nella sezione |04.7| era stato spiegato l'utilizzo fondamentale della clipboard.
C'è una cosa essenziale da spiegare su X-window: ci sono davvero due posti per scambiare del testo tra programmi.
MS-Windows non ha ciò.
<p>
In X-Windows c'è la "current selection".
Questo è il testo attualmente evidenziato.
In Vim questa è la Visual area (si suppone che stiate usando le opzioni di default).
Potete incollare questa selezione senza ulteriori azioni.
Per esempio, in questo testo selezionate alcune parole col mouse.
Vim passerà al Visual mode ed evidenzierà il testo.
Ora aprite un altro Gvim senza l'argomento filename, in modo che appaia una finestra vuota.
Fare clic col pulsante centrale del mouse.
Il testo selezionato verrà inserito.
<p>
La "current selection" rimarrà valida finché non verrà selezionato altro testo.
Dopo avere incollato nell'altro Gvim, adesso selezionate qualche carattere su questa finestra.
Vi accorgerete che le parole che erano state prima selezionate nell'altra finestra di Gvim vengono mostrate in modo diverso.
Ciò significa che non si tratta più della selezione corrente.
<p>
Non siete costretti a selezionare il testo col mouse, usare i comandi della tastiera per il Visual mode funziona proprio nello stesso modo.

<p>
LA VERA CLIPBOARD
<p>
Ed ora l'altro posto con cui si può scambiare il testo.
Lo chiameremo "vera clipboard" per non fare confusione.
Spesso sia la "current selection" che la "vera clipboard" vengono chiamate clipboard, dovrete abituarvici.
Per mettere del testo nella vera clipboard, selezionate alcune parole in uno dei Gvim che avete avviato.
Ora usate la voce di menù Edit/Copy.
Il testo viene copiato nella vera clipboard.
Non potete vederlo se non avete qualche applicazione che mostri i contenuti della clipboard (i.e., klipper di KDE).
Ora scegliete l'altro Gvim, posizionate il cursore da qualche parte ed usate il menù Edit/Paste.
Vedrete che il testo viene inserito dalla vera clipboard.

<p>

<p>
USARLE ENTRAMBE
<p>
L'uso di una "current selection" e di una "vera clipboard" insieme può sembrare un po' confusionario.
Ma è molto utile.
Mostriamolo con un esempio. Usate un solo Gvim con un file di testo ed eseguite queste operazioni:
<p>
- Selezione due parole in Visual mode.
- Usate il menù Edit/Copy per mettere queste parole nella clipboard.
- Selezione un'altra parola in Visual mode.
- Usate l'elemento di menù Edit/Paste.
Dovrebbe succedere che la singola parola selezionata venga rimpiazzata con le due parole dalla clipboard.
- Muovete il puntatore del mouse e premete il tasto centrale.
Vedrete che la parola che avete appena sovrascritto con la clipboard viene inserita qui.

<p>
Se usate "current selection" e la "vera clipboard" con attenzione, potete fare molto utile editing con esse.

<p>

<p>
USARE LA TASTIERA
<p>
Se non vi piace usare il mouse, potete accedere alla current selection ed alla "vera clipboard" con due registri.
Il registro "* è per la selezione corrente.
Per far diventare il testo current selection, usate il Visual mode.
Per esempio, per selezionare l'intera linea digitate "V".
Per inserire la current selection prima del cursore digitate: >
<p>
"*P
<p>
Notate la maiuscola "P".
La minuscola "p" mette il testo dopo il cursore.
<p>
Il registro "+ è usato per la vera clipboard.
Per esempio, per copiare nella clipboard il testo dalla posizione del cursore fino alla fine della linea: >
<p>
"+y$
<p>
Ricordate, "y" sta per yank, che è il comando per copiare in Vim.
Per inserire i contenuti della vera clipboard prima del cursore: >
<p>
"+P
<p>
E' lo stesso che per la "current selection", ma usa il registro (+) invece di quello (*).

<p>
============================================================================== *09.4*	Selezioni (Select mode)
<p>
E ora qualcosa che viene usato più spesso su MS-Windows che in X-Windows.
Ma entrambi lo possono fare.
Avete già visto del Visual mode.
Il Select mode è simile al Visual mode, perché viene anch'esso usato per selezionare del testo.
Ma qui c'è però una ovvia differenza: mentre digitate il testo, il testo selezionato viene cancellato ed il testo digitato lo sostituisce.

<p>
Per iniziare a lavorare in Select mode, dovete prima abilitarlo (in MS-Windows è probabilmente sempre abilitato, ma potete farlo comunque): >
<p>
:set selectmode+=mouse
<p>
Ora usate il mouse per selezionare del testo.
E' evidenziato come in Visual mode.
Adesso premete una lettera.
Il testo selezionato viene cancellato, e la singola lettera lo rimpiazza.
Siete in Insert mode adesso, così potete continuare a digitare.
<p>
Poiché digitare del testo normale causa la cancellazione del testo selezionato, non potete usare i normali comandi di movimento "hjkl", "w", etc.
Invece dovrete usare i tasti di funzione assieme al tasto "shift" (maiuscolo).
<S-Left> (shitf sinistro) muove il cursore a sinistra.
Il testo selezionato viene cambiato come in Visual mode.
Gli altri tasti cursore usati con shift hanno effetti analoghi.
Anche <S-End> e <S-Home> funzionano così.
<p>
Potete affinare la modalità di lavoro di Select mode con l'opzione 'selectmode'.

<p>
==============================================================================
<p>
Capitolo seguente: |usr_10.txt| Fare grandi modifiche
<p>
Copyright: vedere |manual-copyright| vim:tw=78:ts=8:ft=help:norl:
<p>
Per segnalazioni scrivere a vimdoc.it at gmail dot com oppure ad Antonio Colombo azc100 at gmail dot com *usr_10.txt*	Per Vim version 7.2.
Ultima modifica: 2006 Nov 05
<p>
VIM USER MANUAL - di Bram Moolenaar 	 Traduzione di questo capitolo: Gian Piero Carzino
<p>
Fare grandi modifiche
<p>

<p>
Nel capitolo 4 sono stati mostrati molti modi per fare piccole modifiche.
Questo capitolo affronta cambiamenti ripetuti o che possono modificare grandi quantità di testo.
Il modo Visual permette di fare varie cose con blocchi di testo.
Usate un programma esterno per fare cose veramente complesse.
<p>
|10.1| Registrare e rieseguire comandi |10.2| Sostituzione |10.3| Intervallo di esecuzione dei comandi |10.4| Il comando global |10.5| Modo Visual block |10.6| Leggere e scrivere parte di un file |10.7| Formattare un testo |10.8| Cambiare Maiuscole/minuscole |10.9| Usare un programma esterno
<p>
Capitolo seguente: |usr_11.txt| Recupero dopo un blocco Capitolo precedente: |usr_09.txt| Usare la GUI 	 Indice: |usr_toc.txt|
<p>
============================================================================== *10.1*	Registrare e rieseguire comandi
<p>
Il comando "." ripete la precedente modifica.
Ma come fare se volete ottenere qualcosa di più di una singola modifica? Ecco dove entra in gioco la registrazione dei comandi.
Si compone di tre passi:
<p>
1.
Il comando "q{registro}" fa partire la registrazione della sequenza di tasti premuti nel registro di nome {registro}.
Il nome del registro deve essere un carattere fra a e z.
2.
Scrivete i vostri comandi.
3. Per terminare la registrazione, premete q (da solo).
<p>
Ora potete eseguire la macro scrivendo il comando "@{registro}".

<p>
Date un'occhiata a come si possono usare questi comandi in pratica.
Avete una lista di nomi di file come questa:
<p>
stdio.h ~ 	fcntl.h ~ 	unistd.h ~ 	stdlib.h ~
<p>
E quello che volete ottenere è:
<p>
#include "stdio.h" ~ 	#include "fcntl.h" ~ 	#include "unistd.h" ~ 	#include "stdlib.h" ~
<p>
Cominciate portandovi sul primo carattere della prima riga.
Poi eseguite i seguenti comandi:
<p>
qa			Inizia a registrare una macro nel registro a.
^			Vai all'inizio della riga.
i#include "<Esc>	Inserisci la stringa #include " all'inizio 				della riga.
$			Vai alla fine della riga.
a"<Esc>			Aggiungi il carattere doppie virgolette (") 				alla fine della riga.
j			Vai alla riga successiva.
q			Termina la registrazione della macro.

<p>
Ora che avete fatto il lavoro una volta, potete ripetere la modifica scrivendo il comando "@a" tre volte.
Il comando "@a" può essere preceduto da un numero, che farà eseguire la macro altrettante volte.
In questo caso scrivereste: >
<p>
3@a
<p>

<p>
SPOSTARSI ED ESEGUIRE
<p>
Le righe che volete cambiare potrebbero essere in vari posti.
Semplicemente spostate il cursore in ognuno dei posti e usate il comando "@a".
Se lo avete già fatto una volta, lo potete ripetere con "@@".
È ancora più facile da scrivere.
Se ora eseguite il registro b con "@b", il prossimo "@@" userà il registro b.
Se confrontate l'esecuzione di macro con l'uso di ".", troverete molte differenze.
Per prima cosa, "." può solo ripetere una modifica.
Come invece abbiamo visto nell'esempio qui sopra, "@a" può fare molte modifiche, e anche spostamenti.
Secondariamente, "." può ricordare solo l'ultima modifica.
Eseguire un registro vi permette di fare tutte le modifiche che volete, e poter sempre usare "@a" per ripetere quei comandi che sono stati registrati.
Infine potete usare 26 diversi registri.
Quindi potete ricordare 26 diverse sequenze di comandi da eseguire.

<p>

<p>
USARE I REGISTRI
<p>
I registri usati per registrare le macro sono gli stessi che si usano per i comandi yank e delete.
Questo permette di mescolare la registrazione con altri comandi di manipolazione dei registri.
Supponiamo che abbiate registrato alcuni comandi nel registro n.
Quando lo eseguite con "@n" vi accorgete che avete sbagliato qualcosa.
Potreste riprovare la registrazione, ma c'è il rischio di fare un altro errore.
Usate invece questo trucco:
<p>
G			Vai alla fine del file.
o<Esc>			Crea una riga vuota.
"np			Riversare il testo contenuto nel registro n.
Potete vedere i comandi che avete registrato 				come semplice testo nel file.
{modifiche}		Modificate i comandi sbagliati.
Non è altro 				che normale editing di un testo.
0			Vai all'inizio della riga.
"ny$			Copiare i comandi corretti nel registro n.
dd			Cancellare la riga dal file.

<p>
Ora potete eseguire i comandi corretti con "@n".
(Se i comandi che avevate registrato comprendevano degli <a capo>, adattate di conseguenza le due ultime righe nell'esempio per comprendere tutte le linee della macro.)
<p>

<p>
AGGIUNGERE AD UN REGISTRO
<p>
Finora abbiamo usato le lettere minuscole per i nomi di registro.
Per aggiungere in fondo ad un registro, usate le lettere maiuscole.
Supponiamo che abbiate registrato nel registro c un comando per modificare una parola.
Funziona, ma volete aggiungere la ricerca della successiva parola da modificare.
Lo si può fare con: >
<p>
qC/word<Enter>q
<p>
Cominciate con "qC", che registra nel registro c aggiungendo in fondo.
Quindi scrivere in un registro con nome maiuscolo significa aggiungere in fondo al registro con la stessa lettera, ma minuscola.

<p>
Questo vale sia per la registrazione che per i comandi yank e delete.
Supponiamo per esempio che vogliate raccogliere una sequenza di righe in un registro.
Copiate la prima riga con: >
<p>
"aY
<p>
Ora spostatevi sulla seconda riga, e scrivete: >
<p>
"AY
<p>
Ripetete questo comando per tutte le righe da aggiungere.
Alla fine il registro a conterrà tutte le righe, nell'ordine in cui le avete copiate.

<p>
============================================================================== *10.2*	Sostituzione 						*find-replace*
<p>
Il comando ":substitute" vi permette di fare sostituzioni di stringhe su un insieme di righe.
La forma generale di questo comando è la seguente: >
<p>
:[range]substitute/from/to/[flags]
<p>
Questo comando modifica la stringa "from" nella stringa "to" nelle righe specificate da [range].
Per esempio, potete cambiare "il Professor" in "l'Insegnante" in tutte le righe con il seguente comando: >
<p>
:%substitute/il Professor/l'Insegnante/ < 	Note: Il comando ":substitute" non viene quasi mai scritto per intero.
La maggior parte delle volte si usa la forma abbreviata ":s".
Da qui 	in poi useremo l'abbreviazione.

<p>
Il "%" prima del comando indica che il comando va applicato a tutte le righe.
Senza una indicazione di ambito di applicazione, ":s" opera solo sulla riga corrente.
Il prossimo capitolo affronta più approfonditamente il tema degli ambiti di applicazione dei comandi.

<p>
Per default, il comando ":substitute" modifica solo la prima stringa trovata di ogni riga.
Per esempio, il precedente comando modifica la riga:
<p>
Oggi il Professor Smith ha criticato il Professor Johnson.
~
<p>
in:
<p>
Oggi l'Insegnante Smith ha criticato il Professor Johnson.
~
<p>
Per cambiare ogni stringa corrispondente nella riga, dovete aggiungere il flag (globale) g.
Il comando: >
<p>
:%s/il Professor/l'Insegnante/g
<p>
produce (a partire dalla riga originale):
<p>
Oggi l'Insegnante Smith ha criticato l'Insegnante Johnson.
~
<p>
Altri flag sono p (print), che fa stampare al comando ":substitute" l'ultima linea modificata.
Il flag c (conferma) fa chiedere al comando ":substitute" conferma prima di eseguire una modifica.
Scrivete il seguente comando: >
<p>
:%s/il Professor/l'Insegnante/c
<p>
Vim trova la prima volta che ricorre "il Professor" e visualizza il testo che sta per modificare.
Vi chiede: >
<p>
sostituire con l'Insegnante (y/n/a/q/l/^E/^Y)?
<p>
A questo punto potete rispondere con una delle seguenti lettere:
<p>
y		Yes; fai questa modifica.
n		No; salta questa ricorrenza.
a		All; fai questa modifica e tutte le rimanenti senza 			ulteriore conferma.
q		Quit; fine delle modifiche.
l		Last; fai ancora questa modifica e poi termina.
CTRL-E		Fai scorrere il testo una riga in su.
CTRL-Y		Fai scorrere il testo una riga in giù.

<p>
La parte "from" del comando di sostituzione è in effetti una espressione.
Lo stesso tipo di espressione che si usa per il comando di ricerca.
Per esempio il comando che segue sostituisce "the" solo se compare all'inizio di una riga: >
<p>
:s/^the/these/
<p>
Se nella parte "from" o nella parte "to" c'è una barra (/), dovete mettere un backslash (\) prima di essa.
Un modo più semplice è usare un altro carattere come separatore invece della barra.
Ad esempio un segno più: >
<p>
:s+uno/due+uno o due+
<p>
============================================================================== *10.3*	Ambito di applicazione dei comandi
<p>
Il comando ":substitute", e molti altri comandi che iniziano per ":", possono essere applicati ad un insieme di righe.
Questo viene chiamato intervallo.
La forma più semplice di intervallo è {numero},{numero}. Per esempio: >
<p>
:1,5s/questo/quello/g
<p>
Esegue il comando di sostituzione nelle righe dalla 1 alla 5.
Anche la riga 5 viene inclusa.
L'intervallo è sempre posto prima del comando.
<p>
Un singolo numero può essere usato per indicare una specifica riga: >
<p>
:54s/Presidente/Pazzo/
<p>
Alcuni comandi operano sull'intero file quando non si specifica un intervallo.
Per farli operare sulla riga corrente si può usare l'indirizzo ".".
Il comando write funziona in questo modo.
Senza un intervallo, salva l'intero file.
Per fargli salvare in un file solo la riga corrente: >
<p>
:.write altrofile
<p>
La prima riga ha sempre il numero uno.
E l'ultima? Per indicare questa si usa il carattere "$".
Per esempio, per fare una sostituzione dalla riga del cursore alla fine del file: >
<p>
:.,$s/yes/no/
<p>
L'intervallo "%" che abbiamo usato prima altro non è che una abbreviazione di "1,$", cioè dalla prima all'ultima riga.

<p>

<p>
USARE UNO SCHEMA DI RICERCA IN UN INTERVALLO
<p>
Supponiamo che stiate modificando un capitolo di un libro, e vogliate sostituire tutti i giallo con grigio.
Ma solo nel capitolo corrente, non nel prossimo.
Voi sapete che la parola "Capitolo" ad inizio riga si trova solo all'inizio dei capitoli.
Questo comando ottiene il risultato desiderato: >
<p>
:?^Capitolo?,/^Capitolo/s=giallo=grigio=g
<p>
Come potete vedere si usa due volte uno schema di ricerca.
Il primo "?^Capitolo?" trova la riga precedente che corrisponde a questo schema.
Quindi l'intervallo ?schema? serve a cercare all'indietro.
Analogamente, "/^Capitolo/" serve a cercare in avanti l'inizio del prossimo capitolo.
Per rendere più chiaro il comando, abbiamo usato il carattere "=" invece della barra nel comando di sostituzione.
Si poteva anche usare la barra o un altro carattere.

<p>

<p>
AGGIUNTE E SOTTRAZIONI
<p>
C'è un piccolo errore nel comando che abbiamo appena descritto: se nel titolo del capitolo successivo ci fosse la parola "giallo" sarebbe stata sostituita anch'essa.
Forse era ciò che volevate, ma se invece non volevate modificarla? In tal caso potevate indicare uno spostamento.
Per cercare uno schema e poi indicare la riga precedente: >
<p>
/^Capitolo/-1
<p>
Potete usare qualunque numero al posto di 1.
Per indicare la seconda riga dopo quella individuata da uno schema: >
<p>
/^Capitolo/+2
<p>
Gli spostamenti si possono usare anche con altri tipi di voci negli intervalli.
Guardate questo: >
<p>
:.+3,$-5
<p>
Questo indica un intervallo che inizia tre righe sotto il cursore e finisce 5 righe prima dell'ultima riga del file.

<p>

<p>
USARE I SEGNALIBRI
<p>
Invece di trovare il numero di riga di certe posizioni, ricordarseli e poi scriverli in un intervallo, potete usare i segnalibri.
Piazzate i segnalibri come indicato nel capitolo 3.
Per esempio, usate "mt" per segnare l'inizio di una zona e "mb" per segnare la fine.
Potete poi usare il seguente intervallo per indicare le righe fra i due segnalibri (comprese le righe segnate): >
<p>
:'t,'b
<p>

<p>
MODO VISUAL E INTERVALLI
<p>
Potete selezionare del testo in modo Visual.
Se poi premete ":" per scrivere un comando di questo tipo, vedrete: >
<p>
:'<,'>
<p>
Ora potete scrivere il comando e sarà applicato all'insieme di righe che era stato selezionato visualmente.

<p>
Note: Quando si seleziona in modo Visual parte di una riga, o usando 	CTRL-V un blocco di testo, i comandi ":" si applicano ugualmente a 	righe intere.
Questo comportamento potrebbe cambiare in future 	versioni di Vim.

<p>
I '< e '> sono in effetti dei segnalibri, posti all'inizio e alla fine della selezione Visuale.
I segnalibri rimangono fissi finché non viene fatta un'altra selezione Visuale.
Quindi potete usare il comando "'<" per saltare all'inizio dell'area selezionata Visualmente.
E potete mescolare i segnalibri con altri elementi: >
<p>
:'>,$
<p>
Questo individua le righe dalla fine dell'area Visuale alla fine del file.

<p>

<p>
UN CERTO NUMERO DI RIGHE
<p>
Quando sapete quante righe volete modificare, potete scrivere il numero e poi ":".
Per esempio, scrivendo "5:", otterrete: >
<p>
:.,.+4
<p>
Ora potete scrivere il comando che desiderate.
Userà l'intervallo da "." (riga corrente) a ".+4" (quattro righe sotto).
Appunto cinque righe in totale.

<p>
============================================================================== *10.4*	Il comando global
<p>
Il comando ":global" è una delle caratteristiche più potenti di Vim.
Vi permette di trovare una corrispondenza per uno schema ed eseguire lì un certo comando.
La forma generale è: >
<p>
:[range]global/{schema}/{comando}
<p>
È simile al comando ":substitute".
ma invece di sostituire il testo individuato con l'altro testo, esegue il comando {comando}.

<p>
Note: Il comando eseguito da ":global" deve essere uno che inizia con 	":".
I comandi del modo Normal non possono essere eseguiti direttamente.
Il comando |:normal| può eseguirli per voi.

<p>
Supponiamo che vogliate cambiare "foobar" in "barfoo", ma solo all'interno dei commenti in stile C++.
Questi commenti iniziano con "//".
Usate il comando: >
<p>
:g+//+s/foobar/barfoo/g
<p>
Questo comando inizia per ":g".
È la forma abbreviata di ":global", così come ":s" è la forma abbreviata di ":substitute".
Segue poi lo schema, fra due segni più.
Siccome lo schema che stiamo cercando contiene delle barre, usiamo i segni più come separatori.
Infine il comando di sostituzione che cambia "foobar" in "barfoo".
L'intervallo di default per il comando global è l'intero file.
Questo spiega perché non è stato specificato un intervallo in questo esempio.
Notare la differenza col comando ":substitute", che viene eseguito solo su una riga, se non è specificato un intervallo.
Il comando non è perfetto, poiché agisce anche sulle righe in cui "//" appare a metà, e la sostituzione viene applicata anche prima del "//".

<p>
Proprio come il comando ":substitute", si può usare ogni schema.
Quando avrete imparato schemi più complicati, li potrete usare anche qui.

<p>
============================================================================== *10.5*	Modo Visual block
<p>
Con CTRL-V potete iniziare la selezione di un'area rettangolare di testo.
Ci sono alcuni comandi che fanno operazioni speciali sui blocchi di testo.

<p>
Speciale è ad esempio l'uso del comando "$" mentre si è in modo Visual block.
Quando l'ultimo comando di spostamento usato è "$", tutte le righe selezionate in modo Visual block si estendono fino a fine riga, anche se la riga col cursore è più corta.
Questo comportamento rimane finché non si usa un comando di spostamento orizzontale.
Quindi l'uso "j" lo mantiene, "h" lo interrompe.
<p>

<p>
INSERIMENTO DI TESTO
<p>
Il comando "I{stringa}<Esc>" inserisce il testo {stringa} in ogni riga, alla sinistra del blocco Visuale.
Iniziate premendo CTRL-V per entrare nel modo Visual block.
Ora spostate il cursore per definire il blocco che desiderate.
Poi scrivete I per entrare in modo Insert, e di seguito il testo da inserire.
Mentre scrivete, il testo compare solo sulla prima riga.
Dopo aver premuto <Esc> per terminare l'inserimento, il testo sarà automaticamente inserito in tutte le altre righe della selezione Visuale.
Esempio:
<p>
include one ~ 	include two ~ 	include three ~ 	include four ~
<p>
Spostate il cursore alla "o" di "one" e premete CTRL-V.
Spostatelo in giù con "3j" fino a "four".
Ora avete un blocco selezionato che si estende per quattro righe.
Ora scrivete: >
<p>
Imain.<Esc>
<p>
Il risultato è:
<p>
include main.one ~ 	include main.two ~ 	include main.three ~ 	include main.four ~
<p>
Se il blocco include righe corte che non arrivano dentro il blocco, il testo non viene inserito in queste righe.
Per esempio, fate una selezione Visual block che comprende le parole "long" della prima e dell'ultima riga di questo testo (quindi la seconda riga non ha testo selezionato):
<p>
This is a long line ~ 	short ~ 	Any other long line ~
<p>
^^^^ blocco selezionato
<p>
Ora usate il comando "Ivery <Esc>".
Il risultato è:
<p>
This is a very long line ~ 	short ~ 	Any other very long line ~
<p>
Nella riga corta non è stato inserito alcun testo.

<p>
Se la stringa che inserite contiene un <a capo>, il comando "I" si comporta come un comando di inserimento Normale, e agisce solo sulla prima riga del blocco.

<p>
Il comando "A" si comporta alla stessa maniera, salvo che aggiunge il testo dopo il lato destro del blocco.
Ed inserisce testo in una linea breve.
Quindi potete scegliere se volete o meno aggiungere testo ad una linea breve.
C'è un caso speciale per "A": selezionate un blocco Visuale e poi usate "$" per farlo estendere fino alla fine di ogni riga.
Ora usare "A" farà aggiungere il testo alla fine di ogni riga.
Usando lo stesso esempio di prima, e scrivendo "$A XXX<Esc>", otterrete questo risultato:
<p>
This is a long line XXX ~ 	short XXX ~ 	Any other long line XXX ~
<p>
Per far questo è proprio necessario usare il comando "$".
Vim si ricorda che è stato usato.
Creare la stessa selezione spostando il cursore alla fine della riga più lunga con altri comandi di spostamento non ottiene lo stesso risultato.

<p>

<p>
MODIFICARE IL TESTO
<p>
Il comando "c" in modo Visual block cancella il blocco e vi pone in modo Insert per permettervi di scrivere una stringa.
La stringa sarà inserita in ogni riga del blocco.
Iniziando con la stessa selezione delle parole "long" come sopra, e poi scrivendo "c_LONG_<Esc>", otterrete questo:
<p>
This is a _LONG_ line ~ 	short ~ 	Any other _LONG_ line ~
<p>
Come nel caso di "I", la riga più corta non viene modificata.
Inoltre non ci può essere un <a capo> nel testo inserito.

<p>
Il comando "C" cancella il testo dal lato sinistro del blocco fino alla fine della riga.
Vi immette quindi in modo Inserimento, così che possiate scrivere una stringa, che verrà aggiunta alla fine di ogni riga.
Partendo sempre dallo stesso testo, e scrivendo "Cnew text<Esc>" otterrete:
<p>
This is a new text ~ 	short ~ 	Any other new text ~
<p>
Notate che, anche se era selezionata solo la parola "long", è stato cancellato anche il testo che la segue.
Così l'unica cosa che conta davvero è la posizione del lato sinistro del blocco Visuale.
Anche in questo caso le righe corte che non raggiungono il blocco sono escluse.

<p>
Altri comandi che cambiano i caratteri nel blocco sono:
<p>
~	inverti maiuscole/minuscole	(a -> A e A -> a) 	U	rendi maiuscole			(a -> A e A -> A) 	u	rendi minuscole			(a -> a e A -> a)
<p>

<p>
RIEMPIRE CON UN CARATTERE
<p>
Per riempire l'intero blocco con un carattere, usate il comando "r".
Ripartendo sempre dallo stesso esempio di prima, e scrivendo "rx":
<p>
This is a xxxx line ~ 	short ~ 	Any other xxxx line ~
<p>
Note: Se volete includere nel blocco anche i caratteri che sono oltre 	la fine della riga, guardate la caratteristica 'virtualedit' nel 	capitolo 25.

<p>

<p>
SPOSTAMENTO
<p>
Il comando ">" sposta il testo selezionato a destra di una determinata quantità inserendo degli spazi.
Il punto di partenza per questo spostamento è il lato sinistro del blocco Visuale.
Sempre con lo stesso esempio, ">" dà questo risultato:
<p>
This is a	 long line ~ 	short ~ 	Any other	 long line ~
<p>
La quantità di spostamento è specificata con l'opzione 'shiftwidth'.
Per cambiarla a 4 spazi: >
<p>
:set shiftwidth=4
<p>
Il comando "<" rimuove la stessa quantità di spazio bianco dal lato sinistro del blocco.
Questo comando è limitato dalla quantità di testo che c'è effettivamente; quindi se c'è meno spazio bianco della quantità richiesta, rimuove quello che può.

<p>

<p>
UNIRE LE RIGHE
<p>
Il comando "J" unisce tutte le righe selezionate in una sola riga.
Rimuove quindi le interruzioni di riga.
In effetti l'interruzione di riga, lo spazio bianco ad inizio riga e quello a fine riga sono sostituiti da un singolo spazio.
Dopo un punto di fine riga, vengono usati due spazi (ciò può essere modificato con l'opzione 'joinspaces').
Usiamo l'esempio con cui siamo ormai familiari.
Il risultato dell'uso del comando "J" è:
<p>
This is a long line short Any other long line ~
<p>
Il comando "J" non richiede che sia stata fatta una selezione di tipo blocco.
Funziona allo stesso identico modo con le selezioni di tipo "v" e "V".

<p>
Se non volete che gli spazi vengano alterati, usate il comando "gJ".

<p>
============================================================================== *10.6*	Leggere e scrivere parte di un file
<p>
Quando state scrivendo un messaggio e-mail, potreste desiderare di includere un altro file.
Questo si può fare con il comando ":read {nomefile}".
Il testo dell'altro file viene inserito dopo la riga del cursore.
Se partiamo da questo testo:
<p>
Ciao John, ~ 	Ecco il diff che corregge l'errore: ~ 	Saluti, Pierre.
~
<p>
Spostate il cursore nella seconda riga e scrivete: >
<p>
:read patch
<p>
Il file di nome "patch" verrà inserito, ottenendo:
<p>
Ciao John, ~ 	Ecco il diff che corregge l'errore: ~ 	2c2 ~ 	<	for (i = 0; i <= length; ++i) ~ 	--- ~ 	>	for (i = 0; i < length; ++i) ~ 	Saluti, Pierre.
~
<p>
Il comando ":read" accetta un intervallo.
Il file verrà inserito dopo l'ultima riga di questo intervallo.
Così ":$r patch" aggiunge il file "patch" alla fine del file.
E se voleste inserire il file prima della prima riga? Questo si può fare con il numero di riga zero.
Questa riga non esiste in realtà, e sareste avvisati con un messaggio d'errore usandola nella maggior parte dei comandi.
Ma è permesso scrivere: >
<p>
:0read patch
<p>
Il file "patch" sarà posto prima della prima riga del file.

<p>

<p>
SCRIVERE UN GRUPPO DI RIGHE
<p>
Per scrivere un gruppo di righe in un file si può usare il comando ":write".
Senza specificare un intervallo salva l'intero file.
Se si specifica un intervallo, solo le righe indicate vengono scritte: >
<p>
:.,$write tempo
<p>
Questo scrive le righe dal cursore fino alla fine del file nel file "tempo".
Se quest'ultimo file esiste già si otterrà un messaggio di errore.
Vim impedisce di sovrascrivere accidentalmente un file già esistente.
Se proprio volete sovrascriverlo, aggiungete un !: >
<p>
:.,$write! tempo
<p>
ATTENZIONE: il ! deve seguire immediatamente il comando ":write", senza spazi.
Altrimenti diventa un comando filtro, che è spiegato più avanti in questo capitolo.

<p>

<p>
AGGIUNGERE AD UN FILE
<p>
Nella prima sezione di questo capitolo viene spiegato come raccogliere un certo numero di righe in un registro.
Lo stesso si può fare per raccogliere righe in un file.
Scrivete la prima riga con questo comando: >
<p>
:.write raccolta
<p>
Ora spostate il cursore sulla seconda riga che volete raccogliere, e scrivete: >
<p>
:.write >>raccolta
<p>
Il ">>" dice a Vim che il file "raccolta" non deve essere scritto da capo, ma che la riga deve essere aggiunta alla fine.
Potete ripetere quest'ultimo comando tante volte quante volete.

<p>
============================================================================== *10.7*	Formattare un testo
<p>
Quando state scrivendo del semplice testo, è bello che la lunghezza di ogni riga sia automaticamente limitata per stare nella finestra.
Perché questo succeda mentre state inserendo il testo, assegnate un valore all'opzione 'textwidth': >
<p>
:set textwidth=72
<p>
Se ricordate, nel file di esempio di vimrc si usava questo comando in ogni file di testo.
Così, se state usando quel file vimrc, state già usando quel comando.
Per verificare il valore corrente di 'textwidth': >
<p>
:set textwidth
<p>
Ora le righe verranno spezzate per contenere al massimo 72 caratteri.
Ma se voi inserite del testo a metà di una riga, o se cancellate qualche parola, le righe diverranno troppo lunghe o troppo corte.
Vim non le rimette in forma automaticamente.
Per dire a Vim di formattare il paragrafo corrente: >
<p>
gqap
<p>
Questo inizia con il comando "gq", che è un operatore.
Segue "ap", l'oggetto di testo su cui deve operare, che significa "un paragrafo".
I paragrafi sono separati gli uni dagli altri da una riga vuota.

<p>
Note: 	Una riga bianca, che contiene spazio bianco, NON separa i paragrafi.
Questo è molto difficile da notare!
<p>
Invece di "ap" potreste usare ogni spostamento o oggetto di testo.
Se i vostri paragrafi sono separati correttamente, potete usare il seguente comando per formattare l'intero file: >
<p>
gggqG
<p>
"gg" vi porta alla prima riga, "gq" è l'operatore di formattazione e "G" è lo spostamento che salta all'ultima riga.

<p>
Se invece i vostri paragrafi non sono definiti in modo chiaro, potete formattare le righe che selezionate manualmente.
Muovete il cursore alla prima riga che volete formattare.
Iniziate con il comando "gqj".
Questo formatta la riga corrente e la successiva.
Se la prima riga era corta, saranno aggiunte parole prese dalla seconda.
Se era troppo lunga, alcune parole saranno spostate nella successiva.
Il cursore si sposta alla seconda riga.
Ora potete usare "." per ripetere il comando. Continuate a farlo finché raggiungete la fine del testo che volevate formattare.
<p>
============================================================================== *10.8*	Cambiare Maiuscole/minuscole
<p>
Supponiamo che abbiate del testo con i titoli di sezione in lettere minuscole.
Volete cambiare la parola "sezione" in tutte maiuscole.
Fatelo con l'operatore "gU".
Iniziate con il cursore nella prima colonna: >
<p>
gUw <	sezione titolo	 ----> SEZIONE titolo
<p>
L'operatore "gu" fa esattamente l'opposto: >
<p>
guw <	SEZIONE titolo	 ----> sezione titolo
<p>
Potete anche usare "g~" per cambiare tutte le maiuscole in minuscole e viceversa.
Tutti questi sono operatori, quindi lavorano con ogni comando di spostamento, con oggetti di testo e in modo Visual.
Per far lavorare un operatore sulle righe lo si raddoppia.
L'operatore di cancellazione è "d", quindi per cancellare una riga si scrive "dd".
Analogamente "gugu" mette in minuscolo un'intera riga.
Questo può essere abbreviato "guu".
"gUgU" si abbrevia "gUU" e "g~g~" diventa "g~~".
Esempio: > 				g~~ <	Some GIRLS have Fun ----> sOME girls HAVE fUN ~
<p>
============================================================================== *10.9*	Usare un programma esterno
<p>
Vim ha un insieme di comandi molto potente, può fare qualunque cosa.
Ma ci sono cose che un comando esterno può fare meglio o più velocemente.
Il comando "!{spostamento}{programma}" prende un blocco di testo e lo filtra attraverso un programma esterno.
In altre parole, fa partire il programma di sistema di nome {programma}, fornendogli il blocco di testo rappresentato da {spostamento} come input.
L'output di questo comando poi sostituisce il blocco selezionato.
Siccome questo è un po' troppo sintetico se non si conoscono i filtri UNIX, guardate un esempio.
Il comando sort ordina un file.
Se eseguite il seguente comando, il file non ordinato input.txt sarà messo in ordine alfabetico e scritto nel file output.txt.
(Questo funziona sia in UNIX che in Microsoft Windows).
>
<p>
sort <input.txt >output.txt
<p>
Ora facciamo la stessa cosa in Vim.
Volete ordinare le righe da 1 a 5 di un file.
Iniziate ponendo il cursore sulla riga 1.
Poi eseguite il seguente comando: >
<p>
!5G
<p>
Il "!" dice a Vim che state eseguendo una operazione di filtro.
L'editor Vim si aspetta ora uno spostamento, che gli indichi quale parte del file deve filtrare.
Il comando "5G" dice a Vim di andare alla riga 5, così sa che la parte da filtrare va dalla riga 1 (la riga corrente) alla 5.
In previsione del filtraggio, il cursore si sposta in fondo allo schermo e si presenta un !.
Ora potete scrivere il nome del programma filtro, in questo caso "sort".
Quindi il vostro comando completo è: >
<p>
!5Gsort<Enter>
<p>
Il risultato è che il programma sort viene eseguito sulle prime cinque righe.
L'uscita del programma sostituisce queste righe.

<p>
line 55			 line 11 	line 33			 line 22 	line 11		-->	 line 33 	line 22			 line 44 	line 44			 line 55 	last line		 last line
<p>
Il comando "!!" filtra la riga corrente attraverso un filtro.
In UNIX il comando "date" stampa la data e ora corrente.
"!!date<Enter>" sostituisce la riga corrente con l'output di "date".
Questo è utile per aggiungere data e ora ad un file.

<p>

<p>
QUANDO NON FUNZIONA
<p>
Far partire una shell, inviarle testo e catturare il risultato richiede che Vim conosca esattamente come funziona la shell.
Quando avete problemi per filtrare, controllate i valori di queste opzioni:
<p>
'shell'		specifica il programma che Vim usa per eseguire i 			programmi esterni.
'shellcmdflag'	argomento per passare un comando alla shell 	'shellquote'	virgolette da usare intorno al comando 	'shellxquote'	virgolette da usare intorno al comando e alla 			ridirezione 	'shelltype'	tipo di shell (solo per l'Amiga) 	'shellslash'	usare le barre normali nel comando (solo per 			MS-Windows e simili)
<p>
In ambiente Unix questo è raramente un problema, perché ci sono due tipi di shell: quelle tipo "sh" e quelle tipo "csh".
Vim controlla l'opzione 'shell' e imposta le corrispondenti opzioni automaticamente, a seconda che trovi "csh" da qualche parte in 'shell'.
In MS-Windows, invece, ci sono molte diverse shell e potrebbe essere necessario calibrare le opzioni per far funzionare il filtraggio.
Per ulteriori informazioni, vedere l'aiuto delle opzioni.

<p>

<p>
LEGGERE L'OUTPUT DEI COMANDI
<p>
Per leggere il contenuto della directory corrente e metterlo nel file, usare:
<p>
in Unix: > 	:read !ls in MS-Windows: > 	:read !dir
<p>
Il risultato del comando "ls" o "dir" è catturato e inserito nel testo, sotto il cursore.
Questo è analogo a leggere un file, eccetto che si usa il "!" per dire a Vim che segue un comando.
Il comando può avere degli argomenti.
E si può inserire un intervallo per dire a Vim dove mettere le righe: >
<p>
:0read !date -u
<p>
Questo inserisce l'ora e data corrente in formato UTC all'inizio del file (Se avete un comando "date" che accetta l'argomento "-u").
Notate la differenza rispetto a usare "!!date": quello sostituiva una riga, mentre ":read !date" la inserisce.

<p>

<p>
INVIARE DEL TESTO AD UN COMANDO
<p>
Il comando Unix "wc" conta le parole.
Per contare le parole nel corrente file: >
<p>
:write !wc
<p>
Questo è lo stesso comando che abbiamo già incontrato, ma invece del nome di un file viene posto il carattere "!" e il nome di un comando esterno.
Il testo che verrebbe scritto viene invece inviato al comando specificato come suo standard input.
Il risultato potrebbe assomigliare a:
<p>
4 47 249 ~
<p>
Il comando "wc" è molto sintetico.
Questo risultato vuol dire che avete 4 righe, 47 parole e 249 caratteri.

<p>
Attenti a questo errore: >
<p>
:write! wc
<p>
Questo scriverà il file "wc" nella directory corrente, forzando la scrittura nel caso ce ne sia già uno.
Gli spazi sono importanti in questo caso!
<p>

<p>
RIDISEGNARE LO SCHERMO
<p>
Se il comando esterno ha prodotto un messaggio di errore, lo schermo può essere stato scombinato.
Vim è molto efficiente e riscrive solo quelle parti dello schermo che sa che devono essere riscritte.
Ma non può sapere cosa ha combinato un programma esterno.
Per dire a Vim di ridisegnare tutto lo schermo: >
<p>
CTRL-L
<p>
==============================================================================
<p>
Capitolo seguente: |usr_11.txt| Recupero dopo un blocco
<p>
Copyright: vedi |manual-copyright| vim:tw=78:ts=8:ft=help:norl:
<p>
Per segnalazioni scrivere a vimdoc.it at gmail dot com oppure ad Antonio Colombo azc100 at gmail dot com *usr_11.txt*	Per Vim version 7.2.
Ultima modifica: 2006 Apr 24
<p>
VIM USER MANUAL - di Bram Moolenaar 	 Traduzione di questo capitolo: Roberto Franceschini
<p>
Recupero dopo un blocco
<p>

<p>
Il vostro computer si è bloccato? E voi avevate trascorso delle ore a scrivere? Niente paura! Vim salva sufficienti informazioni sul disco fisso da poter recuperare la maggior parte del vostro lavoro.
Questo capitolo mostra come recuperare il vostro lavoro e spiega come viene usato il file di swap.

<p>
|11.1|	Fondamenti del recupero |11.2|	Dove si trova il file di swap? |11.3|	Bloccato o no? |11.4|	Altre letture
<p>
Capitolo seguente: |usr_12.txt| Trucchi ingegnosi Capitolo precedente: |usr_10.txt| Fare grandi modifiche 	 Indice: |usr_toc.txt|
<p>
============================================================================== *11.1*	Fondamenti del recupero
<p>
Nella maggior parte dei casi recuperare un file è semplice, se conoscete quale file stavate scrivendo (e se il disco fisso funziona ancora).
Aprite quel file con Vim aggiungendo l'argomento "-r": >
<p>
vim -r help.txt
<p>
Vim leggerà il file di swap (usato per memorizzare il testo che stavate scrivendo) e potrà leggere i pezzi del file originale.
Se tutto va bene vedrete questi messaggi (con nomi di file differenti, naturalmente):
<p>
Uso swap file ".help.txt.swp" ~ 	File originale "~/vim/runtime/doc/help.txt" ~ 	Recupero completato.
Dovresti controllare se va tutto bene.
~ 	(Potresti salvare questo file con un altro nome ed eseguire ~ 	'diff' rispetto al file originale per vedere le differenze) ~ 	Cancella il file .swp in seguito.
~
<p>
Per sicurezza, salvate questo file con un nome diverso: >
<p>
:write help.txt.recovered
<p>
Confrontate il file con l'originale per verificare di aver ottenuto quello che vi aspettavate.
Vimdiff è molto utile per ciò |08.7|.
Verificate che l'originale non contenga una versione più recente di quella recuperata (se avete salvato poco prima che il computer si bloccasse).
E controllate che non manchino righe (qualcosa andato male che Vim non può riparare).
Se Vim produce dei messaggi di avviso durante il recupero, leggeteli attentamente.
Comunque ciò è raro.
<p>
E' normale che gli ultimi pochi cambiamenti non possano essere recuperati.
Vim invia i cambi al disco quando non scrivete per circa quattro secondi, o dopo che avete digitato circa duecento caratteri.
Questo è impostato con le opzioni 'updatetime' e 'updatecount'.
Così quando Vim non ha avuto la possibilità di salvare quando il sistema si è bloccato, i cambi successivi all'ultimo invio saranno persi.

<p>
Se stavate scrivendo senza un nome di file, date una stringa vuota come argomento: >
<p>
vim -r ""
<p>
Dovete essere nella directory giusta, altrimenti Vim non può trovare il file di swap.

<p>
============================================================================== *11.2*	Dove si trova il file di swap?
<p>
Vim può memorizzare il file di swap in molti posti.
Normalmente è nella stessa directory del file originale.
Per trovarlo posizionatevi nella directory del file e usate: >
<p>
vim -r
<p>
Vim elencherà i file di swap che può trovare.
Guarderà anche in altre directory dove potrebbero trovarsi i file di swap per i file della directory corrente.
Comunque non troverà file di swap presenti in altre directory, e non controllerà l'albero delle directory.
Il risultato potrebbe apparire come questo:
<p>
Swap file trovati: ~ 	 Nella directory in uso: ~ 	1.
.main.c.swp ~ 	 proprietario: mool datato: Tue May 29 21:00:25 2001 ~ 		 nome file: ~mool/vim/vim6/src/main.c ~ 	 modificato: YES ~ 	 nome utente: mool nome computer: masaka.moolenaar.net ~ 	 ID del processo: 12525 ~ 	 Nella directory ~/tmp: ~ 	 -- nessuno -- ~ 	 Nella directory /var/tmp: ~ 	 -- nessuno -- ~ 	 Nella directory /tmp: ~ 	 -- nessuno -- ~
<p>
Se ci sono più file che possono sembrare quello che cercate, vi verrà presentato un elenco e vi verrà richiesto di digitare il numero di quello che volete usare.
Guardate con attenzione la data per decidere quale utilizzare.
Se non sapete quale usare, provateli uno alla volta e verificate se sono quello cercato.

<p>
UTILIZZARE UN FILE DI SWAP SPECIFICO
<p>
Se sapete quale file di swap utilizzare, lo potete recuperare dando il nome del filo di swap.
Vim troverà il nome del file originale leggendo il file di swap.

<p>
Esempio: >
<p>
vim -r .help.txt.swo
<p>
Questo è utile anche quando il file di swap è in una directory diversa da quella che ci si aspetta.
Se anche questo non funziona, guardare quali nomi di file Vim restituisce e rinominarli di conseguenza.
Controllate l'opzione 'directory' per sapere dove Vim può aver messo il file di swap.

<p>
Note: 	Vim prova a trovare il file di swap cercando nelle directory contenute 	nell'opzione 'dir' i file che verificano la stringa "filename.sw?".
Se l'espansione dei caratteri jolly non funziona (ad esempio quando 	l'opzione 'shell' non è valida), Vim fa un tentativo disperato per 	trovare il file "filename.swp".
Se anche questo fallisce, dovrete 	dare il nome completo del file di swap per poter recuperare il file.

<p>
============================================================================== *11.3*	Bloccato o no?					*ATTENTION* *E325*
<p>
Vim prova ad impedirvi di fare stupidaggini.
Supponiamo che abbiate innocentemente iniziato a modificare un file e vi aspettiate di visualizzarne il contenuto.
Invece Vim produce un lungo messaggio di questo tipo:
<p>
E325: ATTENZIONE ~ 	Trovato uno swap file di nome ".main.c.swp" ~ 	 proprietario: mool datato: Tue May 29 21:09:28 2001 ~ 	 nome file: ~mool/vim/vim6/src/main.c ~ 	 modificato: no ~ 	 nome utente: mool nome computer: masaka.moolenaar.net ~ 	 ID del processo: 12559 (ancora attivo) ~ 	Mentre aprivo file "main.c" ~ 	 datato: Tue May 29 19:46:12 2001 ~ ~ 	(1) Un altro programma può essere in edit sullo stesso file.
~ 	 Se è così, attenzione a non trovarti con due versioni ~ 	 differenti dello stesso file a cui vengono apportate modifiche.
~ 	 Esci, o continua con prudenza.
~ ~ 	(2) Una sessione di edit per questo file è finita male.
~ 	 Se è così, usa ":recover" oppure "vim -r main.c" ~ 	 per recuperare modifiche fatte (vedi ":help recovery").
~ 	 Se hai già fatto ciò, cancella il file di swap ".help.txt.swp" ~ 	 per non ricevere ancora questo messaggio.
~
<p>
Ricevete questo messaggio perché, quando iniziate a modificare un file, Vim controlla se un file di swap per esso esista già.
Se ne trovasse uno deve esserci qualcosa di sbagliato.
Si può verificare una di queste due situazioni:
<p>
1.
Un'altra sessione di modifica è attiva per questo file.
Cercate nel messaggio la linea con "process ID". Può apparire così:
<p>
ID del processo: 12559 (ancora attivo) ~
<p>
Il testo "(ancora attivo)" indica che il processo che sta utilizzando questo file gira sullo stesso computer.
Se state lavorando su un sistema non-Unix non avrete questa informazione.
Se state utilizzando questo file in rete non potete vedere questa informazione, in quanto il processo potrebbe girare su un altro computer.
In questi due casi dovrete capire da soli in che situazione vi trovate.
Se un'altra sessione di Vim stesse editando lo stesso file, continuare nella modifica porterà ad averne due versioni.
Quella che verrà salvata per ultima sovrascriverà la prima, e le modifiche di questa andranno perse.
In questo caso sarebbe opportuno chiudere subito Vim.

<p>
2.
Il file di swap potrebbe essere il risultato di un blocco precedente di Vim o del computer.
Verificate i dati contenuti nel messaggio.
Se la data del file di swap è successiva a quella del file che state modificando, ed è presente questa linea:
<p>
modificato: YES ~
<p>
Allora molto probabilmente esisterà una sessione di modifica risalente a poco prima del crash che varrebbe la pena di salvare.
Se la data del file è successiva a quella del file di swap, esso può essere stato modificato dopo il blocco (forse l'avete già recuperato, senza poi cancellare il file di swap?), oppure il file è stato salvato prima del blocco, ma dopo l'ultima scrittura sul file di swap (in questo caso siete fortunati, il vecchio file di swap non vi serve neppure).
Vim vi avviserà con questa linea aggiuntiva:
<p>
più RECENTE dello swap file! ~
<p>

<p>
SWAP FILE NON LEGGIBILE
<p>
Talora la linea
<p>
[non leggibile] ~
<p>
può apparire sotto il nome dello swap file.
Questo può essere positivo o negativo, a seconda del contesto.

<p>
E' positivo se una precedente sessione di modifica si è bloccata senza aver fatto alcuna modifica al file.
In questo caso una lista directory dello swap file mostrerà che è lungo zero byte.
Potete cancellarlo e andare avanti.

<p>
Va un po' male se non siete autorizzati a leggere lo swap file.
Potete provare a visualizzare il file in sola-lettura, o abbandonare le modifiche.
Su sistemi multiutente, se avete fatto voi le ultime modifiche usando un differente nome utente, una chiusura di sessione, seguita da una nuova sessione con l'altro nome utente potrebbe rimediare l'"errore di lettura".
Oppure potreste individuare l'utente che ha fatto l'ultima modifica al file (o lo sta modificando adesso) e parlargli...

<p>
Va molto male se invece c'è un errore fisico di lettura sul disco che contiene lo swap file.
Fortunatamente, questo non capita quasi mai.
Potete visualizzare il file in sola-lettura (se ci riuscite), per vedere l'entità delle modifiche che erano state "dimenticate".
Se siete responsabili della modifica di quel file, siate pronti a ridigitare le vostre ultime modifiche.

<p>

<p>
COSA FARE?
<p>
Se sono supportate le scelte di dialogo, vi verrà chiesto di selezionare una di queste cinque opzioni:
<p>
Swap file ".main.c.swp" già esistente! ~ [O] Apri sola-lettura, (E) Apri comunque, (R)ecupera, (Q) Esci, (A)nnulla, (D) Cancellalo: ~
<p>
O Aprire il file in sola lettura.
Usate questa opzione se volete solo esaminare il file ma non recuperarlo.
Potete fare questa scelta quando sapete che qualcun altro sta modificando il file, e volete solo leggerlo senza fare modifiche.

<p>
E Modificare comunque il file.
Usatela con prudenza! Se un'altra sessione di Vim stesse modificando il file, potreste trovarvi con due versioni differenti dello stesso file.
Vim cercherà di avvisarvi quando ciò accade, ma è meglio essere sicuri piuttosto che doversi pentire.

<p>
R Recuperare il file dal file di swap.
Usate questa opzione se sapete che il file di swap contiene modifiche che volete recuperare.

<p>
Q Esci.
Questo evita di modificare il file.
Usate questa opzione se c'è un'altra sessione che sta modificando lo stesso file.
Se avete appena avviato Vim, ciò chiuderà la sessione.
Se avete avviato Vim con più file in diverse finestre, chiuderà la sessione solo se esiste un file di swap per il primo.
Usando un comando di modifica, il file non verrà caricato e verrete riportati al file che stavate modificando.

<p>
A Annulla.
Come Q [Esci], ma non esegue eventuali comandi ulteriori.
Utile eseguendo uno script che modifica parecchi file, ad es.
una sessione con molte finestre.
<p>
D Cancellare il file di swap.
Usate questa opzione se siete sicuri di non averne più bisogno.
Ad esempio se non contiene modifiche, o quando il file è più nuovo del file di swap.
In Unix questa scelta è mostrata solo se il processo che ha creato il file di swap non risulta più attivo.

<p>
Se non appaiono le scelte di dialogo (state usando una versione di Vim che non le supporta) dovrete fare tutto manualmente.
Per recuperare il file, usate questo comando: >
<p>
:recover
<p>

<p>
Non sempre Vim riesce a scoprire che esiste già un file di swap per un dato file.
Questo avviene quando l'altra sessione di modifica mette il file di swap in una directory diversa, o se il percorso del file è differente quando è modificato su computer diversi.
Quindi non fidatevi sempre degli avvisi di Vim.

<p>
Se veramente non voleste vedere questo messaggio, potreste aggiungere il flag "A" all'opzione 'shortness'.
Ma sarebbe veramente strano se ne aveste bisogno.
<p>
============================================================================== *11.4*	Altre letture
<p>
|swap-file|	Spiega dove viene creato il file di swap e qual è il suo nome.
|:preserve|	Salvare manualmente il file di swap sul disco.
|:swapname|	Vedi il nome del file di swap per il file corrente.
'updatecount'	Numero di caratteri immessi dopo i quali il file di swap viene 		salvato sul disco.
'updatetime'	Tempo dopo il quale il file di swap viene salvato sul disco.
'swapsync'	Se i buffer in memoria vengono scaricati su disco ("synced") ogni volta che il file di swap viene salvato.
'directory'	Elenco delle directory dove viene memorizzato il file di swap.
'maxmem'	Limite di utilizzo della memoria prima che il file di swap 		venga salvato.
'maxmemtot'	Come sopra ma per tutti i file aperti.

<p>
==============================================================================
<p>
Capitolo seguente: |usr_12.txt| Trucchi ingegnosi
<p>
Per segnalazioni scrivere a vimdoc.it at gmail dot com oppure ad Antonio Colombo azc100 at gmail dot com *usr_12.txt*	Per Vim version 7.2.
Ultima modifica: 2007 Mag 11
<p>
VIM USER MANUAL - di Bram Moolenaar 		Traduzione di questo capitolo: Rossella Diomede
<p>
Trucchi ingegnosi
<p>

<p>
Combinando diversi comandi potete far fare a Vim quasi ogni cosa.
In questo capitolo verrà presentata una serie di combinazioni utili.
Utilizzeremo i comandi introdotti nei capitoli precedenti e molti altri.

<p>
|12.1|	Sostituzione di una parola |12.2|	Modifica di "Last, First" in "First Last" |12.3|	Ordinamento di un elenco |12.4|	Inversione dell'ordine delle righe |12.5|	Conteggio di parole |12.6|	Ricerca di una pagina man |12.7|	Eliminazione di spazi vuoti |12.8|	Ricerca di una parola all'interno di un file
<p>
Capitolo seguente: |usr_20.txt| Immissione rapida dei comandi sulla linea 				 di comando Capitolo precedente: |usr_11.txt| Recupero dopo un blocco 	 Indice: |usr_toc.txt|
<p>
============================================================================== *12.1*	Sostituzione di una parola
<p>
Il comando substitute può essere utilizzato per sostituire tutte le occorrenze di una parola con un'altra: >
<p>
:%s/four/4/g
<p>
L'intervallo "%" significa sostituirla in ogni riga.
Il flag "g" alla fine fa sostituire tutte le parole nella stessa riga.
Il comando non farà la cosa giusta se il vostro file contenesse anche "thirtyfour".
Esso verrebbe sostituito da "thirty4".
Per evitare ciò, utilizzate l'elemento "\<" per indicare l'inizio di una parola: >
<p>
:%s/\<four/4/g
<p>
Ovviamente, andrà ancora male con "fourteen".
Utilizzate "\>" per indicare il termine di una parola: >
<p>
:%s/\<four\>/4/g
<p>
Se state programmando, potreste voler sostituire "four" nei commenti, ma non nel codice.
Poiché ciò è difficile da specificare, aggiungete il flag "c" per far sì che il comando substitute chieda quando effettuare la sostituzione: >
<p>
:%s/\<four\>/4/gc
<p>

<p>
SOSTITUZIONE IN PIU' FILE
<p>
Immaginate di voler sostituire una parola in più di un file.
Potete aprire ciascun file e digitare manualmente il comando.
E' molto più veloce utilizzare record e playback.
Supponete di avere una directory con file C++, che terminano con ".cpp".
C'è una funzione chiamata "GetResp" che volete rinominare "GetAnswer".

<p>
vim *.cpp		Avviate Vim, definendo la lista di argomenti 				che contiene tutti i file C++ .
Siete ora 				nel primo file.
qq			Iniziate la registrazione nel registro q 	:%s/\<GetResp\>/GetAnswer/g 				Effettuate le sostituzioni nel primo file.
:wnext			Scrivete il file e passate al successivo.
q			Interrompete la registrazione.
@q			Eseguite il registro q.
Ciò ripeterà la 				sostituzione e il ":wnext".
Potete verificare 				che non ci sia un messaggio di errore.
999@q			Eseguite il registro q nei restanti file.

<p>
Nell'ultimo file avrete un messaggio di errore, in quanto ":wnext" non può passare al file successivo.
Ciò fermerà l'esecuzione e tutte le sostituzioni saranno state effettuate.

<p>
Note: 	Durante la lettura di una sequenza registrata, un errore arresta 	l'esecuzione.
Pertanto, accertatevi che non ci sia un messaggio di errore durante 	la registrazione.

<p>
C'è un problema: se uno dei file .cpp non contiene la parola "GetResp", avrete un messaggio di errore e la sostituzione verrà interrotta.
Per evitare ciò, aggiungete il flag "e" al comando substitute: >
<p>
:%s/\<GetResp\>/GetAnswer/ge
<p>
Il flag "e" dice al comando :substitute che non è un errore non trovare corrispondenze.

<p>
============================================================================== *12.2*	Modifica di "Last, First" in "First Last"
<p>
Avete una lista di nomi in questo formato:
<p>
Doe, John ~ 	Smith, Peter ~
<p>
La volete modificare in:
<p>
John Doe ~ 	Peter Smith ~
<p>
Ciò può essere fatto con un unico comando: >
<p>
:%s/\([^,]*\), \(.*\)/\2 \1/
<p>
Suddividiamolo in più parti.
Ovviamente esso inizia con un comando substitute.
Il "%" è la lunghezza della riga, che rimane per l'intero file.
In tal modo la sostituzione viene effettuata in ogni riga del file.
Gli argomenti del comando substitute sono "/from/to/".
Le "/" separano l'espressione "from" e la stringa "to".
Questo è il contenuto dell'espressione "from": 							\([^,]*\), \(.*\) ~
<p>
La prima parte tra \( \) corrisponde a "Last"	\( \) 	 corrisponde a nessuna virgola		 [^,] 	 ogni volta					 * 	corrisponde a ", " letteralmente			 , 	La seconda parte tra \( \) corrisponde a "First"	 \( \) 	 ogni carattere					 .
ogni volta					 	 *
<p>
Nella parte "to" avete "\2" e "\1".
Essi si chiamano backreference.
Fanno riferimento al testo cui corrispondono le parti "\( \)" nell'espressione.
"\2" fa riferimento al testo cui corrisponde il secondo "\( \)", che è il nome "First".
"\1" fa riferimento al primo "\( \)", che è il nome "Last".
Potete utilizzare più di nove backreference nella parte "to" del comando substitute.
"\0" sta per l'intera espressione trovata.
Ci sono diversi altri elementi speciali nel comando substitute. Vedere |sub-replace-special|.
<p>
============================================================================== *12.3*	Ordinamento di un elenco
<p>
All'interno di un Makefile spesso è presente un elenco di file.
Ad esempio:
<p>
OBJS = \ ~ 		version.o \ ~ 		pch.o \ ~ 		getopt.o \ ~ 		util.o \ ~ 		getopt1.o \ ~ 		inp.o \ ~ 		patch.o \ ~ 		backup.o ~
<p>
Per ordinare l'elenco, filtrate il testo attraverso il comando esterno di ordinamento: >
<p>
/^OBJS 	j 	:.,/^$/-1!sort
<p>
Esso va alla prima riga, dove "OBJS" è il primo elemento nella riga.
Poi va alla riga successiva e filtra le righe fino ad arrivare ad una riga vuota.
Potete anche selezionare le righe con la modalità Visual e poi utilizzare "!sort".
Questo è più semplice da digitare, ma presenta maggior lavoro quando ci sono molte righe.
Il risultato è il seguente:
<p>
OBJS = \ ~ 		backup.o ~ 		getopt.o \ ~ 		getopt1.o \ ~ 		inp.o \ ~ 		patch.o \ ~ 		pch.o \ ~ 		util.o \ ~ 		version.o \ ~
<p>

<p>
Attenzione alla presenza di un backslash al termine di ciascuna riga, usato per indicare che la riga continua.
Dopo l'operazione si evidenzia un errore.
La riga "backup.o" che era alla fine dell'elenco non ha il backslash.
Ora, poiché viene inserita nell'elenco in una posizione diversa, è necessario che abbia il backslash.
La soluzione più semplice è quella di aggiungerla digitando "A \<Esc>".
Potete mantenere il backslash nell'ultima riga se siete certi che poi ci sia una riga vuota.
In tal modo non avrete più questo problema.
<p>
============================================================================== *12.4*	Inversione dell'ordine delle righe
<p>
Il comando |:global| può essere combinato con il comando |:move| per spostare tutte le righe prima della riga iniziale, ottenendo come risultato un file invertito.
Il comando è: >
<p>
:global/^/m 0
<p>
Abbreviato: >
<p>
:g/^/m 0
<p>
L'espressione "^" segna l'inizio della riga (anche se la riga è vuota).
Il comando |:move| sposta la riga trovata dopo la mitica riga zero, in modo che diventi la prima riga del file.
Poiché il comando |:global| non viene confuso dalla numerazione delle righe modificata, |:global| continua a cercare tutte le restanti righe del file ed a porle ciascuna per prima.

<p>
Questo comando opera anche su di un intervallo di righe.
Per prima cosa spostatevi sulla prima riga e contrassegnatela con "mt".
Quindi spostate il cursore sull'ultima riga dell'intervallo e digitate: >
<p>
:'t+1,.g/^/m 't
<p>
============================================================================== *12.5*	Conteggio di parole
<p>
Capita a volte di dover scrivere un testo con un numero massimo di parole.
Vim può contare le parole per voi.
Se volete contare le parole dell'intero file, utilizzate questo comando: >
<p>
g CTRL-G
<p>
Non digitare uno spazio dopo la g, qui è stato usato per rendere il comando facile da leggere.
Il risultato appare così:
<p>
Col.
1 di 0; Linea 141 di 157; Parola 748 di 774; Caratt. 4489 di 4976 ~
<p>
Potete vedere su quale parola siete (748), ed il numero complessivo di parole nel file (774).

<p>
Quando il testo è solo una parte del file, potete spostarvi all'inizio del testo, digitare "g CTRL-G", spostarvi alla fine del testo, digitare ancora "g CTRL-G", e calcolare così la differenza nella posizione della parola.
E' un buon esercizio ma esiste un sistema più semplice.
In Visual mode, selezionate il testo del quale volete contare le parole.
Digitate quindi g CTRL-G.
Risultato:
<p>
Selezionate 5 di 293 righe; 70 di 1884 parole; 359 di 10928 byte ~
<p>
Per altri metodi relativi al conteggio di parole, righe ed altri elementi, vedere |count-items|.

<p>
============================================================================== *12.6*	Ricerca di una pagina man			*find-manpage*
<p>
Nel modificare uno script shell o un programma C, state usando un comando o una funzione di cui volete cercare la pagina man (su Unix).
Utilizziamo prima un semplice sistema: spostate il cursore sulla parola per la quale si chiede aiuto e premete >
<p>
K
<p>
Vim eseguirà il programma esterno "man" sulla parola.
Se la pagina man è stata trovata, viene visualizzata.
Tale sistema utilizza il paginatore normale per scorrere il testo (di solito il programma "more").
Premendo il tasto <Invio> quando terminato, si tornerà a Vim.

<p>
Uno svantaggio è quello di non poter vedere contemporaneamente la pagina man ed il testo sul quale state lavorando.
Esiste un artificio per far sì che la pagina man compaia in una finestra di Vim.
Per prima cosa, caricate il plugin del filetype di man: >
<p>
:runtime! ftplugin/man.vim
<p>
Inserite questo comando nel file vimrc se prevedete di effettuare questa operazione spesso.
Potete ora utilizzare il comando ":Man" per aprire una finestra su una pagina man: >
<p>
:Man csh
<p>
Potete scorrere il testo e noterete che questo è evidenziato.
Ciò vi consente di trovare l'aiuto che stavate cercando.
Utilizzate CTRL-W per spostarvi nella finestra contenente il testo sul quale stavate lavorando.
Per cercare una pagina man in un sezione specifica, inserite come prima cosa il numero della sezione.
Ad esempio, per cercare "echo" nella sezione 3: >
<p>
:Man 3 echo
<p>
Per spostarvi ad un'altra pagina man, che è nel testo nel formato tipico "word(1)", premete CTRL-] su di essa.
Ulteriori comandi ":Man" utilizzeranno la stessa finestra.

<p>
Per visualizzare una pagina man per la parola al di sotto del cursore, utilizzate: >
<p>
\K
<p>
(Se avete ridefinito il <Leader>, utilizzatelo al posto del backslash).
Ad esempio, volete conoscere il valore di ritorno di "strstr()" mentre digitate la riga:
<p>
if ( strstr (input, "aap") == ) ~
<p>
Spostate il cursore su "strstr" e digitate "\K".
Si aprirà una finestra per visualizzare la pagina man per strstr().

<p>
============================================================================== *12.7*	Eliminazione di spazi vuoti
<p>
Alcuni trovano inutili e brutti gli spazi e le tabulazioni [Tab] alla fine di una riga.
Per eliminare gli spazi alla fine di ciascuna riga eseguite il seguente comando: >
<p>
:%s/\s\+$//
<p>
Viene usato l'intervallo di riga "%", in tal modo questo funzionerà per l'intero file.
L'espressione che il comando ":substitute" ricerca è "\s\+$".
Esso troverà spazi vuoti (\s), 1 o più (\+), prima della fine della riga ($).
Più avanti sarà illustrato come scrivere espressioni come questa |usr_27.txt|.
La parte "to" del comando di sostituzione è vuota: "//".
In tal modo essa non viene sostituita con nessun carattere, eliminando effettivamente gli spazi vuoti trovati.

<p>
Un altro uso inutile degli spazi è quando vengono posizionati prima di una tabulazione [Tab].
Spesso possono essere eliminati senza alterare il numero degli spazi necessari.
Ma non sempre è possibile.
Pertanto, è preferibile eseguire l'operazione manualmente. Utilizzate questo comando di ricerca: >
<p>
/
<p>
Non potete vederlo, ma in questo comando c'è uno spazio prima della tabulazione [Tab].
Quindi è "/<Space><Tab>".
Utilizzate ora "x" per eliminare lo spazio e verificate che il numero degli spazi non è stato modificato.
Se fosse stato modificato sarebbe necessario inserire una tabulazione.
Digitate "n" per trovare la prossima corrispondenza.
Ripetete questa operazione finché non ci saranno più altre corrispondenze.
<p>
============================================================================== *12.8*	Ricerca di una parola all'interno di un file
<p>
Se siete utenti di UNIX, potete utilizzare una combinazione di comandi di Vim e grep per modificare tutti i file che contengano una determinata parola.
Ciò risulta estremamente utile quando state lavorando su di un programma e volete visualizzare o modificare i file che contengono una variabile specifica.
Ad esempio, immaginate di voler modificare tutti i file del programma C che contengono la parola "frame_counter".
Per fare ciò utilizzate il comando: >
<p>
vim `grep -l frame_counter *.c`
<p>
Osserviamo il comando nei dettagli.
Il comando grep cerca in un gruppo di file una determinata parola.
Poiché l'argomento -l è indicato, il comando elencherà soltanto i file che contengono la parola e non le righe corrispondenti.
La parola da trovare è "frame_counter".
In realtà, essa può essere qualsiasi espressione regolare.
(Note: Quella che grep considera un'espressione regolare non è considerata allo stesso modo da Vim.) L'intero comando è racchiuso tra apici inversi (`).
Questo comunica alla shell di UNIX di eseguire il comando e pretende che i risultati vengano scritti sulla linea di comando.
Pertanto ciò che avviene è che il comando grep viene eseguito e produce una lista di file, i quali vengono inseriti nella riga di comando di Vim.
Vim modificherà la lista di file data come output da grep.
Potete quindi utilizzare comandi come ":next" e ":first" per dare un'occhiata tra i file.

<p>

<p>
RICERCA DI UNA PAROLA ALL'INTERNO DI UNA RIGA
<p>
Il comando sopra descritto cerca esclusivamente i file che contengono la parola.
Dovete ora cercare la parola all'interno dei file.
Vim ha un comando incorporato che potete utilizzare per cercare una determinata stringa all'interno di un gruppo di file.
Se volete trovare tutte le ripetizioni di "error_string" in tutti i file del programma C, ad esempio, digitate il seguente comando: >
<p>
:grep error_string *.c
<p>
Esso fa sì che Vim cerchi la stringa "error_string" in tutti i file (*.c).
L'editor aprirà il primo file dove è stata trovata la corrispondenza e posizionerà il cursore sulla prima riga.
Per spostarvi alla riga successiva (non importa in quale file), utilizzate il comando ":cnext".
Per andare alla corrispondenza precedente, utilizzate il comando ":cprev".
Utilizzate ":clist" per visualizzare tutte le corrispondenze ed il punto in cui si trovano.
Il comando ":grep" utilizza i comandi esterni di grep (su Unix) o di findstr (su Windows).
Potete modificare ciò impostando l'opzione 'grepprg'.
<p>
==============================================================================
<p>
Capitolo seguente: |usr_20.txt| Immissione rapida dei comandi sulla linea di 				 comando
<p>
Per segnalazioni scrivere a vimdoc.it at gmail dot com oppure ad Antonio Colombo azc100 at gmail dot com *usr_20.txt*	Per Vim version 7.2.
Ultima modifica: 2006 Apr 24
<p>
VIM USER MANUAL - di Bram Moolenaar 	 Traduzione di questo capitolo: Fabio Teatini e Roberta Fedeli
<p>
Immissione rapida dei comandi sulla linea di comando
<p>

<p>
Vim ha alcune funzionalità generali che rendono più semplice l'immissione di comandi.
I comandi possono essere abbreviati, modificati e ripetuti.
Il meccanismo del completamento è disponibile quasi sempre.
<p>
|20.1|	Elaborazione della linea di comando |20.2|	Abbreviazioni dei comandi |20.3|	Completamento automatico dei comandi |20.4|	Cronologia dei comandi |20.5|	Finestra della linea di comando
<p>
Capitolo seguente: |usr_21.txt| Andarsene e ritornare Capitolo precedente: |usr_12.txt| Trucchi ingegnosi 	 Indice: |usr_toc.txt|
<p>
============================================================================== *20.1*	Elaborazione della linea di comando
<p>
Quando, per immettere un comando, digitate il carattere dei due-punti (:) o effettuate la ricerca di una stringa con / o ?, Vim pone il cursore in fondo allo schermo; questa è la posizione in cui inserire i comandi o le chiavi di ricerca, ed è chiamata Command line.
Anche quando viene usata per inserire un comando di ricerca.

<p>
Il modo più semplice per modificare il comando digitato è quello di premere il tasto <BS>, così da cancellare il carattere a sinistra del cursore.
Per cancellare un altro carattere precedentemente digitato, spostate il cursore coi tasti-freccia.
Per esempio, immaginate di aver già digitato il comando:
<p>
:s/col/pig/
<p>
Se ora, prima di premere <Invio>, voi voleste che "col" fosse trasformato in "cow", digitate <Left> cinque volte.
Il cursore, ora, si trova proprio dopo "col".
Per effettuare la correzione digitate "<BS> e "w":
<p>
:s/cow/pig/
<p>
Ora potete premere <Enter> direttamente, senza spostare il cursore alla fine della linea prima di eseguire il comando.

<p>
Ecco i tasti utilizzati più spesso per spostarsi entro la riga di comando:
<p>
<Left>			un carattere a sinistra 	<Right>			un carattere a destra 	<S-Left> o <C-Left>	una parola a sinistra 	<S-Right> o <C-Right>	una parola a destra 	CTRL-B o <Home>		all'inizio della linea di comando 	CTRL-E o <End>		alla fine della linea di comando
<p>
Note: 	<S-Left> (tasto-freccia a sinistra con tasto delle Maiuscole premuto) e <C-Left> (tasto-freccia a sinistra con tasto Control premuto) non 	funzionano su tutte le tastiere.
Ciò vale anche per le altre 	combinazioni ottenute coi tasti Maiuscola e Control.

<p>
Per muovere il cursore potete utilizzare anche il mouse.

<p>
CANCELLAZIONE
<p>
Come già detto, <BS> cancella il carattere precedente al cursore.
Per cancellare un'intera parola si usa CTRL-W.

<p>
/the fine pig ~
<p>
CTRL-W
<p>
/the fine ~
<p>
CTRL-U cancella tutto il testo, permettendo di ricominciare tutto da capo.

<p>
SOVRASCRITTURA
<p>
Esistono due possibilità per l'inserimento di nuovi caratteri: la prima permette di inserire nuovi caratteri senza cancellare quelli esistenti; la seconda fa sovrascrivere i nuovi caratteri su quelli esistenti.
Il tasto <Insert> permette di passare dalla prima modalità alla seconda.
Scrivete questo testo:
<p>
/the fine pig ~
<p>
Ora muovete il cursore all'inizio della parola "fine" premendo <S-Left> due volte (o <Left> otto volte, se <S-Left> non funziona).
Quindi, premete <Insert> per passare alla funzione di sovrascrittura e digitate "great":
<p>
/the greatpig ~
<p>
Oops, è andato perso lo spazio.
In questo caso non usate <BS>, perché cancellereste la "t" (diversamente dalla modalità di Sovrascrittura).
Invece, premete <Insert> per passare dalla sovrascrittura all'inserimento, e digitate lo spazio:
<p>
/the great pig ~
<p>

<p>
ANNULLAMENTO
<p>
Quando volete annullare un comando : oppure / in fase di digitazione, premete CTRL-C o <Esc>.

<p>
Note: 	<Esc> è il tasto universalmente usato come «uscita».
Sfortunatamente, 	nel buon vecchio Vi la digitazione di <Esc> in una riga di comando 	eseguiva il comando! Poiché ciò potrebbe essere considerato un bug, 	Vim usa <Esc> per cancellare il comando.
Ma usando l'opzione 'cpoptions' si può ottenere la compatibilità con 	VI.
<Esc> funziona in modalità compatibile con Vi anche quando si usa 	un mapping (scritto per Vi).
In definitiva, il metodo che funziona sempre è quello del CTRL-C.

<p>
Se siete all'inizio della linea di comando, premendo <BS> annullerete il comando.
È equivalente a cancellare i caratteri ":" o "/" posti all'inizio della riga.

<p>
============================================================================== *20.2*	Scorciatoie per la linea di comando
<p>
Alcuni comandi ":" sono veramente lunghi.
Si è già detto che ":substitute" può essere abbreviato come ":s".
Questa è una regola generale: tutti i comandi ":" possono essere abbreviati.

<p>
Di quanto può essere abbreviato un comando? Ci sono 26 lettere, ma molti più comandi.
Per esempio, anche ":set" inizia con ":s", ma ":s" non avvia un comando ":set".
Invece ":set" può essere abbreviato con ":se".
Quando due comandi hanno la stessa forma abbreviata, in realtà essa funzionerà solo per uno di essi.
Non c'è un metodo logico per individuarlo: è qualcosa che va imparato.
Nei file di help viene indicata la forma abbreviata più corta che funziona.
Per esempio: >
<p>
:s[ubstitute]
<p>
Significa che la forma più corta per ":substitute" è ":s".
I caratteri successivi sono opzionali.
Quindi funzionano anche ":su" e ":sub".
<p>
In questo manuale dell'utente si userà sia il nome intero del comando, sia una forma abbreviata comunque intelligibile.
Per esempio, ":function" potrebbe essere abbreviato in ":fu", ma poiché molte persone non capirebbero cosa indica tale abbreviazione, useremo ":fun" (Vim non ha un comando ":funny", altrimenti anche ":fun" potrebbe ingenerare confusione).

<p>
Per quel che riguarda gli script di Vim, vi raccomando di scrivere il nome intero dei comandi.
Ciò permette di interpretarli più facilmente quando si effettuano modifiche successive.
Si può fare eccezione per alcuni comandi usati molto spesso, come ":w" (":write") e ":r" (":read").
Una forma particolarmente ambigua è ":end", che si adatta a ":endif", ":endwhile" e ":endfunction".
Perciò, usate sempre il nome intero.
<p>

<p>
NOMI BREVI DELLE OPZIONI
<p>
Nel manuale dell'utente sono illustrate le opzioni con i nomi lunghi.
Per molte opzioni si possono usare anche nomi brevi.
Contrariamente a quel che avviene per i comandi ":", c'è un solo nome breve funzionante.
Ad esempio, il nome breve per 'autoindent' è 'ai'.
Perciò, i due comandi seguenti fanno lo stesso lavoro: >
<p>
:set autoindent 	:set ai
<p>
Un elenco dei nomi dei comandi (lunghi e brevi) si trova qui: |option-list|.

<p>
============================================================================== *20.3*	Completamento della linea di comando
<p>
Questa funzionalità di Vim è una di quelle che, da sola, giustifica l'adozione di Vim da parte degli utenti di Vi.
Una volta che l'avrete usata, non potrete più farne a meno.

<p>
Supponete di avere una directory contenente questi file:
<p>
info.txt 	intro.txt 	corpodeltesto.txt
<p>
Per elaborare l'ultimo file, potete usare il comando: >
<p>
:edit corpodeltesto.txt
<p>

<p>
e noterete che è facile sbagliarne la digitazione.
Un modo assai più rapido è:
<p>
:edit c<Tab>
<p>
e otterrete lo stesso effetto di prima.
Che è successo? Il tasto <Tab> effettua il completamento della parola che precede il cursore.
Nel nostro caso: "b".
Vim cerca nella directory e trova soltanto un file il cui nome inizia per "b"; non essendoci ambiguità, Vim completa al posto vostro il nome del file e lo apre.

<p>
Ora digitate: >
<p>
:edit i<Tab>
<p>
Vim, ora, emetterà un segnale acustico e presenterà il comando: >
<p>
:edit info.txt
<p>
Il segnale acustico significa che Vim ha trovato più di una corrispondenza.
Per questo motivo aprirà il primo file (in ordine alfabetico) che corrisponde.
Se premete ancora <Tab>, otterrete: >
<p>
:edit intro.txt
<p>
Così, se il primo <Tab> non evidenzia il file che stavate cercando, premetelo ancora.
Se esistono più nomi corrispondenti, li vedrete tutti, uno per uno.
Se premete <Tab> sull'ultimo nome corrispondente, tornerete a quello che avevate digitato inizialmente: >
<p>
:edit i
<p>
Allora si ricomincia daccapo.
Così Vim effettua un ciclo attraverso l'elenco delle corrispondenze.
Con CTRL-P potrete scorrere la lista nel verso opposto:
<p>
<------------------- <Tab> -------------------------+ 								 | 		 <Tab> -->		 <Tab> --> 	:edit i		 :edit info.txt		 :edit intro.txt 		 <-- CTRL-P		 <-- CTRL-P 	 | 	 +---------------------- CTRL-P ------------------------>
<p>

<p>
CONTESTO
<p>
Quando digitate ":set i" invece che ":edit i" e premete <Tab>, si ottiene: >
<p>
:set icon
<p>
Ehi! Perché non compare ":set info.txt"? Ciò avviene perché il completamento di Vim è sensibile al contesto.
Il tipo di parole cercate da Vim dipende dal comando iniziale.
Vim sa che subito dopo un comando ":set" non potete usare un nome di file; è consentito solo un nome d'opzione.
Anche qui, se digitate più volte il tasto <Tab>, Vim effettuerà una scansione ciclica attraverso tutti i valori corrispondenti.
Ce ne sono parecchi, per cui è meglio digitare altri caratteri: >
<p>
:set isk<Tab>
<p>
Diventa: >
<p>
:set iskeyword
<p>
Ora digitate "=" e premete <Tab>: >
<p>
:set iskeyword=@,48-57,_,192-255
<p>
Ciò che accade è che Vim inserisce il vecchio valore dell'opzione.
Adesso potete modificarla.
L'uso di <Tab> porta al completamento con ciò che Vim si aspetta debba comparire nella posizione corrispondente.
Provate semplicemente a vedere come funziona.
In certe situazioni otterrete qualcosa di diverso da quanto desiderato.
Ciò è dovuto al fatto che Vim non conosce i vostri desideri; oppure il completamento potrebbe non essere stato implementato per quella determinata situazione.
In quel caso otterrete il semplice inserimento di un <Tab> (visualizzato come ^I).

<p>

<p>
ELENCO DI CORRISPONDENZE
<p>
Quando esistono molte corrispondenze, vorrete vederle tutte insieme.
Potete farlo premendo CTRL-D.
Per esempio, premendo CTRL-D dopo aver digitato >
<p>
:set is
<p>
si ottiene: >
<p>
:set is 	incsearch isfname isident iskeyword isprint 	:set is
<p>
Vim elenca le corrispondenze e ritorna al testo da voi digitato, così che possiate passare in rassegna l'elenco e scegliere ciò che volete.
Se non ci sono corrispondenze, potete usare <BS> per correggere la parola.
Se le corrispondenze sono molte, prima di premere <Tab> digitate qualche altro carattere di ciò che vi interessa.
Se ci avete fatto caso, noterete che "incsearch" non inizia con "is".
In questo caso, "is" è il nome breve di "incsearch".
(Molte opzioni hanno nomi sia brevi che lunghi.) Vim è sufficientemente scaltro da sapere che voi potreste aver voluto espandere il nome breve dell'opzione nel suo nome lungo.

<p>

<p>
C'E' DI PIU'
<p>
Il comando CTRL-L completa la parola trasformandola nella stringa più lunga e non ambigua.
Se digitate ":edit i" ed esistono i file "info.txt" e "info_backup.txt" otterrete ":edit info".

<p>
Per modificare il meccanismo di completamento, potete usare l'opzione 'wildmode'.
L'opzione 'wildmenu' permette di produrre un elenco corrispondenze in forma di menù.
L'opzione 'suffixes' permette di precisare i file meno importanti che possono essere relegati alla fine dell'elenco.
L'opzione 'wildignore' permette di indicare i file da non elencare affatto.

<p>
Altre informazioni in merito si trovano qui: |cmdline-completion|
<p>
============================================================================== *20.4*	Cronologia dei comandi
<p>
La cronologia dei comandi (o history) è stata brevemente citata nel capitolo 3.
La cosa più semplice a riguardo è l'utilizzo del tasto <Up> per richiamare i precedenti comandi; il tasto <Down> permette di scorrere i comandi in avanti.

<p>
In realtà di cronologie ne esistono quattro.
Qui tratteremo quella dei comandi ":", e quelle dei comandi di ricerca "/" e "?".
I comandi "/" e "?" condividono la stessa cronologia, essendo entrambi comandi di ricerca.
Le altre due cronologie sono quelle delle espressioni e delle linee di input per la funzione input().
|cmdline-history|
<p>
Supponiamo di aver immesso un comando ":set", di aver digitato più di dieci comandi ":" e poi di voler ripetere il comando ":set" di prima.
Potreste premere ":" e dieci volte <Up>, ma c'è un modo più rapido: >
<p>
:se<Up>
<p>
Vim tornerà al precedente comando che inizia con "se".
Avete buone probabilità che si tratti del comando ":set" che cercavate.
Se non altro, vi sarà risparmiato di premere tante volte il tasto <Up> (a meno che non abbiate dato solo comandi di tipo ":set").

<p>
Il tasto <Up> userà il testo digitato fino a quel momento e lo confronterà con le linee presenti nella cronologia.
Solo le linee corrispondenti saranno usate.
Se non trovate le linee che cercavate, usate <Down> e tornerete a quelle digitate inizialmente, per modificarle.
Oppure usate CTRL-U per ricominciare tutto da capo.

<p>
Per vedere tutte le linee della cronologia: >
<p>
:history
<p>
Questa è la cronologia dei comandi ":".
La cronologia dei comandi di ricerca viene mostrata con il comando: >
<p>
:history /
<p>
CTRL-P ha lo stesso effetto di <Up>, tranne per il fatto che non importa quel che avete già scritto.
Lo stesso vale per CTRL-N e <Down>.
CTRL-P sta per "precedente", CTRL-N per "next" (successivo).
<p>
============================================================================== *20.5*	Finestra della linea di comando
<p>
La digitazione del testo nella linea di comando funziona in modo diverso dalla digitazione in Insert mode: a molti comandi non è permesso di modificare il testo.
Per la maggior parte dei programmi questo non è un problema, ma a volte vi troverete a digitare comandi complessi.
E' in questo caso che torna utile la finestra della linea di comando.

<p>
La finestra della linea di comando si apre con questo comando: >
<p>
q:
<p>
Con esso, Vim apre una (piccola) finestra in basso, che contiene la cronologia della linea di comando e una linea vuota in fondo:
<p>
+-------------------------------------+ 	|other window			 | 	|~				 | 	|file.txt=============================| 	|:e c				 | 	|:e config.h.in			 | 	|:set path=.,/usr/include,,	 | 	|:set iskeyword=@,48-57,_,192-255 | 	|:set is			 | 	|:q				 | 	|:				 | 	|command-line=========================| 	|				 | 	+-------------------------------------+
<p>
Ora siete in Normal mode.
Qui potete usare i tasti "hjkl" per spostarvi col cursore.
Per esempio, spostatevi verso l'alto con "5k" fino alla linea con ":e config.h.in".
Digitate "$h" per muovervi fino alla "i" di "in" e digitate "cwout".
Ora la linea è stata modificata in:
<p>
:e config.h.out ~
<p>
Premete <Enter> e questo comando verrà eseguito, dopodiché la finestra della linea di comando si chiuderà da sé.
Il comando <Enter> eseguirà la linea su cui si trova il cursore, senza badare se Vim si trova in Insert mode o Normal mode.
Le modifiche, effettuate in finestra della linea di comando, saranno perdute; non saranno reperibili nella cronologia dei comandi, tranne per il comando da voi eseguito (ciò vale per tutti i comandi mandati in esecuzione).

<p>
La finestra della linea di comando è utilissima per ottenere una panoramica della cronologia dei comandi, cercare nei comandi qualcosa di simile a quello che serve, fare le dovute modifiche ed eseguire il tutto.
Per trovare quel che si vuole si può utilizzare esplicitamente un comando di ricerca.
Nell'esempio precedente avreste potuto usare il comando di ricerca "?config" per trovare il comando più recente contenente "config".
C'è un che di strano nell'usare un comando di ricerca per effettuare ricerche nella finestra dei comandi.
Quando digitate questo comando di ricerca non potrete aprire un'altra finestra della linea di comando, perché ne viene supportata solo una.

<p>
==============================================================================
<p>
Capitolo seguente: |usr_21.txt| Andarsene e ritornare
<p>
Copyright: vedere |manual-copyright| vim:tw=78:ts=8:ft=help:norl:
<p>
Per segnalazioni scrivere a vimdoc.it at gmail dot com oppure ad Antonio Colombo azc100 at gmail dot com *usr_21.txt*	Per Vim version 7.2.
Ultima modifica: 2008 Nov 09
<p>
VIM USER MANUAL - di Bram Moolenaar 	 Traduzione di questo capitolo: Gianluca Trimarchi
<p>
Andarsene e ritornare
<p>

<p>
Questo capitolo considera come alternare l'uso di altri programmi con Vim.
Sia eseguendo un programma dall'interno di Vim ovvero uscendo da Vim e ritornandovi in seguito.
Inoltre, tratta di come memorizzare lo stato di Vim e ripristinarlo in seguito.

<p>
|21.1|	Sospendere e ripristinare |21.2|	Eseguire comandi della shell |21.3|	Memorizzare le informazioni; viminfo |21.4|	Sessioni |21.5|	Viste |21.6|	Modeline
<p>
Capitolo seguente: |usr_22.txt| Trovare il file da aprire Capitolo precedente: |usr_20.txt| Immissione rapida dei comandi dalla linea 				 di comando 	 Indice: |usr_toc.txt|
<p>
============================================================================== *21.1*	Sospendere e ripristinare
<p>
Come molti programmi UNIX Vim può essere sospeso premendo CTRL-Z.
Vim viene fermato e venite riportati alla shell da cui è stato avviato.
Dopo potete eseguire qualsiasi altro comando finché non ne avete abbastanza.
Ritornate a Vim con il comando "fg", >
<p>
CTRL-Z 	{qualsiasi sequenza di comandi della shell} 	fg
<p>
Siete ritornati dove avevate lasciato Vim, non è cambiato nulla.
Nel caso premere CTRL-Z non funzionasse, potete anche usare ":suspend".
Non dimenticate di riportare Vim in primo piano, potreste perdere qualsiasi modifica fatta!
<p>
Solo UNIX lo permette.
Su altri sistemi Vim avvierà una shell per voi.
Anche questa ha la funzionalità di eseguire comandi della shell.
Ma è una nuova shell, non quella da cui avete avviato Vim.
Quando state eseguendo la GUI non potete tornare alla shell da dove Vim è stato avviato.
CTRL-Z minimizzerà la finestra di Vim.
<p>
============================================================================== *21.2*	Eseguire comandi della shell
<p>
Per eseguire un singolo comando della shell da Vim usate ":!{comando}".
Per esempio, per vedere il contenuto di una directory: >
<p>
:!ls 	:!dir
<p>
Il primo è per Unix, il secondo per MS-Windows.
Vim eseguirà il programma.
Quando finirà vi verrà chiesto di premere <Invio>.
Questo vi permette di visionare l'output del comando prima di ritornare al testo su cui stavate lavorando.
Il "!" è anche usato altrove quando si esegue un programma.
Diamo uno sguardo ad una panoramica:
<p>
:!{programma}		esegue {programma} 	:r !{programma}		esegue {programma} e legge il suo output 	:w !{programma}		esegue {programma} e invia il testo come suo 	 input 	:[intervallo]!{programma}	filtra il testo attraverso {programma}
<p>
Notate che la presenza di un intervallo prima di "!{programma}" fa una grossa differenza.
Senza di esso il programma viene eseguito normalmente, specificando l'intervallo un certo numero di linee di testo verrà filtrato attraverso il programma.

<p>
È possibile eseguire in questo modo molti programmi.
Ma una shell è molto meglio.
Potete avviare una nuova shell in questo modo: >
<p>
:shell
<p>
È simile ad usare CTRL-Z per sospendere Vim.
La differenza è che viene avviata una shell nuova.

<p>
Quando usate la GUI, la shell starà usando la finestra di Vim per i suoi input e output.
Poiché Vim non è un emulatore di terminale, non funzionerà perfettamente.
Se avete problemi, provate ad impiegare l'opzione 'guipty'.
Se ancora non dovesse funzionare in modo soddisfacente, avviate un nuovo terminale per eseguire la shell al suo interno.
Ad es. con: >
<p>
:!xterm&
<p>
============================================================================== *21.3*	Memorizzare le informazioni; viminfo
<p>
Dopo aver scritto per un po', avrete del testo entro i registri, puntatori in vari file, una storia della linea di comando piena di astuti comandi.
Quando uscite da Vim tutto ciò viene perso.
Ma potete conservarlo!
<p>
Il file viminfo è deputato ad immagazzinare le informazioni sullo status:
<p>
Storia della linea di comando e dei pattern di ricerca 	Testo nei registri 	Puntatori per vari file 	L'elenco dei buffer 	Variabili globali
<p>
Ogni volta che uscite da Vim esso memorizzerà queste informazioni in un file, il file viminfo.
Quando Vim viene riavviato, il file viminfo viene letto e le informazioni ripristinate.

<p>
L'opzione 'viminfo' per default è impostata per ripristinare un numero limitato di informazioni.
Potreste volerla impostare per memorizzare un maggior numero di informazioni.
Ciò può avvenire attraverso il seguente comando: >
<p>
:set viminfo=stringa
<p>
La stringa specifica cosa salvare.
La sintassi di questa stringa è un carattere di opzione seguito da un argomento.
Le coppie opzione/argomento sono separate da virgole.
Osservate come potreste costruire la vostra stringa viminfo.
Primo, l'opzione ' viene usata per specificare per quanti file salvare i puntatori (a-z).
Per questa opzione prendete un bel numero pari (1000, per esempio).
Adesso il vostro comando potrebbe assomigliare a questo: >
<p>
:set viminfo='1000
<p>
L'opzione f controlla se memorizzare i puntatori globali (A-Z e 0-9).
Se questa opzione è 0, non ne verrà memorizzato nessuno.
Se è 1 o non specificate una opzione f, i puntatori verranno memorizzati.
Sicuramente vorrete usare questa funzionalità, quindi adesso avrete questo: >
<p>
:set viminfo='1000,f1
<p>
L'opzione < controlla quante linee vengono salvate per ciascun registro.
Per default, vengono salvate tutte le linee.
Se è 0, non viene salvato nulla.
Per evitare di aggiungere migliaia di linee al vostro file viminfo (che potrebbero non venire mai usate e rallenterebbero l'avvio di Vim) usate un massimo di 500 linee: >
<p>
:set viminfo='1000,f1,<500 < Altre opzioni che potreste voler usare:
<p>
:	numero di linee da salvare dalla storia della linea di comando 	@	numero di linee da salvare dalla storia della linea di input 	/	numero di linee da salvare dalla storia della ricerca 	r	supporto rimovibile, per cui nessun puntatore sarà memorizzato 	 (può esser usato più volte) 	!	variabili globali che iniziano con una lettera maiuscola e non 		contengono lettere minuscole 	h	disattiva l'evidenziazione di 'hlsearch' quando viene avviato 	%	l'elenco dei buffer (memorizzato solo quando Vim viene avviato 		senza file come argomenti) 	c	converte il testo usando 'encoding' 	n	il nome usato per il file viminfo (dev'essere l'ultima 	 opzione)
<p>
Guardate l'opzione 'viminfo' e |viminfo-file| per maggiori informazioni.

<p>
Qualora eseguiste più copie di Vim, l'ultima a terminare memorizzerà le sue informazioni.
Ciò potrebbe far sì che le informazioni memorizzate dai Vim precedenti vengano perse.
Ogni dato può essere memorizzato una sola volta.
<p>

<p>
RITORNARE DOVE ERAVATE QUANDO AVETE CHIUSO VIM
<p>
Siete a metà della scrittura di un file ed è tempo di andarsene in vacanza.
Uscite da Vim e andate a divertirvi, dimenticandovi tutto del vostro lavoro.
Dopo qualche settimana avviate Vim, e scrivete: > 	'0
<p>
E siete di nuovo lì dove avevate lasciato Vim.
Ora potete continuare col vostro lavoro.
Vim crea un puntatore ogni volta che uscite da Vim.
L'ultimo è '0.
La posizione a cui puntava '0 diventa '1.
E '1 diventa '2, e così via.
Il puntatore '9 andrà perso. Il comando |:marks| è utile per scoprire dove vi porteranno '0 e '9 .
<p>
TORNARE INDIETRO SU QUALCHE FILE
<p>
Se volete ritornare su un file che avete modificato recentement, ma non quando siete usciti da Vim, c'è un modo per farlo, leggermente più complicato.
Potete ottenere una lista di file immettendo il comando: >
<p>
:oldfiles <	1: ~/.viminfo ~ 	2: ~/text/resume.txt ~ 	3: /tmp/draft ~
<p>
Mettiamo che vogliate editare il secondo file, quello che nella lista è preceduto da "2:".
Dovete scrivere: >
<p>
:e #<2
<p>
Al posto di ":e" potete usare ogni comando che abbia come argomento un nome di file,la dicitura "#<2" funziona come le espressioni "%" (nome del file corrente) e "#" (nome alternativo del file).
Allo stesso modo, potete anche dividere la finestra per editare il terzo file: >
<p>
:split #<3
<p>
La notazione #<123 è un po' complicata da ricordare, se volete solo editare un file.
Fortunatamente c'è un modo più semplice: >
<p>
:browse oldfiles <	1: ~/.viminfo ~ 	2: ~/text/resume.txt ~ 	3: /tmp/draft ~ 	-- More --
<p>
Questo comando vi dà la stessa lisat che otterreste con |:oldfiles|.
Se volete editare "resume.txt", battete "q" per interromepre la lista.
Otterrete una richiesta:
<p>
Inserire numero e <Invio> (vuoto per annullare): ~
<p>
Inserite "2" e premete <Invio> per editare il secondo file.

<p>
Maggior informazioni a |:oldfiles|, |v:oldfiles| e |c_#<|.

<p>

<p>

<p>
SPOSTARE LE INFORMAZIONI DA UN VIM AD UN ALTRO
<p>
Potete usare i comandi ":wviminfo" e ":rviminfo" per salvare e ripristinare le informazioni quando Vim è ancora in esecuzione.
Per esempio è utile per scambiare i contenuti del registro tra due istanze di Vim.
Nel primo Vim fate: >
<p>
:wviminfo! ~/tmp/viminfo
<p>
E nel secondo Vim fate: >
<p>
:rviminfo! ~/tmp/viminfo
<p>
Ovviamente, la "w" sta per "write" e la "r" per "read".
Il carattere ! è usato da ":wviminfo" per forzare la riscrittura di un file già esistente.
Quando è omesso, e il file esiste, le informazioni sono fuse in unico file.
Il carattere ! usato per ":rviminfo" significa che verranno usate tutte le informazioni, ciò potrebbe riscrivere informazioni già esistenti.
Senza il ! verranno usate solo le informazioni che non sono impostate.
Questi comandi possono anche essere usati per memorizzare informazioni e riutilizzarle in seguito.
Potreste creare una directory piena di file viminfo, ognuno contenente informazioni per compiti differenti.

<p>
============================================================================== *21.4*	Sessioni
<p>
Supponete di avere scritto a lungo, ed è ormai fine giornata.
Volete interrompere il lavoro e riprenderlo domani dal punto in cui eravate arrivati.
Potete farlo salvando la vostra sessione di lavoro e ripristinandola il giorno seguente.
Una sessione di Vim contiene tutte le informazioni sui file che avete aperto.
Sono incluse cose come l'elenco dei file, la disposizione delle finestre, le variabili globali, le opzioni ed altre informazioni.
(Cosa esattamente viene memorizzato è controllato dall'opzione 'sessionoptions', descritta più sotto) Il seguente comando crea un file di sessione: >
<p>
:mksession vimbook.vim
<p>
Se dopo volete ripristinare la sessione, potete usare questo comando: >
<p>
:source vimbook.vim
<p>
Se volete avviare Vim e ripristinare una specifica sessione, potete usare il seguente comando: >
<p>
vim -S vimbook.vim
<p>
Questo dice a Vim di leggere all'avvio uno specifico file.
La 'S' sta per sessione (al momento potete utilizzare -S per interpretare qualsiasi script sorgente per Vim, quindi potrebbe star bene anche per "sorgente").

<p>
Le finestre che erano aperte sono ripristinate, con la stessa posizione e dimensione di prima.
Le mappature dei tasti e i valori delle opzioni sono le stesse di prima.
Che cosa venga esattamente ripristinato dipende dall'opzione 'sessionoptions'.
Il valore di default è "blank,buffers,curdir,folds,help,options,winsize".

<p>
blank		mantiene le finestre vuote 	buffers		tutti i buffer, non solo quelli dentro ad una finestra 	curdir		la directory corrente 	folds		annidamenti, anche quelli creati manualmente 	help		la finestra d'aiuto 	options		tutte le opzioni e le mappature dei tasti 	winsize		le dimensioni delle finestre
<p>
Cambiatela come preferite.
Per esempio, per ripristinare anche la dimensione della finestra di Vim, usate: >
<p>
:set sessionoptions+=resize
<p>

<p>
SESSIONE QUI, SESSIONE LA'
<p>
Il modo più ovvio per usare le sessioni è quando si lavora su progetti differenti.
Supponete di memorizzare i vostri file di sessione nella directory "~/.vim".
Al momento state lavorando sul progetto "segreto" e volete spostarvi sul progetto "noioso": >
<p>
:wall 	:mksession! ~/.vim/segreto.vim 	:source ~/.vim/noioso.vim
<p>
La prima usa ":wall" per scrivere tutti i file modificati.
Dopo, la sessione corrente viene salvata, usando ":mksession!".
La precedente sessione viene sovrascritta.
La prossima volta che caricherete la sessione segreta potrete continuare da dove eravate in questo momento.
E finalmente caricate la nuova sessione "noioso".

<p>
Se aprite delle finestre di help, dividete e chiudete varie finestre, ed alterate in generale l'aspetto delle finestre, potrete tornare all'ultima sessione salvata: >
<p>
:source ~/.vim/noioso.vim
<p>
Avrete quindi un controllo completo se la prossima volta vorrete continuare da dove vi trovate adesso, salvando la configurazione corrente in una sessione o mantenendo i file di sessione come punto di partenza.
Un altro modo di usare le sessioni è di creare una disposizione di finestre che vi piaccia usare e salvarla in una sessione.
Potrete tornare a questa disposizione quando vorrete.
Per esempio, questa è una bella disposizione da usare:
<p>
+----------------------------------------+ 	|		 VIM - main help file | 	|					 | 	|Move around: Use the cursor keys, or "h| 	|help.txt================================| 	|explorer |				 | 	|dir	 |~				 | 	|dir	 |~				 | 	|file	 |~				 | 	|file	 |~				 | 	|file	 |~				 | 	|file	 |~				 | 	|~/=========|[No File]===================| 	|					 | 	+----------------------------------------+
<p>
Ha una finestra d'aiuto all'inizio, così che possiate leggere questo testo.
La stretta finestra verticale sulla sinistra contiene un navigatore di file.
È un plugin di Vim che elenca il contenuto di una directory.
Da li' potete selezionare i file da aprire.
Maggiori informazioni in merito nel prossimo capitolo.
Createla da un Vim appena avviato con: >
<p>
:help 	CTRL-W w 	:vertical split ~/
<p>
Potete ridimensionare un po' le finestre a seconda dei vostri gusti.
Dopo salvate la sessione con: > > 	:mksession ~/.vim/mia.vim
<p>
Ora potete avviare Vim con questa disposizione: >
<p>
vim -S ~/.vim/mia.vim
<p>
Suggerimento: Per aprire un file che vedere elencato nella finestra del navigatore nella finestra vuota, muovete il cursore sul nome del file e premete "O".
Un doppio clic col mouse fa la stessa cosa.
<p>
UNIX E MS-WINDOWS
<p>
Alcune persone devono lavorare un giorno su sistemi MS-Windows e un altro giorno su Unix.
Se siete uno di loro, considerate di aggiungere "slash" e "unix" a 'sessionoptions'.
I file di sessione saranno scritti in un formato che potrà esser usato su entrambi i sistemi.
Questo è il comando da inserire nel vostro file vimrc: >
<p>
:set sessionoptions+=unix,slash
<p>
Vim quindi userà il formato Unix, perché il Vim per MS-Windows può leggere e scrivere file Unix, ma il Vim di Unix non può leggere file di sessione nel formato MS-Windows.
Similarmente, il Vim di MS-Windows comprende i nomi dei file con / per separare i nomi, ma il Vim di Unix non comprende \.

<p>

<p>
SESSIONI E VIMINFO
<p>
Le sessioni memorizzano molte cose, ma non la posizione dei puntatori, il contenuto dei registri e la storia della linea di comando.
Per queste cose avete bisogno delle capacità di viminfo.
Nella maggior parte delle situazioni vorrete usare le sessioni separatamente da viminfo.
Ciò può essere usato per spostarsi su un'altra sessione, ma mantenere la storia della linea di comando.
E copiare del testo nei registri in una sessione e riportarlo in un'altra sessione.
Potreste preferire mantenere le informazioni con la sessione.
Dovrete farlo voi stessi allora.
Esempio: > 	:mksession! ~/.vim/segreto.vim 	:wviminfo! ~/.vim/segreto.viminfo
<p>
E per ripristinarlo di nuovo: >
<p>
:source ~/.vim/segreto.vim 	:rviminfo! ~/.vim/segreto.viminfo
<p>
============================================================================== *21.5*	Viste
<p>
Una sessione memorizza l'aspetto dell'intero Vim.
Quando volete memorizzare le proprietà di una sola finestra, usate una vista.
La vista si usa quando volete lavorare su di un file in un modo specifico.
Per esempio, avete il numero delle linee attivato con l'opzione 'number' e alcuni annidamenti sono definiti.
Proprio come con le sessioni, potete memorizzare questa vista su un file e ripristinarla in seguito.
Adesso, quando memorizzate una sessione, vengono salvate le viste di ogni finestra.
Ci sono due modi principali per usare le viste.
Il primo è di lasciare che sia Vim a scegliere il nome del file della vista.
Potete ripristinare la vista quando in seguito aprirete lo stesso file.
Per memorizzare la vista della finestra corrente: >
<p>
:mkview
<p>
Vim deciderà dove memorizzare la vista.
Quando in seguito aprirete lo stesso file potrete riavere la vostra vista con questo comando: >
<p>
:loadview
<p>
È facile, non è vero? Ora vorreste vedere il file senza l' opzione 'number' attivata, o con tutti gli annidamenti aperti, potete impostare le opzioni per rendere la finestra così.
Dopo, memorizzare questa vista con: >
<p>
:mkview 1
<p>
Ovviamente, potete ricaricarla con: >
<p>
:loadview 1
<p>
Ora potete cambiare tra le due viste del file usando ":loadview" con, e senza, l' argomento "1".
In questo modo potete memorizzare fino a dieci viste per lo stesso file, una senza numero e nove numerate da 1 a 9.

<p>
UNA VISTA CON NOME
<p>
Il secondo metodo principale per usare le viste è di memorizzarle in un file con un nome di vostra scelta.
Questa vista potrà essere ricaricata mentre state aprendo un altro file.
Vim cambierà il file aperto utilizzando quello specificato nella vista.
Potete quindi usarla per cambiare velocemente il file aperto, con tutte le opzioni impostate come quando l'avete salvato.
Per esempio, per salvare la vista del file corrente: >
<p>
:mkview ~/.vim/principale.vim
<p>
Potete ripristinarla con: >
<p>
:source ~/.vim/principale.vim
<p>
============================================================================== *21.6*	Modeline
<p>
Quando aprite uno specifico file, potete impostare opzioni per quel particolare file.
Scrivere ogni volta questi comandi è noioso.
Usare una sessione o vista per aprire un file non funziona quando il file è condiviso tra più persone.
La soluzione per questa situazione è aggiungere una modeline al file.
È una linea di testo che dice a Vim i valori delle opzioni da usare solo in questo file.
Un tipico esempio è un programma in C dove dovete far rientrare le linee con multipli di 4 spazi.
Ciò richiede l'impostazione dell'opzione 'shiftwidth' a 4.
Questa modeline lo farà:
<p>
/* vim:set shiftwidth=4: */ ~
<p>
Inserite questa linea tra le prime o le ultime cinque righe nel file.
Quando aprirete il file, noterete che 'shiftwidth' è stata impostata a quattro.
Quando aprirete un altro file, verrà reimpostata al valore di default di otto.
Per alcuni file la modeline si adegua bene ad essere inserita nell'header, sempre che possa esser inserita all'inizio.
Per file di testo e altri file dove la modeline fa parte del normale contenuto, inseritela alla fine del file.

<p>
L'opzione 'modelines' specifica quante linee all'inizio e alla fine del file sono ispezionate per controllare se hanno una modeline.
Per ispezionare dieci linee: >
<p>
:set modelines=10
<p>
L'opzione 'modeline' può esser usata per disattivare questa capacità.
Fatelo quando state lavorando come root in Unix o come Administrator in MS-Windows, o quando non vi fidate dei file che state aprendo: >
<p>
:set nomodeline
<p>
usate questo formato per la modeline:
<p>
qualsiasi-testo vim:set {option}={value} ...
: qualsiasi-testo ~
<p>
Il "qualsiasi-testo" indica che potete inserire qualsiasi testo prima e dopo la parte che userà Vim.
Ciò permette di farlo sembrare un commento, come quello che è stato fatto sopra con /* e */.
La parte " vim:" è quella che permette a Vim di riconoscere la linea.
Ci deve essere uno spazio vuoto prima di "vim", oppure "vim" deve stare all'inizio della linea.
Usare qualcosa tipo "gvim:" non funzionerà.
La parte tra i doppi punti è un comando ":set".
Funziona nello stesso modo che scrivere il comando ":set", eccezion fatta per il backslash che deve essere inserito prima del doppio punto (altrimenti lo vedrebbe come fine della modeline).

<p>
Un altro esempio:
<p>
// vim:set textwidth=72 dir=c\:\tmp: use c:\tmp here ~
<p>
C'è un backslash in più prima del doppio punto, così sarà incluso nel comando ":set".
Il testo dopo il secondo doppio punto sarà ignorato, quindi potete inserirci un commento.

<p>
Per maggiori informazioni guardate |modeline|.

<p>
==============================================================================
<p>
Capitolo seguente: |usr_22.txt| Trovare il file da aprire
<p>
Copyright: vedere |manual-copyright| vim:tw=78:ts=8:ft=help:norl:
<p>
Per segnalazioni scrivere a vimdoc.it at gmail dot com oppure ad Antonio Colombo azc100 at gmail dot com *usr_22.txt*	Per Vim version 7.2.
Ultima modifica: 2007 Ago 14
<p>
VIM USER MANUAL - di Bram Moolenaar 		Traduzione di questo capitolo: Stefano Palmeri
<p>
Trovare il file da aprire
<p>

<p>
I file possono venir trovati ovunque.
Così, come fare a trovarli? Vim offre vari modi per esplorare l'albero delle directory.
Ci sono comandi per saltare ad un file che è menzionato in un altro.
E Vim ricorda quali file siano stati modificati in precedenza.

<p>
|22.1|	Il file browser |22.2|	La directory corrente |22.3|	Trovare un file |22.4|	La lista dei buffer
<p>
Capitolo seguente: |usr_23.txt| Modifica di altri file Capitolo precedente: |usr_21.txt| Andarsene e ritornare 	 Indice: |usr_toc.txt|
<p>
============================================================================== *22.1*	Il file browser
<p>
Vim ha un plugin che rende possibile visualizzare una directory.
Provate questo: >
<p>
:edit .

<p>
Tramite la magia dei comandi automatici e degli script di Vim, la finestra verrà riempita con i contenuti della directory.
Apparirà come questa:
<p>
" ============================================================================ ~ " Netrw Directory Listing (netrw v109) ~ " Sorted by name ~ " Sort sequence: [\/]$,\.h$,\.c$,\.cpp$,*,\.info$,\.swp$,\.o$\.obj$,\.bak$ ~ " Quick Help: <F1>:help -:go up dir D:delete R:rename s:sort-by x:exec ~ " ============================================================================ ~ ../ ~ ./ ~ check/ ~ Makefile ~ autocmd.txt ~ change.txt ~ eval.txt~ ~ filetype.txt~ ~ help.txt.info ~
<p>
Potrete vedere queste voci:
<p>
1.
Il nome dello strumento di browsing tool e il suo numero di versione 2.
Il nome della directory in browsing 3.
Il tipo di ordinamento della lista (può essere per nome, data, o dimensione, rispettivamente name, time, size) 4.
Come vanno ordinati i nomi (prima le directory poi i file *.h, i file *.c, etc.) 5.
Come ottenere aiuto (usare il tasto <F1>), e una lista abbreviata dei comandi disponibili 6.
Una lista di file, compreso "../", il che permette di raggiungere la directory superiore (parent directory).

<p>
Se l'evidenziazione della sintassi è abilitata, le diverse parti sono messe in evidenza in modo da poterle individuare più facilmente.

<p>
Potete usare i comandi di Vim in Normal mode per muovervi nel testo.
Ad esempio, spostate il cursore su un nome file e premete <Invio>; vi troverete in modifica su quel file.
Per tornare di nuovo nel browser, usate nuovamente ":edit .", oppure usate ":Explore".
Si può usare anche CTRL-O.
Provate a usare <Invio> mentre il cursore è sul nome di una directory.
Il risultato è che il file browser si sposta in quella directory e mostra quel che si trova in essa.
Premendo <Invio> sulla prima directory "../" vi sposta al livello superiore.
Premere "-" fa la stessa cosa, senza bisogno di portare prima il cursore su "../".

<p>
Potete premere <F1> per avere aiuto sulle cose che potete fare nel netrw browser.
Questo è ciò che otterrete: >
<p>
9.
Directory Browsing	 netrw-browse netrw-dir netrw-list netrw-help
<p>
MAPS								 netrw-maps 	 <F1>.............Help.......................................|netrw-help| 	 <cr>.............Browsing...................................|netrw-cr| 	 <del>............Deleting Files or Directories..............|netrw-delete| 	 -................Going Up...................................|netrw--| 	 a................Hiding Files or Directories................|netrw-a| 	 mb...............Bookmarking a Directory....................|netrw-mb| 	 gb...............Changing to a Bookmarked Directory.........|netrw-gb| 	 c................Make Browsing Directory The Current Dir....|netrw-c| 	 d................Make A New Directory.......................|netrw-d| 	 D................Deleting Files or Directories..............|netrw-D| 	 <c-h>............Edit File/Directory Hiding List............|netrw-ctrl-h| 	 i................Change Listing Style.......................|netrw-i| 	 <c-l>............Refreshing the Listing.....................|netrw-ctrl-l| 	 o................Browsing with a Horizontal Split...........|netrw-o| 	 p................Use Preview Window.........................|netrw-p| 	 P................Edit in Previous Window....................|netrw-p| 	 q................Listing Bookmarks and History..............|netrw-q| 	 r................Reversing Sorting Order....................|netrw-r| < 	(etc)
<p>
Il tasto <F1> vi porta poi a una pagina di indice dell'aiuto sui contenuti del netrw browser.
E' una normale pagina di aiuto; usate il solito |CTRL-]| per saltare a elementi marcati (tag) e |CTRL-O| per tornare indietro.

<p>
Per scegliere file da vedere e modificare: (col cursore sopra un nome file)
<p>
<enter>		Apre il file nella finestra corrente.	 |netrw-cr| 	o		Divide in orizz.
finestra e mostra file |netrw-o| 	v		Divide in vert.
finestra e mostra file |netrw-v| 	p		Usa la |preview-window| 		 |netrw-p| 	P		Manda in edit nella finestra precedente |netrw-P| 	t		Apre il file in una nuova linguetta	 |netrw-t|
<p>
I seguenti comandi in Normal mode si possono usare per controllare quel che il browser mostra:
<p>
i		Controlla stile lista (thin, long, wide, and tree).
(smilzo, lungo, largo e ad albero).
La lista lunga include le informazioni dimensione e 			data.
s		Premendo s ripetutamente alterna fra i modi in cui 			i file sono ordinati; si può ordinare per nome, data 			di modifica, o dimensione.
r		Inverte l'ordine della lista ["gli ultimi saranno i 			primi"].

<p>
Come esempio di comandi differenti da quelli in Normal mode:
<p>
c		Cambia l'idea di directory corrente per Vim, 			questa diventa la stessa della directory del browser.
(Vederer |g:netrw_keepdir| per controllare anche 			questo) 	R		Rinomina il file o directory sotto il cursore; una 			domanda verrà fatta per specificare il nuovo nome.
D		Elimina il file o directory sotto il cursore; verrà 			fatta una domanda di conferma.
mb gb		Crea un segnalibro [bookmark] /vai a un segnalibro
<p>

<p>
Si può anche usare il Command mode; ancora, solo qualche esempio:
<p>
:Explore [directory]	Esplora la directory specificata/corrente 	:NetrwSettings		Una lista esauriente delle impostazioni netrw 				correnti, con possibile accesso all'aiuto.

<p>
Il browser netrw non è solo limitato alla vostra macchina locale; si possono usare URL, come:	(la "/" finale è importante)
<p>
:Explore ftp://somehost/path/to/dir/ 	:e scp://somehost/path/to/dir/ Si veda |netrw-browse| per ulteriori informazioni.

<p>
============================================================================== *22.2*	La directory corrente
<p>
Proprio come la shell, Vim ha il concetto di directory corrente.
Supponete che voi siate nella vostra home directory e vogliate aprire alcuni file nella directory "VeryLongFileName".
Potete fare: >
<p>
:edit VeryLongFileName/file1.txt 	:edit VeryLongFileName/file2.txt 	:edit VeryLongFileName/file3.txt
<p>
Per evitare una digitazione eccessiva, fate questo: >
<p>
:cd VeryLongFileName 	:edit file1.txt 	:edit file2.txt 	:edit file3.txt
<p>
Il comando ":cd" cambia la directory corrente.
Potete vedere quale sia la directory corrente con il comando ":pwd" : >
<p>
:pwd 	/home/Bram/VeryLongFileName
<p>
Vim ricorda l'ultima directory che avete usato.
Usate "cd -" per ritornarvi.
Esempio: >
<p>
:pwd 	/home/Bram/VeryLongFileName 	:cd /etc 	:pwd 	/etc 	:cd - 	:pwd 	/home/Bram/VeryLongFileName 	:cd - 	:pwd 	/etc
<p>

<p>
LA FINESTRA DELLA DIRECTORY LOCALE
<p>
Quando dividete una finestra, entrambe le finestre useranno la stessa directory corrente.
Quando volete modificare un certo numero di file da qualche altra parte nella nuova finestra, potete far sì che essa usi un'altra directory, senza cambiare la directory corrente nell'altra finestra.
Questa si chiama directory locale.
>
<p>
:pwd 	/home/Bram/VeryLongFileName 	:split 	:lcd /etc 	:pwd 	/etc 	CTRL-W w 	:pwd 	/home/Bram/VeryLongFileName
<p>
Fintanto che il comando ":lcd" non sia stato usato, tutte le finestre condivideranno la stessa directory corrente.
Eseguire un comando ":cd" in una finestra cambierà la directory corrente anche nell'altra finestra.
Per una finestra dove sia stato usato il comando ":lcd" verrà ricordata una directory corrente differente.
Usare ":cd" o ":lcd" in altre finestre non la cambierà.
Quando si usa il comando ":cd" in una finestra posta in una diversa directory corrente, farà tornare ad usare la directory condivisa.

<p>
============================================================================== *22.3*	Trovare un file
<p>
State scrivendo un programma in linguaggio C che contiene questa linea:
<p>
#include "inits.h" ~
<p>
Volete vedere cosa c'è in quel file "inits.h".
Muovete il cursore sul nome del file e digitate: >
<p>
gf
<p>
Vim troverà il file e ne mostrerà il contenuto.
Cosa succede se il file non è nella directory corrente? Vim userà l'opzione 'path' per trovare il file.
Questa opzione è un elenco di nomi di directory nelle quali cercare il vostro file.
Supponete che i vostri file include siano in "c:/prog/include".
Questo comando la aggiungerà alla opzione 'path': >
<p>
:set path+=c:/prog/include
<p>
Questa directory si trova in un percorso assoluto.
Non importa dove voi siate, sarà lo stesso posto.
Cosa fare se avete collocato dei file in una subdirectory, al di sotto di dov'è il file? Potete specificare un percorso relativo.
Questo inizia con un punto: >
<p>
:set path+=./proto
<p>
Questo dice a Vim di cercare nella directory "proto", sotto la directory dove si trova il file nel quale avete usato "gf".
Così, usare "gf" su "inits.h" farà sì che Vim cerchi "proto/inits.h", iniziando nella directory del file.
Senza "./", quindi "proto", Vim dovrebbe cercare nella directory "proto" sotto la directory corrente.
La directory corrente, però, potrebbe non essere quella dove il file che state modificando è collocato.

<p>
L'opzione 'path' permette di specificare le directory dove cercare i file in molti più modi.
Leggete l'aiuto per l'opzione 'path'.
L'opzione 'isfnamè è usata per decidere quali caratteri sono inclusi nel nome del file e quali non lo sono (es., il carattere " nell'esempio in alto).

<p>
Quando conoscete il nome del file, ma non deve essere trovato nel file, potete digitare questo: >
<p>
:find inits.h
<p>
Vim userà quindi l'opzione 'path' per trovare il file.
Questa è la stessa cosa del comando ":edit", eccetto che per l'uso di 'path'.

<p>
Per aprire il file trovato in una nuova finestra usate CTRL-W f anziché "gf", oppure usate ":sfind" al posto di ":find".

<p>

<p>
Un bel modo per avviare direttamente Vim per aprire un file che sia ovunque nel 'path' è: >
<p>
vim "+find stdio.h"
<p>
Ciò trova "stdio.h" nel vostro valore di 'path'.
I doppi apici sono necessari per avere un solo argomento |-+c|.

<p>
============================================================================== *22.4*	La lista dei buffer
<p>
L'editor Vim usa il buffer del terminale per descrivere un file che si sta aprendo.
In realtà, il buffer è una copia del file sul quale voi state lavorando.
Quando avrete finito di modificare il buffer, voi scriverete i contenuti del buffer nel file.
I buffer non contengono solo i contenuti del file, ma anche tutti i segnalibri, le impostazioni e le altre cose che lo accompagnano.

<p>

<p>
NASCONDERE I BUFFER
<p>
Supponete che voi stiate lavorando sul file one.txt e abbiate bisogno di passare al file two.txt.
Potreste usare semplicemente ":edit two.txt", ma poiché avete fatto delle modifiche in one.txt, quel comando non funzionerà.
Inoltre non volete ancora salvare one.txt.
Vim ha una soluzione per voi: >
<p>
:hide edit two.txt
<p>
Il buffer "one.txt" scompare dallo schermo, ma Vim sa ancora che voi state lavorando su questo buffer, così conserva il testo modificato.
Questo viene chiamato buffer nascosto: il buffer contiene il testo, ma voi non potete vederlo.
L'argomento del comando ":hide" è un altro comando.
":hide" fa sì che quel comando si comporti come se l'opzione 'hidden' sia stata impostata.
Potete anche impostare questa opzione esplicitamente.
L'effetto è che quando un buffer viene lasciato, esso diventa nascosto.
State attenti! Quando avete nascosto buffer con cambiamenti, non chiudete Vim senza essere sicuri di avere salvato tutti i buffer.

<p>

<p>
INATTIVARE I BUFFER
<p>
Quando un buffer è stato usato una volta, Vim ricorda alcune informazioni su di esso.
Quando non appare in una finestra e non è nascosto, esso è ancora nella lista dei buffer.
Questo viene chiamato buffer inattivo. Panoramica:
<p>
Attivo		Appare in una finestra, testo caricato.
Nascosto		Non è in una finestra, testo caricato.
Inattivo		Non è in una finestra, testo non caricato.

<p>
I buffer inattivi vengono memorizzati, poiché Vim conserva le informazioni che li riguardano, come i segnalibri.
Ed anche il ricordare il nome del file è utile, affinché voi possiate vedere su quali file avete lavorato.
Ed aprirli ancora.

<p>

<p>
ELENCARE I BUFFERS
<p>
Esaminate la lista dei buffer con questo comando: >
<p>
:buffers
<p>
Un comando che fa la stessa cosa, non così ovvio per elencare i buffer, ma molto più corto da digitare, è: >
<p>
:ls
<p>
L'output potrebbe apparire come questo:
<p>
1 #h	"help.txt"			line 62 ~ 2 %a+	"usr_21.txt"			line 1 ~ 3	"usr_toc.txt"			line 1 ~
<p>
La prima colonna contiene il numero del buffer.
Potete usare questo per ritornare ad un buffer senza doverne digitare il nome, guardate sotto.
Dopo il numero del buffer vengono i flag.
Quindi segue il nome del file ed il numero della linea dove era il cursore l'ultima volta.
I flag che possono apparire sono questi (da sinistra a destra):
<p>
u	Il buffer è unlisted (non in lista) |unlisted-buffer|.
%	Buffer corrente.
#	Buffer alternativo.
a	Il buffer è caricato e mostrato.
h	Il buffer è caricato ma nascosto.
=	Il buffer è di sola lettura (read-only).
-	Il buffer non è modificabile, l'opzione 'modifiable' è 		inattiva.
+	Il buffer è stato modificato.

<p>

<p>
RITORNARE AD UN BUFFER
<p>
Potete ritornare ad un buffer tramite il suo numero.
Questo evita di dover scrivere il nome del file : >
<p>
:buffer 2
<p>
Ma il solo modo di sapere il numero è guardare nell'elenco dei buffer.
Potete, invece, usare il nome, o parte di esso: >
<p>
:buffer help
<p>
Vim troverà la migliore corrispondenza per il nome che avete digitato.
Se c'è un solo buffer che corrisponde al nome, esso verrà usato.
In questo caso "help.txt".
Per aprire un buffer in una nuova finestra: >
<p>
:sbuffer 3
<p>
Funziona anche con il nome ugualmente bene.

<p>

<p>
USARE LA LISTA DEI BUFFER
<p>
Potete muovervi nella lista dei buffer con questi comandi:
<p>
:bnext		va al buffer successivo 	:bprevious	va al buffer precedente 	:bfirst		va al primo buffer 	:blast		va all'ultimo buffer
<p>
Per rimuovere un buffer dalla lista, usate questo comando: >
<p>
:bdelete 3
<p>
Ancora, ciò funziona anche con un nome.
Se cancellate un buffer che era attivo (visibile in una finestra), quella finestra verrà chiusa.
Se cancellate il buffer corrente, la finestra corrente verrà chiusa.
Se fosse l'ultima finestra, Vim cercherebbe un altro buffer da modificare.
Voi non potete non avere nulla di aperto!
<p>
Note: 	Anche dopo aver rimosso il buffer con ":bdelete", Vim lo ricorderà.
In realtà esso è reso "unlisted" e non compare più nella lista di 	":buffers".
Il comando ":buffers!" elencherà i buffer unlisted 	(sì, Vim può fare l'impossibile).
Perché Vim dimentichi veramente 	un buffer, usate ":bwipe".
Vedete anche l'opzione 'buflisted'.
<p>
==============================================================================
<p>
Capitolo seguente: |usr_23.txt| Modifica di altri file
<p>
Copyright: vedere |manual-copyright| vim:tw=78:ts=8:ft=help:norl:
<p>
Per segnalazioni scrivere a vimdoc.it at gmail dot com oppure ad Antonio Colombo azc100 at gmail dot com *usr_23.txt*	Per Vim version 7.2.
Ultima modifica: 2006 Apr 24
<p>
VIM USER MANUAL - di Bram Moolenaar 	 Traduzione di questo capitolo: Cristian Rigamonti
<p>
Modifica di altri file
<p>

<p>
Questo capitolo tratta l'elaborazione di file diversi da quelli ordinari.
Con Vim potete elaborare file compressi o cifrati, file a cui si accede solo via internet e, con alcune restrizioni, file binari.

<p>
|23.1|	File DOS, Mac e Unix |23.2|	File su internet |23.3|	File cifrati |23.4|	File binari |23.5|	File compressi
<p>
Capitolo seguente: |usr_24.txt| Inserzione rapida Capitolo precedente: |usr_22.txt| Trovare il file da aprire 	 Indice: |usr_toc.txt|
<p>
============================================================================== *23.1*	File DOS, Mac e Unix
<p>
Ai vecchi tempi, le macchine telescriventi usavano due caratteri per iniziare una nuova linea: uno per far ritornare il carrello alla prima posizione (carriage return, <CR>), un altro per far scorrere la carta (line feed, <LF>).
Con l'arrivo dei computer, lo spazio di immagazzinamento divenne costoso e qualcuno decise che non c'era bisogno di due caratteri per l'interruzione di linea.
I programmatori UNIX decisero di usare solo <Line Feed> per l'interruzione di linea, i programmatori Apple si accordarono per <CR>, quelli MS-DOS (e Microsoft Windows) decisero di tenere il vecchio <CR><LF>.
Questo significa che se provate a trasferire un file da un sistema all'altro, incontrate dei problemi nelle interruzioni di linea.
L'editor Vim riconosce automaticamente i diversi formati di file e si occupa di gestirli in modo trasparente.
L'opzione 'fileformats' contiene i vari formati che verranno provati quando viene elaborato un nuovo file.
Il comando seguente, ad esempio, dice a Vim di provare per primo il formato UNIX e poi quello MS-DOS: >
<p>
:set fileformats=unix,dos
<p>
Riconoscerete il formato dal messaggio che otterrete quando aprite un file.
Se state usando il formato nativo non vedrete alcun messaggio, questo succede ad esempio elaborando un file Unix su Unix; se invece aprite un file dos, Vim vi avvertirà:
<p>
"/tmp/test" [dos] 3L, 71C ~
<p>
Per un file Mac vedreste "[mac]".
Il formato del file riconosciuto sarà immagazzinato nell'opzione 'fileformat'.
Per vedere il formato corrente, eseguite il seguente comando: >
<p>
:set fileformat?
<p>
I tre nomi usati da Vim sono:
<p>
unix		<LF> 	dos		<CR><LF> 	mac		<CR>
<p>

<p>
USARE IL FORMATO MAC
<p>
Su Unix, <LF> è usato per interrompere una linea.
Non è insolito avere un carattere <CR> nel mezzo di una linea.
Incidentalmente, ciò capita abbastanza spesso negli script di Vi (e Vim).
Sul Macintosh, dove <CR> è il carattere di interruzione di linea, è possibile incontrare un carattere <LF> all'interno di una linea.
Il risultato è che non è possibile essere sicuri al 100% del fatto che un file che contiene sia caratteri <CR> che <LF> sia un file Mac o Unix.
Vim assume quindi che su Unix probabilmente non si useranno file Mac e non controllerà per questo tipo di file.
Per controllare comunque anche per questo tipo di file, aggiungete "mac" a 'fileformats': >
<p>
:set fileformats+=mac
<p>
Allora Vim darà uno sguardo al formato del file.
Attenzione ai casi in cui Vim veda sbagliato.

<p>

<p>
FORZARE IL FORMATO
<p>
Se usate il buon vecchio Vi e provate a elaborare un file in formato MS-DOS, vi accorgerete che ogni linea finisce con un carattere ^M.
(^M corrisponde a <CR>).
Il riconoscimento automatico di Vim evita questa situazione.
Ma supponiamo che invece vogliate elaborare il file nel suo formato originario.
In questo caso dovete forzare il formato: >
<p>
:edit ++ff=unix file.txt
<p>
La stringa "++" avvisa Vim che il valore dell'opzione specificata prevarrà sul valore predefinito limitatamente al comando che segue.
"++ff" è usato al posto di 'fileformat'; potete anche usare "++ff=mac" o "++ff=dos".
Questo meccanismo non funziona per tutte le opzioni: al momento sono implementate solo "++ff" e "++enc".
Si possono usare anche i nomi completi "++fileformat" e "++encoding".

<p>

<p>
CONVERSIONE
<p>
Potete usare l'opzione 'fileformat' per convertire un file da un formato all'altro.
Supponete, ad esempio, di avere un file MS-DOS chiamato README.TXT, che volete convertire in formato UNIX.
Iniziate a elaborare il file in formato MS-DOS: >
<p>
vim README.TXT
<p>
Vim riconoscerà che questo è un file in formato dos.
Ora cambiate il formato in UNIX: >
<p>
:set fileformat=unix 	:write
<p>
Il file viene scritto in formato Unix.

<p>
============================================================================== *23.2*	File su internet
<p>
Qualcuno vi spedisce un messaggio e-mail che fa riferimento ad un file tramite la sua URL.
Ad esempio:
<p>
Trovi le informazioni qui: ~ 		ftp://ftp.vim.org/pub/vim/README ~
<p>
Potreste avviare un programma per scaricare il file, salvarlo sul vostro disco locale ed allora avviare Vim per elaborarlo.
C'è un modo più semplice.
Spostate il cursore su un qualsiasi carattere dell'URL.
Poi usate questo comando: >
<p>
gf
<p>
Con un po' di fortuna, Vim troverà quale programma usare per scaricare il file, scaricarlo ed aprirne la copia.
Per aprire il file in una nuova finestra usate CTRL-W f.
Se qualcosa andasse storto, riceverete un messaggio di errore.
E' possibile che l'URL sia sbagliata, che non abbiate il permesso di leggerlo, che la connessione di rete non sia attiva, ecc.
Purtroppo è difficile stabilire la causa dell'errore.
Dovrete tentare il modo manuale di scaricare il file.

<p>
L'accesso dei file via internet funziona col plugin netrw.
Al momento sono riconosciuti gli URL con questi formati:
<p>
ftp://		usa ftp 	rcp://		usa rcp 	scp://		usa scp 	http://		usa wget (sola lettura)
<p>
Vim non fa lui stesso la comunicazione, ricorre ai programmi menzionati che sono installati sul vostro computer.
Sulla maggior parte dei sistemi Unix "ftp" e "rcp" saranno presenti; "scp" e "wget" probabilmente dovranno venire installati.

<p>
Vim riconosce queste URL per ciascun comando che inizi ad aprire un nuovo file, anche, ad esempio, con ":edit" e ":split".
Funziona anche nei comandi di scrittura, eccetto per http://.

<p>
Per maggiori informazioni, anche a proposito delle password, si veda |netrw|.

<p>
============================================================================== *23.3*	Cifratura
<p>
Alcune informazioni preferite tenerle per voi stessi.
Ad esempio, quando state scrivendo una prova d'esame su un computer usato anche dagli studenti.
Non volete che i più furbi trovino un modo per leggere le domande prima dell'inizio dell'esame.
Vim può cifrare il file, dandovi qualche protezione.
Per iniziare a scrivere un nuovo file con la cifratura, usate l'argomento "-x" per avviare Vim.
Esempio: >
<p>
vim -x exam.txt
<p>
Vim vi chiede una chiave usata per cifrare e decifrare il file:
<p>
Immetti chiave di cifratura: ~
<p>
Accuratamente scrivete la chiave segreta: non vedrete i caratteri che digitate, saranno sostituiti da asterischi.
Per evitare che un errore di digitazione causi problemi, Vim vi chiede di immettere ancora la chiave:
<p>
Ribatti per conferma la stessa chiave: ~
<p>
Ora potete elaborare il file normalmente e scriverci tutti i vostri segreti.
Quando avete finito e dite a Vim di uscire, il file viene cifrato e scritto.
Quando aprite il file con Vim, vi chiederà di immettere nuovamente la stessa chiave.
Non avrete bisogno di usare l'argomento "-x".
Potete anche usare il normale comando ":edit".
Vim aggiunge una stringa magica al file, dalla quale riconosce che il file è stato cifrato.
Se tentate di vedere il file con un altro programma, tutto ciò che ottenete è spazzatura.
Così, se aprite il file con Vim e immettete la chiave sbagliata, ottenete spazzatura.
Vim non ha un meccanismo per controllare se la chiave sia quella giusta (ciò rende molto più difficile tentare di indovinare la chiave).

<p>

<p>
ATTIVARE E DISATTIVARE LA CIFRATURA
<p>
Per disabilitare la cifratura di un file, impostate l'opzione 'key' a una stringa vuota: >
<p>
:set key=
<p>
La prossima volta che scriverete il file, verrà fatto senza cifratura.
Impostare l'opzione 'key' per abilitare la cifratura non è una buona idea, visto che la chiave apparirebbe in chiaro.
Chiunque fosse dietro di voi potrebbe leggere la chiave.
Per evitare questo problema è stato introdotto il comando ":X".
Vi chiede una chiave di cifratura, proprio come fa l'argomento "-x": >
<p>
:X Immetti chiave di cifratura: ****** Ribatti per conferma la stessa chiave: ******
<p>

<p>
LIMITI DELLA CIFRATURA
<p>
L'algoritmo di cifratura usato da Vim è debole.
È abbastanza valido per tenere alla larga il ficcanaso occasionale, ma non lo è abbastanza per un esperto crittografo con molto tempo a disposizione.
Dovete anche tenere presente che il file di swap non è cifrato, quindi mentre elaborate un file, gli utenti con privilegi di amministratore possono leggere il testo in chiaro da questo file.
Un modo per evitare che la gente legga il vostro file di swap è quello di non usarne uno.
Aggiungendo l'argomento -n alla linea di comando, non viene usato alcun file di swap: Vim terrà tutto in memoria.
Ad esempio per elaborare il file cifrato "file.txt" senza usare il file di swap, usate il comando seguente: >
<p>
vim -x -n file.txt
<p>
Quando state elaborando un file, il file di swap può essere disabilitato con: >
<p>
:setlocal noswapfile
<p>
Poiché manca il file di swap, il recupero diverrà impossibile.
Salvate il file un pò più spesso del solito per evitare il rischio di perdere le modifiche effettuate.

<p>
Sino a quando è in memoria, il file è in chiaro.
Qualunque utente privilegiato può guardare nella memoria dell'editor e scoprire i contenuti del file.
Se usate un file viminfo, fate attenzione che i contenuti dei registri di testo sono scritti in chiaro.
Se davvero volete proteggere i contenuti di un file, elaboratelo solo su un computer portatile non connesso in rete, usate buoni strumenti crittografici e tenete il computer chiuso in un posto sicuro quando non lo usate.

<p>
============================================================================== *23.4*	File binari
<p>
Potete aprire file binari con Vim.
Poiché Vim non è davvero fatto per questo, ci sono alcune restrizioni.
Ma potete leggere un file, cambiare un carattere e riscriverlo, col risultato che solo quel carattere sarà stato modificato, mentre il file è identico altrove.
Per essere sicuri che Vim non usi qualcuno dei suoi trucchi nel modo sbagliato, aggiungete l'argomento "-b" all'avvio: >
<p>
vim -b datafile
<p>
Ciò imposta l'opzione 'binary', che ha l'effetto di disattivare effetti collaterali inaspettati.
Ad esempio, 'textwidth' è impostato a zero per evitare la formattazione automatica delle linee.
Ed i file vengono comunque letti in formato Unix.

<p>
Il Binary mode può essere usato per modificare un messaggio in un programma.
Fate attenzione a non inserire o cancellare qualche carattere, il programma non funzionerebbe più.
Usate "R" per entrare in modalità sostituzione.
<p>
Molti caratteri del file non saranno stampabili.
Per vederli in formato Hex: >
<p>
:set display=uhex
<p>
Altrimenti potete usare il comando "ga" per vedere il valore del carattere sotto il cursore.
Il risultato, quando il cursore è su un <Esc>, è questo:
<p>
<^[> 27, Esa 1b, Ottale 033 ~
<p>
Potrebbero non esserci molte interruzioni di linea nel file.
Per avere una panoramica del file, disabilitate l'opzione 'wrap': >
<p>
:set nowrap
<p>

<p>
POSIZIONE IN BYTE
<p>
Per vedere in quale byte del file vi trovate, usate questo comando: >
<p>
g CTRL-G
<p>
Il risultato è lungo:
<p>
Col.
9-16 di 9-16; Linea 277 di 330; Parola 1806 di 2058; Caratt. 10580 di 12206 ~
<p>
Gli ultimi due numeri sono la posizione in byte nel file e il numero totale di byte.
Viene tenuto conto di come 'fileformat' modifica il numero di byte usati dalle interruzioni di linea.
Per spostarvi ad un byte specifico del file, usate il comando "go".
Ad esempio, per spostarvi al byte 2345: >
<p>
2345go
<p>

<p>
USARE XXD
<p>
Un vero editor binario mostra il testo in due modi: così come è ed in formato hex.
Potete farlo in Vim convertendo prima il file con il programma "xxd", fornito con Vim.
Per prima cosa, aprite il file in modalità binaria: >
<p>
vim -b datafile
<p>
Ora convertite il file in un hex dump usando xxd: >
<p>
:%!xxd
<p>
Il testo apparirà così:
<p>
0000000: 1f8b 0808 39d7 173b 0203 7474 002b 4e49 ....9..;..tt.+NI ~ 	0000010: 4b2c 8660 eb9c ecac c462 eb94 345e 2e30 K,.`.....b..4^.0 ~ 	0000020: 373b 2731 0b22 0ca6 c1a2 d669 1035 39d9 7;'1.".....i.59.
~
<p>
Ora potete vedere ed modificare il testo a vostro piacimento.
Vim tratta l'informazione come testo ordinario.
Modificare il codice hex non modifica automaticamente il carattere stampabile, o quant'altro.
Alla fine convertitelo di nuovo con: >
<p>
:%!xxd -r
<p>
Solo le modifiche alla parte hex vengono usate.
Le modifiche alla parte del testo stampabile sulla destra vengono ignorate.

<p>
Per maggiori informazioni, consultare la pagina di manuale di xxd.

<p>
============================================================================== *23.5*	File compressi
<p>
Questo è facile: potete elaborare un file compresso come qualsiasi altro file.
Il plugin "gzip" si occupa di decomprimere il file quando lo aprite.
E di comprimerlo quando lo scrivete.
Attualmente sono supportati questi metodi di compressione:
<p>
.Z	compress 	.gz	gzip 	.bz2	bzip2
<p>
Per comprimere e decomprimere, Vim usa i programmi menzionati sopra.
Potrebbe essere necessario installarli prima.

<p>
==============================================================================
<p>
Capitolo seguente: |usr_24.txt| Inserzione rapida
<p>
Copyright: vedere |manual-copyright| vim:tw=78:ts=8:ft=help:norl:
<p>
Per segnalazioni scrivere a vimdoc.it at gmail dot com oppure ad Antonio Colombo azc100 at gmail dot com *usr_24.txt*	Per Vim version 7.2.
Ultima modifica: 2006 Lug 23
<p>
VIM USER MANUAL - di Bram Moolenaar 	 Traduzione di questo capitolo: Giuliano Bordonaro
<p>
Inserzione rapida
<p>

<p>
Quando immettete del testo, Vim vi offre molti modi per ridurre il numero di caratteri immessi ed evitare errori di digitazione.
Utilizzate il completamento in Insert mode per ripetere parole digitate in precedenza.
Accorciate le parole lunghe in parole brevi.
Scrivete caratteri che non sono presenti sulla tastiera.

<p>
|24.1|	Effettuare correzioni |24.2|	Evidenziare le corrispondenze |24.3|	Completamento |24.4|	Ripetizione ed inserimento |24.5|	Copiare da un'altra linea |24.6|	Inserire un registro |24.7|	Abbreviazioni |24.8|	Scrittura di caratteri speciali |24.9|	I digrammi |24.10|	Comandi in Normal mode
<p>
Capitolo seguente: |usr_25.txt| Lavorare con testo formattato Capitolo precedente: |usr_23.txt| Modifica di altri file 	 Indice: |usr_toc.txt|
<p>
============================================================================== *24.1*	Effettuare correzioni
<p>
Del tasto <BS> abbiamo già parlato.
Cancella i caratteri immediatamente precedenti il cursore.
Il tasto <Del> fa la stessa cosa per i caratteri posti sotto (dopo) il cursore.
Avendo scritto qualche parola sbagliata potete usare CTRL-W:
<p>
The horse had fallen to the sky ~ 				 CTRL-W 	The horse had fallen to the ~
<p>
Se aveste sbagliato un'intera linea e voleste ripartire da capo, potreste usare CTRL-U per cancellarla.
Ciò conserverebbe il testo posto dopo il cursore e il rientro.
Solo il testo dal suo inizio alla posizione del cursore verrebbe cancellato.
Con il cursore sulla "f" di "fallen" nella linea che segue premendo CTRL-U avverrebbe quanto segue:
<p>
The horse had fallen to the ~ 		 CTRL-U 	fallen to the ~
<p>
Se trovaste un errore poche parole indietro bisognerebbe spostarvi il cursore per correggerlo.
Ad esempio, avendo scritto così:
<p>
The horse had follen to the ground ~
<p>
Volendo cambiare "follen" in "fallen".
Con il cursore a fine linea potreste scrivere così per correggerlo: >
<p>
<Esc>4blraA
<p>
<	Uscire dall'Insert mode		<Esc> 	indietro di quattro parole	 4b 	vai sulla "o"			 l 	sostituiscila con una "a"		ra 	riavvia l'Insert mode			 A
<p>
Un altro modo di farlo: >
<p>
<C-Left><C-Left><C-Left><C-Left><Right><Del>a<End>
<p>
<	indietro di quattro parole	 <C-Left><C-Left><C-Left><C-Left> 	vai sopra la "o"			<Right> 	cancella la "o"				 <Del> 	inserisci una "a"				 a 	vai a fine linea				 <End>
<p>
Questo impiega i tasti speciali per muoversi attorno, restando nell'Insert mode.
Ciò assomiglia a quanto fareste con un editor non modale.
E' più facile da ricordare, ma richiede più tempo (dovreste spostarvi tra lettere e tasti cursore ed il tasto <End> risulta difficile da premere senza guardare la tastiera).
Questi tasti speciali sono molto utili per scrivere senza lasciare l'Insert mode.
Allora il fatto di dover scrivere di più non costituisce un problema.
Una vista d'assieme dei tasti che potete usare nell'Insert mode:
<p>
<C-Home>	va all'inizio del file 	<PageUp>	si sposta di uno schermo verso l'alto 	<Home>		va all'inizio della linea 	<S-Left>	si sposta di una parola a sinistra 	<C-Left>	si sposta di una parola a sinistra 	<S-Right>	si sposta di una parola a destra 	<C-Right>	si sposta di una parola a destra 	<End>		va alla fine della linea 	<PageDown>	si sposta di uno schermo verso il basso 	<C-End>		va alla fine del file
<p>
Ce ne sono alcuni in più, vedere |ins-special-special|.

<p>
============================================================================== *24.2*	Evidenziare le corrispondenze
<p>
Quando scrivete un ) potrebbe esservi utile vedere a quale ( corrisponda.
Per ottenere che Vim faccia ciò potete usare questo comando: >
<p>
:set showmatch
<p>
Quando scrivete un testo come "(example)", appena scritto ) Vim sposterà per un attimo il cursore sulla corrispondente (, rimarrà lì per mezzo secondo, poi tornerà indietro dove stavate scrivendo.
Se non ci fosse la corrispondente (, Vim emetterebbe un suono.
Così sapreste di aver dimenticato la ( da qualche parte, o scritto una ) di troppo.
La corrispondenza viene cercata anche per le coppie [] e {}.
Non dovete aspettare per scrivere la prossima lettera, appena Vim trova la corrispondenza il cursore tornerà indietro e l'inserzione continuerà come prima.
Potete modificare questo tempo di verifica con l'opzione 'matchtime'.
Ad esempio, per far sì che Vim attenda per un secondo e mezzo: >
<p>
:set matchtime=15
<p>
Il tempo va specificato in decimi di secondo.

<p>
============================================================================== *24.3*	Completamento
<p>
Vim può completare automaticamente le parole durante l'inserzione.
Scrivete la prima parte di una parola, premete CTRL-P, e Vim provvederà al resto.
Immaginate, ad esempio, di stare scrivendo un programma in C e di voler scrivere:
<p>
total = ch_array[0] + ch_array[1] + ch_array[2]; ~
<p>
Inizierete scrivendo quanto segue:
<p>
total = ch_array[0] + ch_ ~
<p>
Ora dite a Vim di completare la parola usando il comando CTRL-P.
Vim cercherà una parola che inizi con ciò che sta davanti al cursore.
In questo caso, si tratta di "ch_", che corrisponde con la parola ch_array.
Così se digitate CTRL-P otterrete:
<p>
total = ch_array[0] + ch_array ~
<p>
Dopo un minimo sforzo di digitazione otterrete (terminando con uno spazio):
<p>
total = ch_array[0] + ch_array[1] + ~
<p>
Se adesso digitate CTRL-P Vim cercherà ancora una parola che completi quella prima del cursore.
Poiché non c'è nulla davanti al cursore, verrà trovata la prima parola cercando all'indietro, che è "ch_array".
Digitando ancora CTRL-P si troverà la prossima parola corrispondente, in questo caso "total".
Un terzo CTRL-P cercherà ancora all'indietro.
Se non vi fosse altro, l'editor, avendo terminato le parole, tornerebbe al testo originale, che è nullo.
Un quarto CTRL-P farà ripartire l'editor con "ch_array".

<p>
Per cercare in avanti usate CTRL-N.
Quando la ricerca avrà raggiunto la fine del file, CTRL-N e CTRL-P troveranno le stesse corrispondenze, ma in sequenza diversa.
Significato: CTRL-N vuol dire Next-match e CTRL-P significa Previous-match.

<p>
Vim tenterà di tutto per trovare parole da completare.
Di default, cercherà nei seguenti posti:
<p>
1.
File attuale 	2.
File in altre finestre 	3.
Altri file caricati (buffer nascosti) 	4.
File non caricati (buffers inattivi) 	5.
Tag file 	6.
Tutti i file #included dal file corrente
<p>

<p>
OPZIONI
<p>
Potete personalizzare l'ordine di ricerca con l'opzione 'complete'.

<p>
Uso dell'opzione 'ignorecase'.
Quando viene impostata, vengono ignorate le differenze tra maiuscole e minuscole nella ricerca delle corrispondenze.

<p>
Un'opzione speciale per il completamento è 'infercase'.
Risulta utile per trovare corrispondenze ignorando la distinzione tra maiuscole e minuscole ('ignorecase' deve essere impostata) ma utilizzando l'attributo della parola precedentemente digitata.
Così, se scriveste "For", Vim troverebbe la corrispondenza in "fortunately", il risultato sarà "Fortunately".

<p>

<p>
COMPLETAMENTO DI ELEMENTI SPECIFICI
<p>
Se sapete cosa state cercando, potete usare questi comandi per completare a mezzo di un certo tipo di elementi:
<p>
CTRL-X CTRL-F		nomi di file 	CTRL-X CTRL-L		talune linee 	CTRL-X CTRL-D		definizioni di macro (anche in file inclusi) 	CTRL-X CTRL-I		file corrente ed inclusi 	CTRL-X CTRL-K		parole da un dizionario 	CTRL-X CTRL-T		parole da un thesaurus 	CTRL-X CTRL-]		marcature 	CTRL-X CTRL-V		linea di comando di Vim
<p>
Dopo ciascuno di essi CTRL-N può essere usato per trovare la prossima corrispondenza, CTRL-P per quella precedente.
Una maggiore informazione per ciascuno di questi comandi qui: |ins-completion|.

<p>

<p>
COMPLETAMENTO DEI NOMI DEI FILE
<p>
Prendiamo ad esempio CTRL-X CTRL-F.
Serve a trovare nomi di file.
Esamina la directory corrente e mostra ciascun file che corrisponda con la parola davanti al cursore.
Ad esempio, immaginate di avere i seguenti file nella directory corrente:
<p>
main.c sub_count.c sub_done.c sub_exit.c
<p>
Entrate in Insert mode ed iniziate a scrivere:
<p>
The exit code is in the file sub ~
<p>
A questo punto digitate il comando CTRL-X CTRL-F.
Vim completa ora la parola "sub" osservando i file nella directory attuale.
La prima corrispondenza è sub_count.c.
Ciò non è quello che volevate, così provate il prossimo file con CTRL-N.
La corrispondenza è sub_done.c.
Scrivendo ancora una volta CTRL-N vi darà sub_exit.c. Il risultato:
<p>
The exit code is in the file sub_exit.c ~
<p>
Se il nome del file iniziasse con / (Unix) o C:\ (MS-Windows) potreste trovare tutti i file del file system.
Ad esempio, digitate "/u" e CTRL-X CTRL-F.
Ciò troverà corrispondenza in "/usr" (ciò in Unix):
<p>
the file is found in /usr/ ~
<p>
Se adesso premete CTRL-N tornate a "/u".
Invece, per accettare "/usr/" ed andare ad una directory di livello più basso, usate ancora CTRL-X CTRL-F:
<p>
the file is found in /usr/X11R6/ ~
<p>
I risultati dipenderanno da cosa si trova nel vostro file system, ovviamente.
Le corrispondenze vengono ordinate alfabeticamente.

<p>

<p>
COMPLETAMENTO DI CODICE SORGENTE
<p>
I file di codice sorgente sono ben strutturati.
Questo rende possibile effettuare dei completamenti in maniera intelligente.
In Vim questa è stata definita completamento Omni.
In altri programmi di videoscrittura è detta intellisense, ma la parole è un marchio commerciale.

<p>
La chiave al completamento Omni è CTRL-X CTRL-O.
Ovviamente la O sta per Omni qui, per aiutare a ricordarlo.
Vediamo un esempio di modifica ad un sorgente in C:
<p>
{ ~ 	 struct foo *p; ~ 	 p-> ~
<p>
Il cursore è posizionato dopo "p->".
Ora digitate CTRL-X CTRL-O.
Vim vi offrirà una lista di scelte, ossia gli elementi contenuti in "struct foo".
Ciò è piuttosto differente dall'usare CTRL-P, che completerebbe qualsiasi parola, mentre solo elementi di "struct foo" sono validi qui.

<p>
Per far funzionare il completamento Omni può essere necessaria qualche preparazione.
Assicuratevi almeno che i plugin per un tipo_file siano abilitati.
Il vostro file vimrc dovrebbe contenere una linea come questa: > 	filetype plugin on Oppure: > 	filetype plugin indent on
<p>
Per il sorgente C dovrete creare un file di tag ed impostare l'opzione 'tags'.
La spiegazione si trova in |ft-c-omni|.
Per altri tipi di file dovrete procedere analogamente, guardate qui sotto |compl-omni-filetypes|.
Questo funziona solo per tipi di file specifici.
Controllate il valore dell'opzione 'omnifunc' per trovare se l'opzione potrebbe funzionare per il file che state modificando.

<p>
==============================================================================
<p>
*24.4*	Ripetizione di un inserimento
<p>
Se premete CTRL-A, l'editor inserisce il testo scritto l'ultima volta che vi trovavate nell'Insert mode.
Ad esempio, supponete di avere un file che inizi con i seguenti:
<p>
"file.h" ~ 	/* Main program begins */ ~
<p>
Modificate questo file inserendo "#include " all'inizio della prima linea:
<p>
#include "file.h" ~ 	/* Main program begins */ ~
<p>
Scendete all'inizio della linea seguente con il comando "j^".
Inserite una nuova linea "#include".
Così scrivete: >
<p>
i CTRL-A
<p>
Ne deriverà quanto segue:
<p>
#include "file.h" ~ 	#include /* Main program begins */ ~
<p>
E' stato incluso "#include " perché CTRL-A inserisce il testo dell'inserimento precedente.
Ora scrivete "main.h"<Enter> per completare la linea:
<p>
#include "file.h" ~ 	#include "main.h" ~ 	/* Main program begins */ ~
<p>
Il comando CTRL-@ produce un CTRL-A ed esce dall'Insert mode.
E' un modo veloce per fare lo stesso inserimento un'altra volta.

<p>
============================================================================== *24.5*	Copiare da un'altra linea
<p>
Il comando CTRL-Y inserisce il carattere prima del cursore.
Risulta utile dovendo duplicare una linea precedente.
Ad esempio, posta questa linea di codice C:
<p>
b_array[i]->s_next = a_array[i]->s_next; ~
<p>
Adesso dovete scrivere la stessa linea, ma con "s_prev" invece di "s_next".
Andate a capo e premete CTRL-Y 14 volte, sino a quando giungerete alla "n" di "next":
<p>
b_array[i]->s_next = a_array[i]->s_next; ~ 	b_array[i]->s_ ~
<p>
Adesso scrivete "prev":
<p>
b_array[i]->s_next = a_array[i]->s_next; ~ 	b_array[i]->s_prev ~
<p>
Continuate premendo CTRL-Y sino al prossimo "next":
<p>
b_array[i]->s_next = a_array[i]->s_next;~ 	b_array[i]->s_prev = a_array[i]->s_ ~
<p>
Adesso scrivete "prev;" per terminare.

<p>
Il comando CTRL-E fa come CTRL-Y ad eccezione del fatto che inserisce il carattere dopo il cursore.

<p>
============================================================================== *24.6*	Inserire un registro
<p>
Il comando CTRL-R {register} inserisce i contenuti del registro.
Ciò risulta utile per evitare di dover scrivere una parola lunga.
Ad esempio, se volete scrivere:
<p>
r = VeryLongFunction(a) + VeryLongFunction(b) + VeryLongFunction(c) ~
<p>
Il nome della funzione è definito entro un file diverso.
Aprite questo file e muovete il cursore all'inizio del nome della funzione, copiatelo ora nel registro v: >
<p>
"vyiw
<p>
"v è la specificazione del registro, "yiw" sta per yank-inner-word.
Ora aprite il file in cui volete inserire la nuova linea e premete le prime lettere:
<p>
r = ~
<p>
Adesso, con CTRL-R v verrà inserito il nome della funzione:
<p>
r = VeryLongFunction ~
<p>
Continuate a scrivere caratteri entro il nome della funzione ed usate ancora due volte CTRL-R v.
Potreste fare lo stesso per il completamento.
Usare un registro è utile se ci fossero troppo parole inizianti con lo stesso carattere.

<p>
Se il registro contenesse caratteri come <BS> od altri caratteri speciali, essi verrebbero interpretati come se fossero stati digitati dalla tastiera.
Se non volete che ciò accada (volete che venga inserito davvero nel testo il <BS>), usate il comando CTRL-R CTRL-R {register}.

<p>
============================================================================== *24.7*	Abbreviazioni
<p>
Un'abbreviazione è una parola breve che prende il posto di una lunga.
Ad esempio, "ad" sta per "advertisement".
Vim permette di scrivere un'abbreviazione e la espanderà automaticamente.
Per dire a Vim di espandere "ad" in "advertisement" ogni volta che venga inserita, usate il comando seguente: >
<p>
:iabbrev ad advertisement
<p>
Adesso, scrivendo "ad", tutta la parola "advertisement" verrà inserita nel testo.
Lo otterrete scrivendo un carattere che non fa parte della parola, ad esempio uno spazio:
<p>
What Is Entered		What You See 	I saw the a		I saw the a ~ 	I saw the ad		I saw the ad ~ 	I saw the ad<Space>	I saw the advertisement<Space> ~
<p>
L'espansione non avviene scrivendo solo "ad".
Ciò vi permette di scrivere una parola come "add", che non deve essere espansa.
Solo le parole intere vengono prese in esame per le abbreviazioni.

<p>

<p>
ABBREVIARE DIVERSE PAROLE
<p>
E' possibile definire un'abbreviazione che si sviluppi in diverse parole.
Ad esempio, per definire "JB" come "Jack Benny", usate il seguente comando: >
<p>
:iabbrev JB Jack Benny
<p>
Come programmatore, uso due abbreviazioni abbastanza insolite: >
<p>
:iabbrev #b /**************************************** 	:iabbrev #e <Space>****************************************/
<p>
Servono per generare commenti incorniciati.
Il commento parte con #b, che disegna la linea sopra.
Poi si scrive il testo del commento e si usa #e per disegnare la linea sotto.
Attenzione al fatto che l'abbreviazione #e inizia con uno spazio.
In altre parole, i primi due caratteri sono spazio-asterisco.
Di solito Vim ignora gli spazi tra l'abbreviazione e l'espansione.
Per evitare questo problema, sillabo "space" come sette caratteri: <, S, p, a, c, e, >.

<p>
Note: 	":iabbrev" è una parola lunga da scrivere.
":iab" va meglio.
Ciò significa abbreviare il comando abbreviate!
<p>

<p>
CORREZIONE DEGLI ERRORI DI SCRITTURA
<p>
E' comunissimo ripetere spesso lo stesso errore di digitazione.
Ad es., scrivere "teh" invece di "the".
Potete rimediare con un'abbreviazione: >
<p>
:abbreviate teh the
<p>
Potete aggiungerne un'intera lista.
Aggiungetene una ogni volta che scoprite un errore comune.

<p>

<p>
ELENCARE LE ABBREVIAZIONI
<p>
Il comando ":abbreviate" elenca le abbreviazioni:
<p>
:abbreviate 	i #e		 ****************************************/ 	i #b		 /**************************************** 	i JB		 Jack Benny 	i ad		 advertisement 	! teh		 the
<p>
La lettera "i" nella prima colonna indica l'Insert mode.
Queste abbreviazioni sono attive soltanto nell'Insert mode.
Altri possibili caratteri sono:
<p>
c	Command-line mode			:cabbrev 	!	Entrambi, Insert e Command-line mode	:abbreviate
<p>
Poiché le abbreviazioni non sono utili spesso nel Command-line mode, userete preferibilmente il comando ":iabbrev".
Ciò eviterà, ad esempio, che "ad" venga espanso quando state scrivendo un comando come: >
<p>
:edit ad
<p>

<p>
CANCELLARE LE ABBREVIAZIONI
<p>
Per eliminare un'abbreviazione usate il comando ":unabbreviate".
Supponete di avere la seguente abbreviazione: >
<p>
:abbreviate @f fresh
<p>
La potete rimuovere con il seguente comando: >
<p>
:unabbreviate @f
<p>
Sino a quando non farete ciò @f verrà espanso in "fresh".
Non preoccupatevene, Vim lo capisce comunque (eccetto se aveste un'abbreviazione per "fresh", ma essa fosse molto differente).
Per eliminare tutte le abbreviazioni: >
<p>
:abclear
<p>
":unabbreviate" ed ":abclear" sono delle varianti per l'Insert mode ("iunabbeviate ed ":iabclear") e per il Command-line mode (":cunabbreviate" e "cabclear").

<p>

<p>
RIMAPPATURA DELLE ABBREVIAZIONI
<p>
C'è una cosa da tenere in considerazione quando definite un'abbreviazione: La stringa risultante non può essere mappata.
Ad esempio: >
<p>
:abbreviate @a adder 	:imap dd disk-door
<p>
Se adesso scriveste @a, otterreste "adisk-doorer".
Non è quanto volevate.
Per evitarlo, impiegate il comando ":noreabbrev".
Fa come ":abbreviate", ma evita che la stringa risultante venga usata per la mappatura: >
<p>
:noreabbrev @a adder
<p>
Fortunatamente è raro che il risultato di un'abbreviazione venga mappato.

<p>
============================================================================== *24.8*	Inserimento di caratteri speciali
<p>
Il comando CTRL-V serve ad inserire letteralmente il prossimo carattere.
In altre parole, qualsiasi significato speciale il carattere abbia verrà ignorato.
Ad esempio: >
<p>
CTRL-V <Esc>
<p>
Inserisce un carattere di escape.
Così non dovrete lasciare l'Insert mode.
(Non dovete mettere lo spazio dopo CTRL-V, è solo per renderlo più leggibile).
<p>
Note: 	In MS-Windows CTRL-V viene usato per incollare del testo.
Usate 	CTRL-Q invece di CTRL-V.
Su Unix, d'altronde, CTRL-Q non funziona su 	alcuni terminali perché ha un significato speciale.

<p>
Potete anche usare il comando CTRL-V {numeri} per inserire un carattere contenente numeri decimali {numeri}.
Ad esempio, il carattere numero 127 è il carattere <Del> (ma non necessariamente il tasto <Del>!).
Per inserire <Del> scrivete: >
<p>
CTRL-V 127
<p>
In questo modo potete inserire caratteri in numero superiore a 255.
Quando scrivete meno di due cifre, un carattere non cifra dovrà ultimare il comando.
Per evitare di scrivere il carattere non cifra anteponete uno o due zeri per fare tre cifre.
Tutti i seguenti comandi inseriscono un <Tab> seguito da un punto:
<p>
CTRL-V 9.
CTRL-V 09.
CTRL-V 009.

<p>
Per inserire un carattere in esadecimale, usate una "x" dopo il CTRL-V: >
<p>
CTRL-V x7f
<p>
Ciò va anche oltre i 255 caratteri (CTRL-V xff).
Potete usare "o" per scrivere un carattere come numero ottale ed altri due metodi vi consentiranno di scrivere numeri a 16 o 32 bit (e.g., per un carattere Unicode): >
<p>
CTRL-V o123 	CTRL-V u1234 	CTRL-V U12345678
<p>
============================================================================== *24.9*	Digrammi
<p>
Taluni caratteri non esistono sulla tastiera.
Ad esempio, il carattere di copyright (©).
Per scrivere questi caratteri con Vim, utilizzerete dei digrammi, ove due caratteri ne rappresentano uno.
Per inserire un ©, ad esempio, premerete tre tasti: >
<p>
CTRL-K Co
<p>
Per sapere quali digrammi siano disponibili usate il seguente comando: >
<p>
:digraphs
<p>
Vim farà vedere la tabella dei digrammi.
Eccone tre linee:
<p>
AC ~_ 159 NS | 160 !I ¡ 161 Ct ¢ 162 Pd £ 163 Cu ¤ 164 Ye ¥ 165 ~ BB ¦ 166 SE § 167 ': ¨ 168 Co © 169 -a ª 170 << « 171 NO ¬ 172 ~ -- ­ 173 Rg ® 174 'm ¯ 175 DG ° 176 +- ± 177 2S ² 178 3S ³ 179 ~
<p>
Ciò mostra, per esempio, che il carattere-digramma che otterrete premendo CTRL-K Pd è il carattere (£).
Si tratta del carattere numero 163 (decimale).
Pd è l'abbreviazione di Pound.
Molti digrammi sono fatti in modo da darvi un suggerimento circa il carattere che produrranno.
Guardando la lista ne capirete la logica.
Si può scambiare il primo col secondo carattere, se non esiste un altro digramma con la stessa combinazione.
Così funzionerà anche CTRL-K dP.
Se non vi fosse un digramma per "dP" Vim cercherà anche un digramma per "Pd".
<p>
Note: 	I caratteri-digramma dipendono dall'assieme di caratteri che Vim pensa 	usiate.
In MS-DOS è diverso che in MS-Windows.
Usate sempre 	":digraphs" per trovare quali caratteri-digramma sono attualmente 	disponibili.

<p>
Potete definire i vostri digrammi.
Esempio: >
<p>
:digraph a" ä
<p>
Definisce che CTRL-K a" inserisca un carattere ä.
Potete anche specificare il carattere con un numero decimale.
Ciò definisce il medesimo digramma: >
<p>
:digraph a" 228
<p>
Troverete ulteriori informazioni circa i caratteri digrammi in: |digraphs| Un altro modo per inserire caratteri speciali è con una keymap.
Di più sull'argomento: |45.5|
<p>
============================================================================== *24.10*	Comandi in Normal mode
<p>
L'Insert mode offre un numero limitato di comandi.
In Normal mode è disponibile assai di più.
Se ne voleste usare uno, normalmente abbandonereste l'Insert mode con <Esc>, eseguireste il comando in Normal mode, e rientrereste in Insert mode con "i" od "a".
C'è una via più rapida.
Con CTRL-O {comando} potete eseguire tutti i comandi Normal mode restando nell'Insert mode.
Ad esempio, per cancellare dalla posizione del cursore alla fine della linea: >
<p>
CTRL-O D
<p>
Potete eseguire un solo comando Normal mode in questo modo.
Ma potete specificare un registro od un conto.
Un esempio più complicato: >
<p>
CTRL-O "g3dw
<p>
Cancella a partire dalla terza parola entro il registro g.

<p>
==============================================================================
<p>
Capitolo seguente: |usr_25.txt| Lavorare con testo formattato
<p>
Copyright: vedere |manual-copyright| vim:tw=78:ts=8:ft=help:norl:
<p>
Per segnalazioni scrivere a vimdoc.it at gmail dot com oppure ad Antonio Colombo azc100 at gmail dot com *usr_25.txt*	Per Vim version 7.2.
Ultima modifica: 2007 Mag 07
<p>
VIM USER MANUAL - di Bram Moolenaar 	 Traduzione di questo capitolo: Cristian Rigamonti
<p>
Elaborare testo formattato
<p>

<p>
Difficilmente un testo è composto da una frase per linea.
Questo capitolo spiega come interrompere le frasi per adattarle alla pagina ed altre formattazioni.
Vim ha anche utili funzioni per elaborare paragrafi di una sola linea e tabelle.

<p>
|25.1|	Interrompere le linee |25.2|	Allineare il testo |25.3|	Rientro e tabulazione |25.4|	Trattare le linee lunghe |25.5|	Elaborare tabelle
<p>
Capitolo seguente: |usr_26.txt| Ripetizione Capitolo precedente: |usr_24.txt| Inserzione rapida 	 Indice: |usr_toc.txt|
<p>
============================================================================== *25.1*	Interrompere le linee
<p>
Vim ha una serie di funzioni che facilitano il trattamento del testo.
Di default, l'editor non interrompe le linee automaticamente.
In altre parole, dovete premere <Enter> voi stessi.
Ciò è utile se state scrivendo programmi e volete essere voi a decidere dove finisce ogni linea.
Non va altrettanto bene se state scrivendo della documentazione e volete che il testo occupi al massimo 70 caratteri per linea.
Impostando l'opzione 'textwidth', Vim inserisce automaticamente le interruzioni di linea.
Supponete, ad esempio, di volere una colonna molto stretta di soli 30 caratteri.
Dovete eseguire il comando seguente: >
<p>
:set textwidth=30
<p>
Ora iniziate a scrivere (il righello è stato aggiunto qui per chiarezza)
<p>
1	 2	 3 	12345678901234567890123456789012345 	Ho insegnato programmazione pe ~
<p>
Se ora scrivete la "r", la linea supererà il limite di 30 caratteri.
Quando Vim se ne accorge, inserisce un'interruzione di linea e ottenete il seguente:
<p>
1	 2	 3 	12345678901234567890123456789012345 	Ho insegnato programmazione ~ 	per un po' ~
<p>
Continuando, potete scrivere il resto del paragrafo:
<p>
1	 2	 3 	12345678901234567890123456789012345 	Ho insegnato programmazione ~ 	per un po'.
Una volta sono ~ 	stato fermato dalla polizia ~ 	perché davo dei compiti troppo ~ 	difficili.
Storia vera. ~
<p>
Non dovete digitare il ritorno a capo: Vim lo inserisce automaticamente.

<p>
Note: 	Con l'opzione 'wrap', Vim interrompe le linee solo in fase di 	visualizzazione, non inserisce interruzioni di linea nel file.

<p>

<p>
RIFORMATTARE
<p>
Vim è un editor, non un word processor.
In un word processor, se cancellate qualcosa all'inizio di un paragrafo, le interruzioni di linea vengono rielaborate.
In Vim non avviene, quindi se cancellate la parola "programmazione" dalla prima linea, vi ritrovate con una linea più corta:
<p>
1	 2	 3 	12345678901234567890123456789012345 	Ho insegnato ~ 	per un po'.
Una volta sono ~ 	stato fermato dalla polizia ~ 	perché davo dei compiti troppo ~ 	difficili.
Storia vera. ~
<p>
Non è un bel vedere: per ridare forma al paragrafo, usate l'operatore "gq".
Usiamolo dapprima con una selezione visuale.
Partendo dalla prima linea, scrivete: >
<p>
v4jgq
<p>
"v" per entrare in Visual mode, "4j" per muovervi alla fine del paragrafo e infine l'operatore "gq".
Il risultato è:
<p>
1	 2	 3 	12345678901234567890123456789012345 	Ho insegnato per un po'.
Una ~ 	volta sono stato fermato ~ 	dalla polizia perché davo dei ~ 	compiti troppo difficili.
~ 	Storia vera.
~
<p>
Poiché "gq" è un operatore, potete usare uno dei seguenti tre modi per selezionare il testo su cui operare: con Visual mode, con un movimento e con un oggetto di testo.
Nell'esempio precedente avremmo potuto usare "gq4j".
Che significa scrivere meno, ma bisogna conoscere il numero delle linee.
Un comando di spostamento ancora più utile è "}".
Questo va alla fine del paragrafo.
Così "gq}" formatta il testo dalla posizione del cursore fino alla fine del paragrafo attuale.
Un oggetto di testo molto utile da usare con "gq" è il paragrafo.
Provate: >
<p>
gqap
<p>
"ap" sta per "a paragraph".
Ciò formatta il testo di un solo paragrafo (separato da linee vuote).
Così la parte dopo il cursore.
Se i vostri paragrafi sono separati da linee vuote, potete formattare l'intero file scrivendo: >
<p>
gggqG
<p>
"gg" per spostarvi alla prima linea, "gqG" per formattare fino all'ultima linea.
Attenzione: se i paragrafi non sono opportunamente separati, verranno uniti.
Un errore comune è quello di lasciare una linea con uno spazio o una Tabulazione [Tab].
Quella è una linea "bianca", ma non vuota.
<p>
Vim è in grado di formattare più che il solo testo semplice.
Si veda |fo-table| in proposito.
Si veda anche l'opzione 'joinspaces' per cambiare il numero di spazi usati dopo un punto.
È possibile usare un programma esterno per formattare.
Ciò è utile se il vostro testo non può venire correttamente formattato con in comandi disponibili in Vim.
Si veda l'opzione 'formatprg'.
<p>
============================================================================== *25.2*	Allineare il testo
<p>
Per centrare un intervallo di linee, usate il comando seguente: >
<p>
:{range}center [width]
<p>
{range} è il solito intervallo da linea di comando.
[width], è un'opzionale larghezza di linea da usare per centrare il testo.
Se [width] non viene specificata, assume automaticamente il valore di 'textwidth' (se 'textwidth' fosse 0, il valore predefinito è 80).
Per esempio: >
<p>
:1,5center 40
<p>
il risultato sarà il seguente:
<p>
Ho insegnato per un po'.
Una ~ volta sono stato fermato ~ dalla polizia perché davo dei ~ compiti troppo difficili.
~ Storia vera.
~
<p>
ALLINEAMENTO A DESTRA
<p>
In modo simile il comando ":right" allinea il testo a destra: >
<p>
:1,5right 37
<p>
produrrà:
<p>
Ho insegnato per un po'.
Una ~ 	 volta sono stato fermato ~ 	dalla polizia perché davo dei ~ 	 compiti troppo difficili.
~ 	 Storia vera.
~
<p>
ALLINEAMENTO A SINISTRA
<p>
Infine, c'è il comando: >
<p>
:{range}left [margin]
<p>
A differenza di ":center" e ":right", l'argomento di ":left" non è la lunghezza della linea.
E' invece il margine sinistro.
Se viene omesso, il testo verrà allineato al margine sinistro dello schermo (lo stesso risultato si ottiene indicando un margine zero).
Se vale 5, il testo sarà rientrato di 5 spazi.
Provate ad esempio questi comandi: >
<p>
:1left 5 	:2,5left
<p>
Il risultato è il seguente:
<p>
Ho insegnato per un po'.
~ 	Una volta sono stato fermato ~ 	dalla polizia perché davo dei ~ 	compiti troppo difficili.
~ 	Storia vera.
~
<p>

<p>
GIUSTIFICARE IL TESTO
<p>
Vim non contiene comandi per giustificare il testo.
Però c'è un bel pacchetto macro che fa proprio questo.
Per usare questo pacchetto, eseguite il comando seguente: >
<p>
:runtime macros/justify.vim
<p>
Questo script di Vim definisce un nuovo comando visuale: "_j".
Per giustificare un blocco di testo, evidenziatelo in Visual mode ed eseguite "_j".
Maggiori spiegazioni sono contenute nel file.
Per andare là, fate "gf" su questo nome: $VIMRUNTIME/macros/justify.vim.

<p>
Un'alternativa è filtrare il testo attraverso un programma esterno.
Ad esempio: >
<p>
:%!fmt
<p>
============================================================================== *25.3*	Rientro e tabulazione
<p>
Il rientro può venire usato per disallineare una parte del testo rispetto al resto.
I testi di esempio in questo manuale, ad esempio, sono rientrati di otto spazi od un tab.
Potrete normalmente ottenerlo digitando un tab all'inizio di ciascuna linea.
Prendete questo testo:
<p>
la prima linea ~ 	la seconda linea ~
<p>
E' stato creato scrivendo un tab, del testo, <Enter>, un tab e altro testo.
L'opzione 'autoindent' attiva il rientro automatico: >
<p>
:set autoindent
<p>
Ogni nuova linea assume lo stesso rientro della precedente.
Nell'esempio sopra, il tab dopo <Enter> non sarebbe stato necessario.

<p>

<p>
AUMENTARE IL RIENTRO
<p>
Per aumentare la quantità di rientro di una linea, usate l'operatore ">".
Spesso questo viene usato come ">>", che aggiunge rientro alla linea corrente.

<p>
Il valore del rientro aggiunto è specificato con l'opzione 'shiftwidth', il cui valore predefinito è 8.
Per far sì che ">>" inserisca un'ampiezza di rientro pari a quattro spazi, ad esempio, scrivete questo: >
<p>
:set shiftwidth=4
<p>
Se provate a usarlo sulla seconda linea del testo di esempio, ottenete:
<p>
la prima linea ~ 	 la seconda linea ~
<p>
"4>>", invece, aumenterà il rientro delle quattro linee successive.

<p>

<p>
LUNGHEZZA DELLA TABULAZIONE
<p>
Se volete ottenere rientri multiple di 4, basta impostare 'shiftwidth' a 4; tuttavia, premendo <Tab> ottenete ancora un rientro di 8 caratteri.
Per modificare questo comportamento, impostate l'opzione 'softtabstop': >
<p>
:set softtabstop=4
<p>
Ciò farà sì che il tasto <Tab> inserisca un rientro larga 4 caratteri.
Se ci fossero già quattro spazi, verrà usato un carattere <Tab>, (risparmiando così 7 caratteri nel file).
(Se invece volete sempre spazi e non caratteri tab, impostate l'opzione 'expandtab').

<p>
Note: 	Potreste impostare l'opzione 'tabstop' a 4.
Tuttavia, se aprite il 	file un'altra volta, con 'tabstop' impostato al valore predefinito di 	8, il file sarà visualizzato in modo scorretto.
In altri programmi, e 	nella stampa, il rientro risulterà sbagliato.
Per questo motivo è 	raccomandabile tenere 'tabstop' sempre ad 8.
Questo è il valore 	standard ovunque.

<p>

<p>
MODIFICARE LA TABULAZIONE
<p>
Se elaborate un file che è stato scritto con una tabulazione 3, in Vim apparirà terribile, visto che Vim usa il valore standard di 8 per la tabulazione.
Potreste risolvere impostando 'tabstop' a 3, ma dovreste farlo ogni volta che lavorate su questo file.
Vim può cambiare l'uso delle tabulazioni nel vostro file.
Per prima cosa impostate 'tabstop' in modo che il rientro risulti corretto, quindi usate il comando ":retab": >
<p>
:set tabstop=3 	:retab 8
<p>
Il comando ":retab" imposterà 'tabstop' a 8, modificando al contempo il testo in modo che il suo aspetto rimanga inalterato: le sequenze di spazi bianchi saranno trasformate opportunamente in sequenze di tab e spazi per questo.
Potete ora salvare il file.
La prossima volta che lo aprirete, il rientro risulterà corretto senza dover impostare alcuna opzione.
Attenzione: usando ":retab" su un programma, potreste modificare gli spazi in una costante di stringa.
Per questo è buona norma usare "\t" invece del vero tab.

<p>
============================================================================== *25.4*	Trattare le linee lunghe
<p>
Qualche volta aprirete un file più largo del numero di colonne della finestra.
Quando ciò avviene, Vim spezza le linee cosicché tutto stia sullo schermo.
Se disattivate l'opzione 'wrap', ogni linea del file verrà mostrata su una linea dello schermo.
Allora la fine delle linee lunghe scomparirà sulla destra dello schermo.
Quando spostate il cursore su un carattere che non può essere visto, Vim farà scorrere il testo fino a mostrarlo.
Ciò è come spostare una finestra sul testo in senso orizzontale.
Di default Vim non mostra una barra di scorrimento nella GUI.
Se volete abilitarne una, usate il comando seguente: >
<p>
:set guioptions+=b
<p>
Una barra di scorrimento orizzontale apparirà in basso nella finestra di Vim.

<p>
Se non avete, o non volete usare, una barra di scorrimento, usate i seguenti comandi per far scorrere il testo.
Il cursore resterà nello stesso posto, ma verrà spostato sul testo visibile se necessario.

<p>
zh		scorre (il testo) a destra 	4zh		scorre a destra di quattro caratteri 	zH		scorre a destra di metà finestra 	ze		scorre a destra finché il cursore è a fine riga 	zl		scorre (il testo) a sinistra 	4zl		scorre a sinistra di quattro caratteri 	zL		scorre a sinistra di metà finestra 	zs		scorre a sinistra finché il cursore è a fine riga
<p>
Proviamo a mostrarlo con una linea di testo.
Il cursore è sulla "e" di "del".
La "finestra attuale" sopra la linea indica la parte di testo attualmente visibile.
Le "finestre" sotto il testo indicano la parte di testo visibile dopo avere eseguito il comando scritto sulla sinistra.

<p>
|<--finestra attuale-->| 		 un testo lungo, parte del quale è visibile nella finestra ~ 	ze	 |<--	 finestra -->| 	zH	 |<-- finestra -->| 	4zh		 |<--	 finestra -->| 	zh		 |<-- finestra -->| 	zl		 |<-- finestra -->| 	4zl			 |<--	 finestra -->| 	zL				|<--	finestra -->| 	zs			 |<-- finestra -->|
<p>

<p>
SPOSTARSI CON L'INTERRUZIONE DI LINEA DISATTIVATA
<p>
Quando 'wrap' è disattivata ed il testo è stato fatto scorrere orizzontalmente, potete usare i seguenti comandi per spostare il cursore su uno dei caratteri visibili, ignorando il testo al di fuori della finestra, a destra e a sinistra.
Questi comandi non fanno mai scorrere il testo:
<p>
g0		al primo carattere visibile della linea 	g^		al primo carattere "non bianco" visibile della linea 	gm		a metà della linea 	g$		all'ultimo carattere visibile della linea
<p>
|<--	finestra -->| 	un testo lungo, parte del quale è visibile ~ 		 g0 g^ gm	 g$
<p>

<p>
INTERROMPERE LE LINEE SENZA SPEZZARE LE PAROLE		*edit-no-break*
<p>
Quando preparate un testo che dovrà essere usato da un altro programma, potreste dover fare dei paragrafi senza linea di interruzione.
Uno svantaggio di usare 'nowrap' è che non potreste vedere l'intera frase su cui state lavorando; d'altra parte, quando 'wrap' è attivo, le parole vengono spezzate a metà, rendendone difficile la lettura.
Una buona soluzione per elaborare questo tipo di paragrafi consiste nell'impostare l'opzione 'linebreak'.
Vim allora interromperà le linee nel punto giusto mostrando la linea.
Il testo nel file rimarrà inalterato.
Senza 'linebreak' un testo potrebbe apparire così:
<p>
+---------------------------------+ 	|programma per creare automaticame| 	|nte delle lettere.
Volevano spedi| 	|re una lettera personalizzata ai | 	|loro 1000 clienti più ricchi.
Sfo| 	|rtunatamente per il programmatore| 	+---------------------------------+ Dopo: >
<p>
:set linebreak
<p>
apparirebbe così:
<p>
+---------------------------------+ 	|programma per creare | 	|automaticamente delle lettere.
| 	|Volevano spedire una lettera | 	|personalizzata ai loro 1000 | 	|clienti più ricchi.
| 	+---------------------------------+
<p>
Opzioni collegate: 'breakat' specifica i caratteri ove un'interruzione può venire inserita.
'showbreak' specifica una stringa da mostrare all'inizio di una linea interrotta.
Impostate 'textwidth' a zero per evitare che i paragrafi vengano interrotti.

<p>

<p>
SPOSTARSI SULLE LINEE VISIBILI
<p>
I comandi "j" e "k" spostano il cursore alla prossima od alla precedente linea del file.
Quando usati su una linea lunga ciò significa spostare molte linee dello schermo alla volta.
Per spostare solo una linea dello schermo, usate i comandi "gj" e "gk".
Quando una linea non viene interrotta essi fanno come "j" e "k".
Quando la linea viene interrotta, spostano il carattere indicato una linea sopra o sotto.
Potrebbe piacervi usare le seguenti mappature, che assegnano questi comandi di movimento ai tasti cursore: >
<p>
:map <Up> gk 	:map <Down> gj
<p>

<p>
TRASFORMARE UN PARAGRAFO IN UNA LINEA
<p>
Se volete importare del testo in un programma come MS-Word, ogni paragrafo deve essere formato da una sola linea.
Se i vostri paragrafi sono attualmente separati da linee vuote, ecco come trasformare ogni paragrafo in una linea singola: >
<p>
:g/./,/^$/join
<p>
Sembra complicato.
Dividiamolo in parti:
<p>
:g/./		Un comando ":global" che trova tutte le linee che 			contengono almeno un carattere.
,/^$/	Un intervallo che inizia dalla linea attuale (la linea 	 		non vuota) e termina con una linea vuota.
join	Il comando ":join" unisce l'intervallo di linee 			formandone una sola.

<p>
Partendo da questo testo, che contiene otto linee interrotte alla colonna 30:
<p>
+----------------------------------+ 	|Un programma per creare 	 | 	|automaticamente delle lettere.
| 	|Volevano spedire una lettera | 	|personalizzata.		 | 	|				 | 	|Ai loro 1000 clienti più | 	|ricchi.
Sfortunatamente per il | 	|programmatore, 		 | 	+----------------------------------+
<p>
Otterreste queste due linee:
<p>
+----------------------------------+ 	|Un programma per creare automatica| 	|mente delle lettere.
Volevano sped| 	|ire una lettera personalizzata.
| 	|Ai loro 1000 clienti più ricchi.
S| 	|fortunatamente per il programmator| 	+----------------------------------+
<p>
Nota: il tutto non funziona se la linea che separa i paragrafi è "bianca" ma non vuota, ossia se contiene spazi e/o tab.
Questo comando funziona con le linee "bianche": >
<p>
:g/\S/,/^\s*$/join
<p>
Ciò richiede almeno una linea "bianca" o vuota alla fine del file perché venga unito anche l'ultimo paragrafo.

<p>
============================================================================== *25.5*	Elaborare tabelle
<p>
Supponete di lavorare su una tabella con quattro colonne:
<p>
tabella 	 test 1 test 2 test 3 ~ 	input A		 0.534 ~ 	input B		 0.913 ~
<p>
Dovete inserire dei numeri nella terza colonna.
Potreste spostarvi sulla seconda linea, usare "A", inserire un sacco di spazi e scrivere il testo.
Per questo tipo di elaborazione esiste un'opzione speciale: >
<p>
:set virtualedit=all
<p>
Ora potete muovere il cursore in posizioni dove non vi sia alcun testo.
Questo si chiama "spazio virtuale".
Elaborare tabelle risulta molto più facile in questo modo.
Muovete il cursore ricercando l'intestazione dell'ultima colonna: >
<p>
/test 3
<p>
Ora premete "j" e vi ritrovate esattamente dove dovete inserire il valore per "input A".
Scrivendo "0.693" ottenete:
<p>
tabella 	 test 1 test 2	test 3 ~ 	input A		 0.534			0.693 ~ 	input B		 0.913 ~
<p>
Vim ha riempito automaticamente lo spazio che precede il nuovo testo.
Ora, per riempire il campo successivo in questa colonna usate "Bj".
"B" vi sposta all'indietro, all'inizio di una parola separata da spazio bianco.
Poi "j" vi sposta nella posizione dove può essere inserito il valore per il prossimo campo.

<p>
Note: 	Potete spostare il cursore ovunque sullo schermo, anche oltre la fine 	di una linea, ma Vim non inserirà spazi là, finché non inserirete un 	carattere in quella posizione.

<p>

<p>
COPIARE UNA COLONNA
<p>
Volete aggiungere una colonna, che deve essere la copia della terza colonna e posta prima della colonna "test 1".
Potete farlo in sette passi: 1.
Spostate il cursore sull'angolo superiore sinistro di questa colonna, ad es.
con "/test 3".
2.
Premete CTRL-V per entrare in Visual mode a blocchi.
3.
Spostate il cursore di due linee verso il basso con "2j".
Siete ora in "spazio virtuale": la linea "input B" della colonna "test 3".
4.
Spostate il cursore a destra, per includere l'intera colonna nella selezione, più lo spazio che volete tra le colonne.
"9l" dovrebbe farlo. 5. Copiate il rettangolo selezionato con "y". 6. Spostate il cursore su "test 1", dove va inserita la nuova colonna. 7. Premete "P".
<p>
Il risultato dovrebbe essere:
<p>
tabella 	 test 3 test 1 test 2 test 3 ~ 	input A		 0.693 0.534		 0.693 ~ 	input B			 0.913 ~
<p>
Notate che l'intera colonna "test 1" è stata spostata a destra, compresa la linea in cui la colonna "test 3" non contiene testo.

<p>
Tornate ai movimenti del cursore non virtuali con: >
<p>
:set virtualedit=
<p>

<p>
MODALITÀ DI SOSTITUZIONE VIRTUALE
<p>
Lo svantaggio di usare 'virtualedit' è che viene avvertito diverso.
Non potete riconoscere tab o spazi oltre la fine delle linee quando spostate il cursore.
Può essere usato un altro metodo: il Virtual Replace mode.
Supponete di avere una linea in una tabella che contenga sia tab che altri caratteri.
Usate "rx" sul primo tab:
<p>
inp	0.693 0.534	0.693 ~
<p>
| 	 rx | 	 V
<p>
inpx0.693 0.534	0.693 ~
<p>
L'allineamento viene perduto.
Per evitare ciò, usate il comando "gr":
<p>
inp	0.693 0.534	0.693 ~
<p>
| 	 grx | 	 V
<p>
inpx	0.693 0.534	0.693 ~
<p>
Ciò che avviene è che il comando "gr" si assicura che il nuovo carattere prenda la giusta quantità di spazio dello schermo.
Vengono inseriti spazi o tab in più per riempire lo spazio vuoto.
Così, ciò che accade ora è che un tab viene sostituito da "x" e che vengono inseriti spazi bianchi per fare sì che il testo dopo di esso mantenga la sua posizione.
In questo caso viene inserito un tab.
Se dovete sostituire più di un carattere e usate il comando "R" per entrare in modalità Sostituzione (si veda |04.9|), rovinerete l'allineamento e sostituirete i caratteri sbagliati:
<p>
inp	0	0.534	0.693 ~
<p>
| 	 R0.786 | 		V
<p>
inp	0.78634	0.693 ~
<p>
Il comando "gR" invece usa il Virtual Replace mode.
Ciò preserva l'allineamento:
<p>
inp	0	0.534	0.693 ~
<p>
| 	gR0.786 | 		V
<p>
inp	0.786	0.534	0.693 ~
<p>
==============================================================================
<p>
Capitolo seguente: |usr_26.txt| Ripetizione
<p>
Copyright: vedere |manual-copyright| vim:tw=78:ts=8:ft=help:norl:
<p>
Per segnalazioni scrivere a vimdoc.it at gmail dot com oppure ad Antonio Colombo azc100 at gmail dot com *usr_26.txt*	Per Vim version 7.2.
Ultima modifica: 2006 Apr 24
<p>
VIM USER MANUAL - di Bram Moolenaar 		 Traduzione di questo capitolo: Ivan Morgillo
<p>
Ripetizione
<p>

<p>
Un lavoro di editing è sempre crudamente privo di struttura.
Una modifica spesso necessita di venire eseguita molte volte.
In questo capitolo saranno spiegati diversi modi utili per ripetere un cambiamento.

<p>

<p>
|26.1|	Ripetizioni in Visual mode |26.2|	Aggiungere e sottrarre |26.3|	Fare una modifica in più file |26.4|	Usare Vim in uno shell script
<p>
Capitolo seguente: |usr_27.txt| Comandi di ricerca ed espressioni Capitolo precedente: |usr_25.txt| Lavorare con testo formattato 	 Indice: |usr_toc.txt|
<p>
============================================================================== *26.1*	Ripetizioni in Visual mode
<p>
Il Visual mode è molto pratico per effettuare correzioni su qualsiasi numero di righe.
Potete vedere il testo evidenziato, così potete verificare se siano state modificate le linee giuste.
Ma effettuare la selezione richiede la pressione di alcuni tasti.
Il comando "gv" seleziona nuovamente la stessa area di testo.
Questo vi permette di fare un'altra operazione sullo stesso testo.
Supponiamo che abbiate alcune righe in cui vogliate sostituire "2001" con "2002" e "2000" con "2001":
<p>
The financial results for 2001 are better ~ 	than for 2000.
The income increased by 50%, ~ 	even though 2001 had more rain than 2000.
~ 			2000		2001 ~ 	income		45,403		66,234 ~
<p>
Per prima cosa sostituite "2001" con "2002".
Selezionate le righe in Visual mode, e usate: >
<p>
:s/2001/2002/g
<p>
Ora usate "gv" per riselezionare lo stesso testo.
Non importa dove si trovi il cursore.
Usate ":s/2000/2001/g" per effettuare la seconda modifica.
Ovviamente, potete ripetere queste sostituzioni diverse volte.
============================================================================== *26.2*	Aggiungere e sottrarre
<p>
Quando ripetete il cambiamento di un numero in un altro, spesso avete uno scostamento fisso.
Nell'esempio sopra, è stato aggiunto uno ad ogni anno.
Invece di scrivere un comando diverso per ogni anno, si può usare il comando CTRL-A.
Usando lo stesso testo di prima, cercate un anno: > 	/19[0-9][0-9]\|20[0-9][0-9]
<p>
Ora premete CTRL-A.
L'anno sarà incrementato di uno:
<p>

<p>
The financial results for 2002 are better ~ 	than for 2000.
The income increased by 50%, ~ 	even though 2001 had more rain than 2000.
~ 			2000		2001 ~ 	income		45,403		66,234 ~
<p>
Usate "n" per trovare l'anno successivo, e premente "." per ripetere il CTRL-A ("." è un po' più veloce da scrivere).
Ripetete "n" e "." per tutti gli anni che ci sono.
Suggerimento: impostate l'opzione 'hlsearch' per vedere i valori che state per modificare, poi potrete guardare oltre e farlo più velocemente.

<p>
L'aggiunta di numeri maggiori di uno può essere fatta premettendo un numero a CTRL-A.
Supponete di avere la seguente lista:
<p>
1.
item four ~ 2.
item five ~ 	3.
item six ~ 		 Spostate il cursore su "1." e scrivete: > 	3 CTRL-A
<p>
L'"1." cambierà in "4,".
Ancora, potete usare "." per ripetere l'operazione sugli altri numeri.
numeri.
<p>
Altro esempio:
<p>
006	foo bar ~ 	007	foo bar ~
<p>
Usando CTRL-A su questi numeri risulterà:
<p>
007	foo bar ~ 	010	foo bar ~
<p>
7 più uno fa 10? Questo è accaduto perché Vim ha riconosciuto "007" come un numero in rappresentazione ottale, perché il primo numero è uno zero.
Questa notazione è spesso usata nei programmi C.
Se non volete che un numero che inizia per zero sia gestito come un numero ottale, usate questo: >
<p>
:set nrformats-=octal
<p>
Il comando CTRL-X esegue le sottrazioni nello stesso modo.

<p>
============================================================================== *26.3*	Fare una modifica in più file
<p>
Supponiamo che abbiate una variabile di nome "x_cnt" e che vogliate cambiarla in "x_counter".
Questa variabile viene usata in parecchi dei vostri file C.
Dovrete sostituirla in tutti i file.
Ecco come fare. Mettete tutti i file interessati nella lista degli argomenti: >
<p>
:args *.c < Questo comando trova tutti i file C e modifica il primo.
Ora potete eseguire un comando di sostituzione su tutti gli altri file: >
<p>
:argdo %s/\<x_cnt\>/x_counter/ge | update
<p>
Il comando ":argdo" prende come argomento un altro comando.
Questo comando verrà eseguito su tutti i file nella lista degli argomenti.
Il comando substitute "%s" che segue lavora su tutte le righe.
Esso trova la parola "x_cnt" come "\<x_cnt\>".
Le "\<" e "\>" vengono usate per trovare solo la parola esatta e non "px_cnt" o "x_cnt2".
Le flag per il il comando includono "g" per sostituire tutte le "x_cnt" che si presentano nella stessa riga.
La flag "e" è usata per evitare un messaggio di errore nel caso in cui "x_cnt" non appaia affatto nel file.
Diversamente ":argdo" abortirebbe la sua esecuzione se non venisse trovata "x_cnt" nel primo file.
Le "|" separano i due comandi.
Il comando "update" che segue salva il file solo se è cambiato il suo contenuto.
Se nessuna "x_cnt" viene cambiata in "x_counter", non succede niente.

<p>
C'è anche il comando ":windo", che esegue il suo argomento in tutte le finestre.
E ":bufdo" che esegue il suo argomento in tutti i buffer.
Fate attenzione con quest'ultimo perché potreste avere più file di quanti pensiate nella lista dei buffer.
Fate un controllo con il comando ":buffers" (o ":ls").

<p>
============================================================================== *26.4*	Usare Vim da uno shell script
<p>
Supponiamo che abbiate molti file in cui avete bisogno di cambiare la stringa "-person-" con "Jones" e poi stamparla.
Come lo fate? Un modo è scrivere molto.
L'altro modo è scrivere uno shell script che faccia il lavoro.
L'editor Vim fa un lavoro superbo come editor screen-oriented quando si usano i comandi del Normal mode.
Nei processi di batch, tuttavia, i comandi del Normal mode non risultano chiari; così qui userete invece l'Ex mode.
Questa modalità fornisce una gradevole interfaccia a linea di comando che facilita l'immissione dei comandi in un file batch.
("Ex command" è solo un altro nome per un comando (:) da linea di comando).
I comandi Ex mode di cui avete bisogno sono i seguenti: >
<p>
%s/-person-/Jones/g 	write tempfile 	quit
<p>
Inserite questi comandi nel file "change.vim".
Ora per lanciare l'editor in batch mode, usate questo shell script: >
<p>
for file in *.txt; do 	 vim -e -s $file < change.vim 	 lpr -r tempfile 	done
<p>
Il ciclo for-done è un costrutto della shell per ripetere le due righe nel mezzo, sino a che la variabile $file risulta ogni volta impostata con un nome di file diverso.
La seconda riga lancia l'editor Vim in modalità Ex (argomento -e) sul file $file e legge i comandi dal file "change.vim".
L'argomento -s dice a Vim di operare in silent mode.
In altre parole, non visualizza il :prompt, né alcun altro prompt.
Il comando "lpr -r tempfile" stampa il risultante "tempfile" e lo cancella (ciò che fa l'argomento -r).

<p>

<p>
LEGGERE DA STDIN
<p>
Vim può leggere testo dallo standard input.
Dato che normalmente qui vengono letti i comandi, voi dovete dire a Vim di leggere invece del testo.
Ciò è possibile passando l'argomento "-" al posto di un file.
Esempio: > 	 	ls | vim -
<p>
Ciò vi permette di modificare l'output del comando "ls", senza prima salvare il testo in un file.
Se usate lo standard input per leggere del testo, potete usare l'argomento "-S" per leggere uno script: >
<p>
producer | vim -S change.vim -
<p>

<p>
SCRIPT E MODALITA' NORMALE
<p>
Se veramente volete usare i comandi del Normal mode in uno script, potete farlo così: >
<p>
vim -s script file.txt ...
< 	Note: 	"-s" ha un significato diverso quando viene usato senza "-e".
Qui 	significa che utilizza il contenuto di "script" come un insieme di 	comandi del Normal mode.
Quando è usato con "-e" significa che esegue in silenzio e non usa 	l'argomento seguente come nome di un file.

<p>
I comandi nello script vengono eseguiti nel modo in cui li avete scritti.
Non dimenticate che una riga vuota viene interpretata come premere <Enter>.
In Normal mode esso sposta il cursore sulla riga successiva.
Per realizzare lo script potete creare il file script e scrivervi i comandi.
Avete bisogno di immaginare quale possa essere il risultato, il che può essere un po' difficile.
Un altro modo consiste nel registrare i comandi mentre li eseguite manualmente.
Questo è quanto dovete fare: >
<p>
vim -w script file.txt ...

<p>
Tutti i tasti che verranno premuti saranno scritti nello "script".
Se fate un piccolo sbaglio potete pure continuare e ricordarvi di modificare lo script in seguito.
L'argomento "-w" aggiunge tutto ad uno script esistente.
Va bene quando volete registrare lo script un po' alla volta.
Se voleste iniziare dal niente e scrivere tutto dall'inizio, usate l'argomento "-W".
Sovrascriverà ogni file esistente.

<p>
==============================================================================
<p>
Capitolo seguente: |usr_27.txt| Comandi di ricerca ed espressioni
<p>
Copyright: vedere |manual-copyright| vim:tw=78:ts=8:ft=help:norl:
<p>
Per segnalazioni scrivere a vimdoc.it at gmail dot com oppure ad Antonio Colombo azc100 at gmail dot com *usr_27.txt*	Per Vim version 7.2.
Ultima modifica: 2007 Nov 10
<p>
VIM USER MANUAL - di Bram Moolenaar 		Traduzione di questo capitolo: Stefano Palmeri
<p>
Comandi di ricerca ed espressioni
<p>
Nel capitolo 3 sono stati menzionati pochi semplici espressioni di ricerca |03.9|.
Vim può eseguire delle ricerche molto più complesse.
Questo capitolo spiega quelle usate più spesso.
Una dettagliata spiegazione può essere trovata qui: |pattern|
<p>
|27.1|	Ignorare le differenze tra i caratteri maiuscoli e minuscoli |27.2|	Aggirare (nella ricerca) la fine del file |27.3|	Scostamento |27.4|	Effettuare più volte la ricerca |27.5|	Alternative |27.6|	Intervalli di caratteri |27.7|	Classi di caratteri |27.8|	Ricerca di interruzioni di linea |27.9|	Esempi
<p>
Capitolo seguente: |usr_28.txt| La piegatura Capitolo precedente: |usr_26.txt| Ripetizione 	 Indice: |usr_toc.txt|
<p>
============================================================================== *27.1*	Ignorare le differenze tra i caratteri maiuscoli e minuscoli
<p>
Di default, le ricerche di Vim rispettano le differenze tra caratteri maiuscoli e minuscoli.
Quindi, "include", "INCLUDE" e "Include" sono tre parole differenti ed una ricerca ne troverà solo una.
Adesso abilitate l'opzione 'ignorecase': >
<p>
:set ignorecase
<p>
Cercate di nuovo "include" e ora corrisponderà a "Include", "INCLUDE" e "InClUDe".
(Impostate l'opzione 'hlsearch' per vedere velocemente dove una espressione corrisponda.) Potete disabilitarla di nuovo con : >
<p>
:set noignorecase
<p>
Lasciamola però impostata e cerchiamo "INCLUDE".
Troverà esattamente lo stesso testo che "include" aveva trovato .
Adesso impostiamo l'opzione 'smartcase' : >
<p>
:set ignorecase smartcase
<p>
Se avete un'espressione con almeno un carattere maiuscolo, la ricerca rispetterà le differenze tra i caratteri maiuscoli e minuscoli.
L'idea è che voi non eravate obbligati a scrivere quel carattere maiuscolo, quindi dovete averlo fatto perché volevate cercare una maiuscola.
Questo è intelligente! Con queste due opzioni impostate troverete le seguenti corrispondenze:
<p>
espressione		corrispondenze ~ 	word			word, Word, WORD, WoRd, etc.
Word			Word 	WORD			WORD 	WoRd			WoRd
<p>

<p>
CARATTERI MAIUSCOLI E MINUSCOLI IN UNA SOLA ESPRESSIONE
<p>
Se volete ignorare le differenze tra i caratteri maiuscoli e minuscoli per uno specifica espressione, potete farlo anteponendo la stringa "\c".
Usare "\C" fa sì che l'espressione rispetti le differenze.
Tutto ciò sovrascrive le opzioni 'ignorecase' e 'smartcase'; quando "\c" o "\C" vengono usate i loro valori non contano.

<p>
espressione		corrispondenze ~ 	\Cword			word 	\CWord			Word 	\cword			word, Word, WORD, WoRd, etc.
\cWord			word, Word, WORD, WoRd, etc.

<p>
Un grande vantaggio nell'usare "\c" e "\C" è che esse rimangono con l'espressione.
Così se voi ripetete un'espressione dalla cronologia delle ricerche, succederà la stessa cosa, senza che abbia importanza se 'ignorecase' o 'smartcase' siano state cambiate.

<p>
Note: 	L'uso di argomenti "\" nelle espressioni di ricerca dipende 	dall'opzione 'magic'.
In questo capitolo noi assumiamo che 'magic' 	sia attiva, poiché questa è l'impostazione standard e raccomandata.
Se 	voleste cambiare 'magic', molte espressioni di ricerca all'improvviso 	diventerebbero non valide.

<p>
Note: 	Se la vostra ricerca richiede più tempo di quanto vi aspettavate, 	potete interromperla con CTRL-C in Unix e CTRL-Break in MS-DOS e 	MS-Windows.

<p>
============================================================================== *27.2*	Aggirare (nella ricerca) la fine del file
<p>
Di default, una ricerca in avanti inizia a cercare la stringa data dalla posizione corrente del cursore.
Essa poi continua fino alla fine del file.
Se fino ad allora non ha trovato la stringa, comincia da principio e cerca dall'inizio del file fino alla posizione del cursore.
Tenete a mente che ripetendo il comando "n" per cercare la corrispondenza successiva, potreste eventualmente tornare alla prima corrispondenza.
Se non vi accorgete di questo, cercherete all'infinito! Per darvi un consiglio, Vim mostra questo messaggio:
<p>
raggiunto il FONDO nella ricerca, continuo dalla CIMA ~
<p>
Se usate il comando "?", per cercare nell'altra direzione, ricevete questo messaggio:
<p>
raggiunta la CIMA nella ricerca, continuo dal FONDO ~
<p>
Tuttavia, voi non sapete quando siete tornati alla prima corrispondenza.
Un modo per saperlo è quello di attivare l'opzione 'ruler': >
<p>
:set ruler
<p>
Vim mostrerà la posizione del cursore nell'angolo in basso a destra della finestra (nella linea di stato, se ce n'è una).
Appare così:
<p>
101,29 84% ~
<p>
Il primo numero è il numero di linea del cursore.
Ricordate il numero di linea dal quale siete partiti, affinché possiate controllare se avete passato di nuovo questa posizione.

<p>

<p>
NON AGGIRARE LA FINE DEL FILE
<p>
Per disabilitare l'aggiramento della fine del file in una ricerca , usate il seguente comando: >
<p>
:set nowrapscan
<p>
Adesso quando la ricerca raggiunge la fine del file, un messaggio d'errore dice:
<p>
E385: la ricerca ha raggiunto il FONDO senza successo per: %s ~
<p>
Così potete trovare tutte le corrispondenze andando all'inizio del file con "gg" e continuando a cercare fino a che non vedete questo messaggio.
Se cercate nell'altra direzione, usando "?", voi ricevete:
<p>
E384: la ricerca ha raggiunto la CIMA senza successo per: %s ~
<p>
============================================================================== *27.3*	Scostamento
<p>
Di default, il comando di ricerca lascia il cursore posizionato all'inizio dell'espressione.
Potete dire a Vim di lasciarlo in qualche altro posto specificando uno scostamento.
Per il comando di ricerca in avanti "/", lo scostamento è specificato aggiungendo una barra (/) e lo scostamento: >
<p>
/default/2
<p>
Questo comando cerca l'espressione "default" e poi sposta il cursore all'inizio della seconda linea dopo la stessa.
Usando questo comando per il paragrafo sopra, Vim trova la parola "default" nella prima linea.
Poi il cursore è spostato due linee più sotto e si posa su "specificando".

<p>
Se lo scostamento è un semplice numero, il cursore sarà posizionato all'inizio della linea che dista quel numero di linee dalla corrispondenza.
Lo scostamento numerico può essere positivo o negativo.
Se è positivo, il cursore si sposta in basso di quel numero di linee; se è negativo si sposta verso l'alto.

<p>

<p>

<p>
SCOSTAMENTO DEI CARATTERI
<p>
Lo scostamento "e" indica uno scostamento dalla fine della corrispondenza.
Esso sposta il cursore sull'ultimo carattere della corrispondenza.
Il comando: >
<p>
/const/e
<p>
mette il cursore sulla "t" di "const".
Da quella posizione, aggiungendo un numero si sposta in avanti di quel numero di caratteri.
Questo comando muove il cursore sul carattere proprio dopo la corrispondenza: >
<p>
/const/e+1
<p>
Un numero positivo sposta il cursore verso destra, uno negativo lo sposta verso sinistra.
Ad esempio: >
<p>
/const/e-1
<p>
posiziona il cursore sulla "s" di "const".

<p>
Se lo scostamento comincia con "b", il cursore si sposta all'inizio dell'espressione.
Questo non è molto utile, dal momento che lasciar fuori la "b" fa la stessa cosa.
Diventa utile quando si aggiunge o si sottrae un numero.
Il cursore dopo va avanti o indietro di quel numero di caratteri.
Per esempio: >
<p>
/const/b+2
<p>
Posiziona il cursore all'inizio della corrispondenza e poi due caratteri verso destra.
Così si posa sulla "n".
<p>

<p>
RIPETIZIONE
<p>
Per ripetere una ricerca della precedente espressione, ma con un diverso scostamento, omettete l'espressione: >
<p>
/that 	//e
<p>
E' uguale a: >
<p>
/that/e
<p>
Per ripetere con lo stesso scostamento: >
<p>
/
<p>
"n" fa la stessa cosa.
Per ripetere ed al tempo stesso rimuovere un offset usato in precedenza: >
<p>
//
<p>

<p>
CERCARE ALL'INDIETRO
<p>
Il comando "?" usa gli offset nello stesso modo, ma dovete usare "?" per separare l'offset dall'espressione, anziché "/": >
<p>
?const?e-2
<p>
La "b" e la "e" mantengono il loro significato; essi non cambiano direzione se si usa "?".

<p>

<p>
POSIZIONE DI PARTENZA
<p>
Quando si comincia una ricerca, essa normalmente inizia dalla posizione del cursore.
Quando voi specificate uno scostamento di linea, ciò può causare dei problemi.
Ad esempio: >
<p>
/const/-2
<p>
Questo trova la successiva parola "const" e quindi sposta il cursore due linee verso l'alto.
Se usate "n" per cercare di nuovo, Vim potrebbe iniziare dalla posizione corrente e trovare la stessa corrispondenza "const".
Allora, usando di nuovo lo scostamento, potreste tornare da dove eravate partiti.
Dovreste esservi bloccati! Potrebbe essere peggio: supponete che ci sia un'altra corrispondenza con "const" nella linea successiva.
In questo caso ripetendo la ricerca in avanti trovereste questa corrispondenza e spostereste il cursore due linee insù.
Così in realtà spostereste il cursore indietro!
<p>
Quando voi specificate uno scostamento di carattere, Vim terrà conto di ciò.
In questo modo la ricerca inizia pochi caratteri avanti o indietro, cosicché la stessa corrispondenza non verrà trovata di nuovo.

<p>
============================================================================== *27.4* Effettuare più volte la ricerca 		 L'argomento "*" specifica che l'argomento che lo precede può corrispondere un qualsiasi numero di volte.
Così: >
<p>
/a*
<p>
corrisponde ad "a", "aa", "aaa", etc.
Ma anche a "" (la stringa vuota), poiché le zero volte sono incluse.
Il segno "*" influisce solo sull'argomento direttamente prima di esso.
Quindi "ab*" corrisponde ad "a", "ab", "abb", "abbb", etc.
Per far sì che di un'intera stringa si trovino corrispondenze multiple, essa deve essere raggruppata in un unico argomento.
Questo si fa mettendo "\(" prima della stringa e "\)" dopo di essa.
Così questo comando: >
<p>
/\(ab\)*
<p>
corrisponde a: "ab", "abab", "ababab", etc.
Corrisponde anche a "".
<p>
Per evitare di trovare le corrispondenze con le stringhe vuote, usate "\+".
Questo fa sì che l'argomento precedente abbia una o più corrispondenze: >
<p>
/ab\+
<p>
Corrisponde ad "ab", "abb", "abbb", etc.
Non corrisponde ad "a" quando questa non è seguita da una "b".

<p>
Per trovare le corrispondenze con un argomento con diverse opzioni, usate "\=".
Esempio: >
<p>
/folders\=
<p>
corrisponde a "folder" e "folders".

<p>

<p>
CONTEGGI SPECIFICI
<p>
Per trovare uno specifico numero di corrispondenze degli argomenti usate il formato "\{n,m}".
"n" e "m" sono numeri.
L'argomento che lo precede corrisponderà da "n" a "m" volte (incluse |inclusive|). Esempio: >
<p>
/ab\{3,5}
<p>
corrisponde ad "abbb", "abbbb" e "abbbbb".
Quando "n" è omesso, esso assume il valore di zero.
Quando "m" è omesso, esso assume il valore di infinito.
Quando ",m" è omesso, esso troverà corrispondenze esattamente "n" volte.
Esempi:
<p>
espressione	conteggio corrispondenze ~ 	\{,4}		0, 1, 2, 3 o 4 	\{3,}		3, 4, 5, etc.
\{0,1}		0 o 1, lo stesso che \= 	\{0,}		0 o più, lo stesso che * 	\{1,}		1 o più, lo stesso che \+ 	\{3}		3
<p>

<p>
CERCARE IL MENO POSSIBILE
<p>
Fin qui gli argomenti cercano corrispondenze col maggior numero possibile di caratteri che possono trovare.
Per cercare il numero minimo di corrispondenze, usate "\{-n,m}".
Funziona allo stesso modo di "\{n,m}", eccetto per il fatto che ne viene usata la minore quantità possibile.
Per esempio, usate: >
<p>
/ab\{-1,3}
<p>
Troverà "ab" in "abbb".
In realtà, esso non cercherà mai più di una "b", perché non c'è ragione di cercare oltre.
Qualcos'altro è richiesto per forzare la ricerca di corrispondenze oltre il limite più basso.
Le stesse regole si applicano rimuovendo "n" e "m".
E' anche possibile rimuoverle entrambi i numeri, risultando in "\{-}".
Questo trova l'argomento prima di esso zero o più volte, il meno possibile.
L'argomento in sé stesso corrisponde sempre zero volte.
E' utile quando è combinato con qualcos'altro.
Esempio: >
<p>
/a.\{-}b
<p>
Questo trova le corrispondenze "axb" in "axbxb".
Se si usasse questa espressione: >
<p>
/a.*b
<p>
Esso cercherebbe di trovare corrispondenza con il maggior numero possibile di caratteri con ".*", ossia troverebbe "axbxb" interamente.

<p>
============================================================================== *27.5*	Alternative
<p>
L'operatore "or" in una espressione è "\|".
Esempio: >
<p>
/foo\|bar
<p>
Questo trova "foo" o "bar".
Più alternative possono venire concatenate: >
<p>
/one\|two\|three
<p>
Cerca "one", "two" e "three".
Per ricercare più volte, tutto deve essere posto tra "\(" e "\)": >
<p>
/\(foo\|bar\)\+
<p>
Questo trova "foo", "foobar", "foofoo", "barfoobar", etc.
Un altro esempio: >
<p>
/end\(if\|while\|for\)
<p>
Questo trova "endif", "endwhile" e "endfor".

<p>
Un argomento correlato è "\&".
Questo richiede che entrambe le alternative corrispondano nello stesso posto.
La ricerca risultante usa l'ultima alternativa.
Esempio: >
<p>
/forever\&...

<p>
Questo trova "for" in "forever".
Non troverà la corrispondenza in "fortuin", per esempio.

<p>
============================================================================== *27.6*	Intervalli di caratteri
<p>
Per cercare "a", "b" o "c" potete usare "/a\|b\|c".
Quando voleste cercare tutte le corrispondenze di tutte le lettere dalla "a" alla "z", ciò richiederebbe molto tempo.
C'è un metodo più breve: >
<p>
/[a-z]
<p>
Il costrutto [] trova un singolo carattere.
All'interno specificate quali caratteri cercare.
Potete includere una lista di caratteri, come questa: >
<p>
/[0123456789abcdef]
<p>
Questo troverà le corrispondenze di ogni carattere incluso.
Per i caratteri consecutivi potete specificare l'intervallo.
"0-3" è uguale a "0123".
"w-z" sta per "wxyz".
Così lo stesso comando appena visto sopra può essere abbreviato in: >
<p>
/[0-9a-f]
<p>
Per trovare proprio il carattere "-" fate in modo che sia il primo o l'ultimo dell'intervallo.
Questi caratteri speciali sono accettati per rendere più facile usarli dentro un intervallo [] (essi in realtà possono essere usati dovunque nella espressione di ricerca):
<p>
\e	<Esc> 	\t	<Tab> 	\r	<CR> 	\b	<BS>
<p>
Ci sono alcune situazioni speciali riguardo agli intervalli []; vedete |/[]| per l'intera storia.

<p>

<p>
INTERVALLI COMPLEMENTARI
<p>
Per escludere la ricerca di uno specifico carattere, usate "^" all'inizio di un intervallo.
L'argomento di [] quindi cerca tutte le corrispondenze tranne i caratteri inclusi.
Esempio: >
<p>
/"[^"]*" < 	 "	 le virgolette 	 [^"]	 qualsiasi carattere che non siano virgolette 	 *	 il maggior numero possibile 	 " di nuovo le virgolette
<p>
Questo corrisponde a "foo" e "3!x", virgolette incluse.

<p>

<p>
INTERVALLI PREDEFINITI
<p>
Un certo numero di intervalli sono usati molto spesso.
Vim offre una scorciatoia per questi.
Per esempio: >
<p>
/\a
<p>
Cerca caratteri alfabetici.
Questo equivale a usare "/[a-zA-Z]".
Qui di seguito ci sono alcune di queste scorciatoie:
<p>
argomento	corrispondenze		equivale a ~ 	\d	numeri			[0-9] 	\D	non-numeri		[^0-9] 	\x	numeri esadecimali	[0-9a-fA-F] 	\X	numeri non-esadecimali	[^0-9a-fA-F] 	\s	spazio bianco		[ 	] (<Tab> e <Space>) 	\S	caratteri non-bianchi	[^ 	] (non <Tab> e <Space>) 	\l	caratteri alfabetici	[a-z] 	\L	non-lettere minuscole	[^a-z] 	\u	lettere maiuscole	[A-Z] 	\U	non-lettere maiuscole	[^A-Z]
<p>
Note: 	Usare questi intervalli predefiniti funziona molto più velocemente che 	non gli intervalli di caratteri equivalenti.
Questi argomenti non possono essere usati all'interno di [].
Quindi "[\d\l]" NON trova le corrispondenze di un numero o di 	lettera minuscola.
Usate invece "\(\d\|\l\)".
<p>
Vedete |/\s| per avere l'intera lista di questi intervalli.

<p>
============================================================================== *27.7*	Classi di caratteri
<p>
L'intervallo di caratteri trova le corrispondenze con una serie prefissata di caratteri.
Una classe di caratteri è simile, ma con una differenza essenziale: la serie di caratteri può essere ridefinita senza cambiare l'espressione di ricerca.
Ad esempio, cercate questa espressione: >
<p>
/\f\+
<p>
L'argomento "\f" sta per caratteri di nomi di file.
Quindi corrisponde a sequenze di caratteri che possono essere il nome di un file.
Quali caratteri possono far parte del nome di un file dipende dal sistema operativo che voi state usando.
In MS-Windows, la backslash è inclusa, in Unix non lo è.
Questo è specificato con l'opzione 'isfname'.
Il valore di default per Unix è: >
<p>
:set isfname 	isfname=@,48-57,/,.,-,_,+,,,#,$,%,~,=
<p>
Per altri sistemi il valore di default è diverso.
Quindi potete creare una espressione di ricerca con "\f" per trovare il nome di un file ed esso automaticamente si adatterà al sistema nel quale lo state usando.

<p>
Note: 	In realtà, Unix permette di usare qualsiasi carattere nel nome di un 	file, spazi bianchi inclusi.
Includere questi caratteri in 'isfname' 	sarebbe teoricamente corretto, ma renderebbe impossibile trovare la 	fine del nome del file nel testo.
Quindi il valore predefinito di 	'isfname' è un compromesso.

<p>
Le classi di caratteri sono:
<p>
argomento	corrispondenze			opzioni ~ 	\i	caratteri di identificativi 	'isident' 	\I	come \i, escludendo i numeri 	\k	caratteri di parole chiave 	'iskeyword' 	\K	come \k, escludendo i numeri 	\p	caratteri stampabili		'isprint' 	\P	come \p, escludendo i numeri 	\f	caratteri di nomi di file	'isfname' 	\F	come \f, escludendo i numeri
<p>
============================================================================== *27.8* Ricerca di interruzioni di linea
<p>
Vim può trovare una espressione che includa una interruzione di linea.
Dovete specificare dov'è l'interruzione, poiché tutti gli argomenti menzionati fin qui non cercano le interruzioni di linea.
Per verificare una interruzione di linea in una posizione specifica, usate l'argomento "\n" : >
<p>
/the\nword
<p>
Questo corrisponderà a una linea che finisca con "the" seguita da una linea che inizi con "word".
Per trovare "the word" così com'è, dovete trovare una interruzione o uno spazio bianco.
L'argomento da usare per far questo è "\_s": >
<p>
/the\_sword
<p>
Per permettere qualsiasi numero di spazi bianchi: >
<p>
/the\_s\+word
<p>
Questo trova le corrispondenze anche quando "the " è alla fine di una linea e " word" si trova all'inizio della successiva.

<p>
"\s" trova lo spazio bianco, "\_s" trova lo spazio bianco o una interruzione di linea.
Similarmente, "\a" corrisponde a un carattere alfabetico e "\_a" corrisponde ad un carattere alfabetico o a una interruzione di linea.
Le altre classi o intervalli di caratteri possono essere modificati nello stesso modo inserendo un "_".

<p>
Molti altri argomenti possono essere creati per trovare una interruzione di linea anteponendo "\_".
Ad esempio: "\_." corrisponde ad ogni carattere od interruzione di linea.

<p>
Note: 	"\_.*" trova qualsiasi cosa fino alla fine del file.
State attenti 	con questo, poiché può rendere un comando di ricerca molto lento.

<p>
Un altro esempio è "\_[]", un intervallo di caratteri che includa una interruzione di linea: >
<p>
/"\_[^"]*"
<p>
Questo trova un testo tra virgolette che può essere distribuito in diverse linee.

<p>
============================================================================== *27.9*	Esempi
<p>
Ecco alcune espressioni di ricerca che voi potreste trovare utili.
Mostrano come possono essere combinati gli argomenti menzionati sopra.

<p>

<p>
TROVARE UNA TARGA AUTOMOBILISTICA DELLA CALIFORNIA
<p>
Un semplice numero di targa è "1MGU103".
Esso ha un numero, tre lettere maiuscole e tre numeri.
Mettiamo questo direttamente in una espressione di ricerca: >
<p>
/\d\u\u\u\d\d\d
<p>
Un altro metodo è quello di specificare che ci sono tre numeri e lettere con un conteggio: >
<p>
/\d\u\{3}\d\{3}
<p>
Usando gli intervalli [] invece: >
<p>
/[0-9][A-Z]\{3}[0-9]\{3}
<p>
Quali tra questi potreste usare? Quello che vi ricordate.
Il metodo semplice che riuscite a ricordare è molto più veloce del metodo fantasioso che non riuscite a ricordare.
Se riuscite a ricordarli tutti, evitate l'ultimo, poiché è sia più lungo da digitare, che più lento da eseguire.

<p>

<p>
TROVARE UN IDENTIFICATIVO
<p>
Nei programmi in C (e in molti altri linguaggi del computer), un identificativo inizia con una lettera e più oltre è composto da lettere e numeri.
Anche gli underscore ("_") possono essere usati.
Questi possono essere trovati con: >
<p>
/\<\h\w*\>
<p>
"\<" e "\>" sono usati per trovare solo parole intere.
"\h" equivale a "[A-Za-z_]" e "\w" sta per "[0-9A-Za-z_]".

<p>
Note: 	"\<" e "\>" dipendono dall'opzione 'iskeyword'.
Se essa include "-", 	per esempio, poi "ident-" non è trovato.
In questa situazione usate: >
<p>
/\w\@<!\h\w*\w\@! < 	Questo controlla se "\w" non trova corrispondenze prima o dopo 	l'identificativo.
Vedete |/\@<!| e |/\@!|.

<p>
==============================================================================
<p>
Capitolo seguente: |usr_28.txt| La piegatura
<p>
Copyright: vedere |manual-copyright| vim:tw=78:ts=8:ft=help:norl:
<p>
Per segnalazioni scrivere a vimdoc.it at gmail dot com oppure ad Antonio Colombo azc100 at gmail dot com *usr_28.txt*	Per Vim version 7.2.
Ultima modifica: 2008 Giu 14
<p>
VIM USER MANUAL - di Bram Moolenaar 	 Traduzione di questo capitolo: Giuliano Bordonaro
<p>
La piegatura
<p>

<p>
Un testo strutturato può essere diviso in sezioni.
E le sezioni in sottosezioni.
La piegatura vi consente di mostrare una sezione come una sola linea, consentendo una visione d'assieme.
Questo capitolo spiega i diversi modi per farlo.

<p>
|28.1|	Che vuol dire piegatura? |28.2|	Piegatura manuale |28.3|	Lavorare con le piegature |28.4|	Salvataggio e ripristino delle piegature |28.5|	Piegature secondo i rientri |28.6|	Piegature mediante marker |28.7|	Piegature secondo la sintassi |28.8|	Piegature secondo espressione |28.9|	Piegature delle linee non modificate |28.10| Quale metodo di piegatura usare?
<p>
Capitolo seguente: |usr_29.txt| Spostarsi attraverso i programmi Capitolo precedente: |usr_27.txt| Comandi di ricerca e modelli 	 Indice: |usr_toc.txt|
<p>
============================================================================== *28.1*	Cosa vuol dire piegatura?
<p>
La piegatura serve per mostrare un gruppo di linee del buffer come se fossero una sola riga sullo schermo.
Allo stesso modo con cui piegate un foglio di carta per renderlo più corto:
<p>
+------------------------+ 	| linea 1		 | 	| linea 2		 | 	| linea 3		 | 	|_______________________ | 	\			 \ 	 \________________________\ 	 / linee ripiegate	 / 	/________________________/ 	| linea 12		 | 	| linea 13		 | 	| linea 14		 | 	+------------------------+
<p>
Il testo esiste ancora nel buffer, intatto.
Soltanto che le linee visibili hanno una piegatura.

<p>
Un vantaggio conseguente alla piegatura è che potete godere di una migliore vista d'assieme della struttura del testo, piegando delle linee di una sezione e sostituendole con una sola linea che indica che lì c'è una sezione.

<p>
============================================================================== *28.2*	Piegatura manuale
<p>
Provate: mettete il cursore entro un paragrafo e digitate: >
<p>
zfap
<p>
Vedrete che il paragrafo viene sostituito da una linea evidenziata.
Avete effettuato una piegatura.
|zf| è un operatore ed |ap| la selezione di un oggetto di testo.
Potrete impiegare l'operatore |zf| con tutti i comandi di movimento per creare una piegatura del testo su cui vi siete spostati.
|zf| lavora anche nel modo visuale.

<p>
Per rivedere il testo, dispiegatelo digitando: >
<p>
zo
<p>
E potrete richiudere la piegatura con: >
<p>
zc
<p>
Tutti i comandi di piegatura cominciano con "z".
Con un po' di fantasia "z" ricorda un foglio di carta piegato visto da un lato.
La lettera che segue la "z" ha un significato mnemonico per aiutarvi a rammentare i comandi:
<p>
zf	F-old creation	(Creare una piegatura) 	zo	O-pen a fold	(Riaprire una piegatura) 	zc	C-lose a fold	(Chiudere una piegatura)
<p>
La piegatura può venire annidata: una regione di testo che contenga delle piegature può essere nuovamente piegata.
Ad esempio, potete piegare tutti i paragrafi di questa sezione e poi farlo con le sezioni costituenti questo capitolo.
Provate.
Vedrete che aprendo la piegatura che contiene l'intero capitolo verranno conservate le pieghe nidificate così come erano, alcune potrebbero essere aperte ed altre invece chiuse.

<p>
Supponete di aver fatto diverse piegature e di voler invece vedere tutto il testo.
Potreste portarvi su ogni piega e digitare "zo".
Per fare prima usate questo comando: >
<p>
zr
<p>
Questo R-idurrà la piegatura.
Il contrario è: >
<p>
zm
<p>
Questo piega M-ore (nuovamente).
Potete ripetere "zr" e "zm" per aprire e chiudere le pieghe annidate di molti livelli.

<p>
Se aveste annidato attraverso molti livelli, potreste aprirli tutti con: >
<p>
zR
<p>
Questo R-iduce le piegature non lasciandone alcuna.
E potete chiudere tutte le pieghe con: >
<p>
zM
<p>
Questo piegherà M-olto e M-olto di più.

<p>
Potete togliere rapidamente le piegature con il comando |zn|.
E |zN| riporta la piegatura come era.
|zi| cambia tra le due.
Questo è un modo proficuo di lavorare: - creare le piegature per avere la vista d'assieme del vostro file - spostarvi dove vi pare per fare il vostro lavoro - fare |zi| per cercare del testo e lavorarci - fare |zi| nuovamente per tornare indietro e ricominciare lo spostamento
<p>
Maggiori informazioni sulla piegatura manuale sono nel manuale di riferimento: |fold-manual|
<p>
============================================================================== *28.3*	Lavorare con le piegature
<p>
Quando una piegatura è chiusa, i comandi di movimento come "j" e "k" la attraversano come se fosse una sola linea vuota.
Ciò vi consente di spostarvi rapidamente sopra il testo ripiegato.

<p>
Potete copiare, cancellare ed incollare le piegature come se si trattasse di una sola linea.
Ciò è utilissimo per riordinare delle funzioni entro un programma.
Prima assicuratevi che ciascuna piega contenga tutta una funzione (o poco meno) selezionando il corretto 'foldmethod'.
Poi cancellate la funzione con "dd", spostate il cursore ed incollatela con "p".
Se alcune linee della funzione fossero prima o dopo la piegatura, potreste usare la selezione Visual: - ponete il cursore sulla prima linea da spostare - premete "V" per entrare nel modo Visual - portate il cursore sull'ultima linea che volete spostare - premete "d" per cancellare le linee selezionate.
- spostate il cursore sulla nuova posizione e "p"ut (incollate) qui le linee.

<p>
E' talvolta difficile vedere o ricordare dove si trovi una piegatura, ossia dove un comando |zo| potrebbe davvero operare.
Per vedere le piegature definite: >
<p>
:set foldcolumn=4
<p>
Ciò mostrerà una piccola colonna alla sinistra della finestra per indicare le piegature.
Un "+" viene mostrato per una piegatura chiusa.
Un "-" è posto all'inizio di ciascuna piega aperta e "|" alle linee seguenti della piega.
<p>
Potete usare il mouse per aprire una piega facendo clic sul "+" nella colonna della piegatura.
Fare clic sul "-" o sul "|" chiuderà una piegatura aperta.
<p>
Per aprire tutte le pieghe sulla linea del cursore usate |zO|.
Per chiudere tutte le pieghe sulla linea del cursore usate |zC|.
Per eliminare una piega sulla linea del cursore usate |zd|.
Per eliminare tutte le pieghe sulla linea del cursore usate |zD|.

<p>
Se siete nell'Insert mode, la piega alla linea del cursore non è mai chiusa.
Ciò vi consente di vedere ciò che state scrivendo!
<p>
Le piegature vengono aperte automaticamente quando si salta in giro o si sposta il cursore a sinistra od a destra.
Ad esempio, il comando "0" apre la piega sotto il cursore (se 'foldopen' contiene "hor", che è il default).
L'opzione 'foldopen' può essere cambiata per aprire pieghe per comandi specifici.
Se volete che venga sempre aperta la linea sotto il cursore, fate così: >
<p>
:set foldopen=all
<p>
Attenzione: non potrete spostarvi entro una piega chiusa allora.
Potreste voler usare ciò solo temporaneamente e poi tornare al settaggio di default: >
<p>
:set foldopen&
<p>
Potete far sì che le piegature si chiudano automaticamente quando uscite da esse: >
<p>
:set foldclose=all
<p>
Ciò riapplicherà 'foldlevel' a tutte le piegature che non contengono il cursore.
Dovrete provarlo per sentire se vi piace.
Usate |zm| per piegare ancora e |zr| per piegare di meno (ridurre le pieghe).
<p>
La piega è localizzata nella finestra.
Ciò vi permette di aprire due finestre sullo stesso buffer, una con le pieghe e l'altra senza.
Od una con tutte le pieghe chiuse ed una con tutte aperte.

<p>
============================================================================== *28.4*	Salvataggio e ripristino delle piegature
<p>
Quando lasciate un file (iniziando ad editarne un altro), lo stato delle piegature viene perduto.
Ritornando allo stesso file successivamente tutte le piegature aperte o chiuse manualmente saranno tornate al proprio default.
Quando le pieghe sono state create manualmente, tutte le pieghe vanno perdute! Per salvare le piegature usate il comando |:mkview|: >
<p>
:mkview
<p>
Ciò scriverà nel file le impostazioni e le altre cose che influenzano la vista.
Potete modificare quanto salvato con l'opzione 'viewoptions'.
Riaprendo successivamente lo stesso file, potrete caricare nuovamente le viste: >
<p>
:loadview
<p>
Potete salvare fino a dieci viste di un file.
Ad esempio, salvare le impostazioni attuali come terza vista e caricare la seconda: >
<p>
:mkview 3 	:loadview 2
<p>
Notare che quando aggiungete o cancellate delle linee la vista potrebbe diventare non valida.
Così osservate l'opzione 'viewdir', che indica dove le viste sono state salvate.
Potreste voler cancellare delle vecchie viste.
<p>
============================================================================== *28.5*	Piegature secondo i rientri
<p>
Definire le pieghe con |zf| costa un sacco di lavoro.
Se avete strutturato il vostro testo dando un rientro più ampio alle componenti di livello più basso, potrete usare il metodo di piegatura dei rientri.
Ciò creerà piegature per tutti gli insiemi di linee aventi lo stesso rientro.
Linee con un rientro più ampio diverranno piegature annidate.
Ciò funziona assai bene con molti linguaggi di programmazione.

<p>
Provatelo impostando l'opzione 'foldmethod': >
<p>
:set foldmethod=indent
<p>
Così potrete usare i comandi |zm| e |zr| per piegare maggiormente o ridurre le piegature.
E' facile da vedere in questo testo di esempio:
<p>
This line is not indented 	This line is indented once 		This line is indented twice 		This line is indented twice 	This line is indented once This line is not indented 	This line is indented once 	This line is indented once
<p>
Notare che la relazione tra l'estensione del rientro e la profondità della piegatura dipendono dall'opzione 'shiftwidth'.
Ciascun valore 'shiftwidth' del rientro aggiunge un'unità alla profondità della piegatura.
Ciò viene chiamato livello di piegatura.

<p>
Usando i comandi |zr| e |zm| adesso aumentate o diminuite il valore dell'opzione 'foldlevel'.
Potete anche impostarlo direttamente: >
<p>
:set foldlevel=3
<p>
Ciò significa che tutte le piegature con tre volte il rientro 'shiftwidth' o più verranno chiuse.
Più basso sarà il livello di piegatura, tante più piegature verranno chiuse.
Quando 'foldlevel' è zero tutte le piegature vengono chiuse.
|zM| pone 'foldlevel' a zero.
Il comando opposto |zR| pone 'foldlevel' al livello più profondo presente entro il file.
<p>
Così ci sono due modi per aprire e chiudere le piegature: (A) Impostando il livello di piegatura.
Fornisce un velocissimo modo di "portarsi in alto" per vedere la struttura del testo, spostare il cursore, e "ritornare in basso" nel testo.

<p>
(B) Usando i comandi |zo| e |zc| per aprire o chiudere specifiche piegature.
Consente di aprire soltanto le piegature volute, lasciando chiuse le altre.

<p>
Ciò può venire combinato: potete prima chiudere molte piegature usando |zm| poche volte e poi aprire una piega specifica con |zo|.
Od aprire tutte le piegature con |zR| e poi chiuderne alcune con |zc|.

<p>
Ma non potete definire delle piegature manualmente se il 'foldmethod' è "indent", poiché ciò sarebbe in conflitto con la relazione tra il rientro ed il livello di piegatura.

<p>
Di più circa le piegature basate sul rientro nel manuale di riferimento: |fold-indent|
<p>
============================================================================== *28.6*	Piegature mediante marker
<p>
Dei marker entro il testo vengono usati per specificare l'inizio e la fine di una regione di piegatura.
Ciò dà un esatto controllo su quali linee siano incluse entro una piegatura.
Lo svantaggio è che il testo necessita di essere modificato.

<p>
Provatelo: >
<p>
:set foldmethod=marker
<p>
Testo di esempio, come apparirebbe in un programma C:
<p>
/* foobar () {{{ */ 	int foobar() 	{ 		/* return a value {{{ */ 		return 42; 		/* }}} */ 	} 	/* }}} */
<p>
Notate che la linea piegata mostrerà il testo prima del marker.
Ciò è molto utile per capire cosa contenga la piegatura.

<p>
E' fastidioso quando i marker non siano più accoppiati correttamente dopo aver spostato qualche linea.
Ciò può essere evitato usando marker numerati.
Esempio:
<p>
/* global variables {{{1 */ 	int varA, varB;
<p>
/* functions {{{1 */ 	/* funcA() {{{2 */ 	void funcA() {}
<p>
/* funcB() {{{2 */ 	void funcB() {} 	/* }}}1 */
<p>
Ad ogni marker numerato comincia una piegatura del livello specificato.
Ciò farà che qualsiasi piegatura di livello più alto finisca qui.
Potete usare proprio dei marker numerati di partenza per definire tutte le piegature.
Solo quando voleste esplicitamente terminare una piegatura prima che ne inizi un'altra dovrete aggiungere un marker di fine.

<p>
Di più circa le piegature con i marker nel manuale di riferimento: |fold-marker|
<p>
============================================================================== *28.7*	Piegature secondo la sintassi
<p>
Per ogni linguaggio Vim usa un file di sintassi diverso.
Ciò definisce i colori per le diverse componenti entro il file.
Se state leggendo questo testo su di un terminale che supporti i colori, i colori che vedete vengono fatti con il file di sintassi "help".
Nei file di sintassi è possibile aggiungere oggetti di sintassi che abbiano l'argomento "fold".
Questi definiscono una regione di piegatura.
Ciò comporta di scrivere un file di sintassi ed aggiungergli questi oggetti.
Non è semplice da fare.
Ma una volta fatto, tutte le piegature avvengono automaticamente.
Poniamo di usare un file di sintassi esistente.
Così non vi è più nulla da spiegare.
Potete aprire e chiudere piegature come spiegato sopra. Le piegature verranno create e distrutte automaticamente scrivendo il file.
<p>
Di più circa le piegature secondo sintassi nel manuale di riferimento: |fold-syntax|
<p>
============================================================================== *28.8*	Piegature secondo espressione
<p>
E' come la piegatura basata sul rientro ma, invece di impiegare il rientro di una linea, una funzione utente verrà chiamata a calcolare il livello di piegatura di una linea.
Potete usarlo per del testo ove qualcosa indichi quali linee debbano stare insieme.
Un esempio è costituito da un messaggio e-mail dove il testo quotato viene indicato da un ">" prima della linea.
Per piegare queste quote usate questo: >
<p>
:set foldmethod=expr 	:set foldexpr=strlen(substitute(substitute(getline(v:lnum),'\\s','',\"g\"),'[^>].*','',''))
<p>
Potete provarlo con il testo seguente:
<p>
> quoted text he wrote > quoted text he wrote > > double quoted text I wrote > > double quoted text I wrote
<p>
Spiegazione per la 'foldexpr' usata nell'esempio (a partire dal centro): getline(v:lnum)			prende la linea corrente substitute(...,'\\s','','g')		toglie tutti gli spazi bianchi dalla 					linea substitute(...,'[^>].*','','')	toglie tutto ciò che segue '>' strlen(...)				misura la lunghezza della stringa, 					pari al numero di '>'s trovati
<p>
Notare che una barra rovesciata deve essere inserita davanti ad ogni spazio, virgolette doppie e barra rovesciata per il comando ":set".
Se ciò vi confonde usate >
<p>
:set foldexpr
<p>
per vedere l'attuale valore risultante.
Per correggere un'espressione complicata usate il completamento automatico da linea di comando: >
<p>
:set foldexpr=<Tab>
<p>
Dove <Tab> è il vero Tab.
Vim completerà il valore precedente che potrete allora modificare.

<p>
Di più circa la piegatura secondo espressione nel manuale di riferimento: |fold-expr|
<p>
============================================================================== *28.9*	Piegatura delle linee non modificate
<p>
Risulta utile se impostate l'opzione 'diff' nella stessa finestra.
Il comando |vimdiff| lo farà per voi.
Esempio: >
<p>
:setlocal diff foldmethod=diff scrollbind nowrap foldlevel=1
<p>
Fatelo in ogni finestra che mostri una versione diversa dello stesso file.
Vedrete chiaramente le differenze tra i file, fin quando il testo non modificato rimane piegato.

<p>
Per maggiori dettagli vedere |fold-diff|.

<p>
============================================================================== *28.10* Quale metodo di piegatura usare?
<p>
Tutte queste possibilità inducono a domandarsi quale metodo scegliere.
Purtroppo non esiste una regola d'oro.
Ecco alcuni suggerimenti.
<p>
Se c'è un file di sintassi con le piegature per il linguaggio che state utilizzando, questa è probabilmente la scelta migliore.
Se non ce n'è uno potreste provare a scriverlo.
Ciò richiede una buona conoscenza delle stringhe di ricerca.
Non è facile, ma quando funziona non dovete definire le piegature manualmente.

<p>
Piegare manualmente delle regioni scrivendo comandi può essere usato per il testo non strutturato.
Allora usate il comando |:mkview| per salvare e ripristinare le vostre piegature.

<p>
Il metodo dei marker richiede che voi modifichiate il file.
Se condividete i file con altri o dovete rispettare gli standard della ditta, potreste non essere in grado di aggiungerne.
Il vantaggio principale dei marker è che li potete mettere esattamente dove li volete.
Ciò evita che qualche linea vada persa quando tagliate ed incollate delle piegature.
E potete aggiungere un commento su cosa sia contenuto della piegatura.

<p>
La piegatura badata sul rientro è qualcosa che funziona in molti file, ma non sempre benissimo.
Usatela quando non potete usare uno degli altri metodi.
Comunque è molto utile per delineare.
A questo fine, usate una sola 'shiftwidth' per tutti i livelli di annidamento.
<p>
Piegare mediante espressioni può fare le piegature in quasi tutti i testi strutturati.
È anche semplice da specificare, particolarmente se l'inizio e la fine di una piegatura può essere trovato facilmente.
Se usate il metodo "expr" per definire le piegature, ma non vi vengono come vorreste potete passare al metodo "manual".
Ciò non rimuoverà le piegature già definite.
Così potrete cancellare od aggiungere piegature manualmente.
<p>
==============================================================================
<p>
Capitolo seguente: |usr_29.txt| Spostarsi attraverso i programmi
<p>
Copyright: vedere |manual-copyright| vim:tw=78:ts=8:ft=help:norl:
<p>
Per segnalazioni scrivere a vimdoc.it at gmail dot com oppure ad Antonio Colombo azc100 at gmail dot com *usr_29.txt*	Per Vim version 7.2.
Ultima modifica: 2008 Giu 28
<p>
VIM USER MANUAL - di Bram Moolenaar 		Traduzione di questo capitolo: Antonio Colombo
<p>
Spostarsi attraverso i programmi
<p>

<p>
Chi ha creato Vim è un programmatore di computer.
Non sorprende quindi che Vim contenga molte funzionalità utili nella scrittura di programmi.
Spostatevi per trovare dove vengono definiti o usati degli identificatori.
Visualizzate dichiarazioni in una finestra apposita.
Ulteriori possibilità sono descritte nel prossimo capitolo.

<p>
|29.1|	Usare i tag |29.2|	La finestra di anteprima |29.3|	Muoversi all'interno di un programma |29.4|	Trovare identificatori globali |29.5|	Trovare identificatori locali
<p>
Capitolo seguente: |usr_30.txt| Editare programmi Capitolo precedente: |usr_28.txt| La piegatura 	 Indice: |usr_toc.txt|
<p>
============================================================================== *29.1*	Usare i tag
<p>
Cos'è un tag? È un posto dove è definito un identificatore.
Un esempio è la definizione di una funzione in un programma C o C++.
Una lista di tag è il contenuto di un file di tag.
Il file può essere usato da Vim per saltare direttamente da un posto qualsiasi al tag, il posto dove un identificatore è definito.
Per generare il file di tag per tutti i file C nella directory corrente, usate il comando seguente: >
<p>
ctags *.c
<p>
[Il nome del file generato è sempre "tags" - NdT] "ctags" è un programma a parte.
Quasi tutti i sistemi Unix lo hanno già installato.
Se ancora non l'avete, potete trovare "Exuberant ctags" qui:
<p>
http://ctags.sf.net ~
<p>
Adesso, quando siete in Vim e volete andare a una definizione di funzione, potete raggiungerla velocemente usando il comando seguente: >
<p>
:tag startlist
<p>
Questo comando troverà una funzione "startlist" anche se è in un altro file.
Il comando CTRL-] salta al tag della parola che è sotto il cursore.
Questo facilita l'esplorazione di una "giungla" di codice C.
Supponete, ad es., di trovarvi in una funzione "scrivi_blocco".
Potete vedere che chiama "scrivi_linea".
Ma cosa fa "scrivi_linea"? Posizionando il cursore sulla chiamata a "scrivi_linea" e digitando CTRL-], saltate alla definizione di questa funzione.

<p>
La funzione "scrivi_linea" chiama "scrivi_carattere".
Per capire cosa faccia "scrivi_carattere", posizionate il cursore sulla chiamata a "scrivi_carattere" e digitate CTRL-].
Siete ora alla definizione di "scrivi_carattere".
<p>
+-----------------------------------------------+ 	|void scrivi_blocco(char **s; int contatore)	| 	|{						| 	| int i;					| 	| for (i = 0; i < contatore; ++i)		| 	| scrivi_linea(s[i]);			| 	|}	 |					| 	+-----------|-----------------------------------+ 		 | 	 CTRL-] | 		 |	 +------------------------------+ 		 +--> |void scrivi_linea(char *s)	| 			 |{				| 			 | while (*s != 0)		| 			 |	scrivi_carattere(*s++);	| 			 |}	 |			| 			 +--------|---------------------+ 				 | 			 CTRL-] | 				 | +------------------------------------+ 				 +--> |void scrivi_carattere(char c)	 | 				 |{				 | 				 | putchar((int)(unsigned char)c); | 				 |}				 | 				 +------------------------------------+
<p>
Il comando ":tags" visualizza la lista di tag attraverso cui siete passati:
<p>
:tags 	 # A tag	 DA__ linea in file/testo ~ 	 1 1 scrivi_linea	 8 scrivi_blocco.c ~ 	 2 1 scrivi_carattere	 7 scrivi_linea.c ~ 	> ~ > Ora tornate indietro.
Il comando CTRL-T torna al tag precedente.
Nell'esempio sopra tornate a una funzione "scrivi_linea", nella chiamata a "scrivi_carattere".
Questo comando accetta come argomento un contatore, che indica di quante tag tornare indietro.
Siete andati avanti, e poi indietro.
Andiamo avanti ancora. Il comando seguente va al primo tag di una lista: >
<p>
:tag
<p>
Potete premettergli un contatore e saltare in avanti di alcuni tag.
Ad es.: ":3tag".
Anche con CTRL-T si può specificare un contatore.
Questi comandi quindi vi permettono di scendere lungo una cascata di chiamate con CTRL-] e di tornare indietro ancora con CTRL-T.
Usate ":tags" per vedere dove vi trovate.

<p>

<p>
DIVIDERE LA FINESTRA
<p>
Il comando ":tag" rimpiazza il file nella finestra corrente con quello che contiene la nuova funzione.
Supponete di voler vedere non solo la vecchia funzione ma anche quella nuova.
Potete dividere in due la finestra usando il comando ":split" seguito dal comando ":tag".
Vim ha un comando "scorciatoia" che fa entrambe le cose: >
<p>
:stag nome_tag
<p>
Per dividere in due la finestra corrente e saltare al tag sotto il cursore usate questo comando: >
<p>
CTRL-W ]
<p>
Se un contatore è specificato, la nuova finestra sarà alta quel numero di linee.

<p>

<p>
PIU' FILE DI TAG
<p>
Quando avete file in molte directory, potete create un file di tag in ognuna di esse.
Vim sarà capace solo di saltare a tag all'interno di quella directory.
Per trovare più file di tag, impostate l'opzione 'tags' per includere tutti i file di tag che vi interessano.
Esempio: >
<p>
:set tags=./tags,./../tags,./*/tags
<p>
Questo trova un file di tag nella stessa directory del file corrente, nel livello di directory superiore e in tutte le sub-directory.
In questo modo si trovano parecchi file di tag, ma potrebbero servirvene altri.
Ad es., modificando un file in "~/proj/src", non trovereste il file di tag "~/proj/sub/tags".
In vista di questa situazione Vim permette di cercare un intero albero di directory, per utilizzarne i file di tag.
Esempio: >
<p>
:set tags=~/proj/**/tags
<p>

<p>
UN SOLO FILE DI TAG
<p>
Quando Vim deve cercare in parecchi posti per trovare file di tag, potete udire il vostro hard disk che rumoreggia.
La faccenda può diventare lunga.
In questo caso è meglio impiegare lo stesso tempo per generare un unico grosso file di tag.
Potreste lasciar girare un simile lavoro durante la notte.
E' necessario il programma "Exuberant ctags", prima citato.
Provvede un argomento per cercare attraverso un intero albero di directory: >
<p>
cd ~/proj 	ctags -R .

<p>
Il bello della faccenda è che "Exuberant ctags" riconosce vari tipi di file.
E quindi è possibile far questo non solo con programmi C e C++, ma anche per script Eiffel e perfino per script Vim.
Si veda la documentazione di ctags per come funziona la cosa.
Ora dovete solo dire a Vim dov'è il vostro grosso file di tag: >
<p>
:set tags=~/proj/tags
<p>

<p>
CORRISPONDENZE MULTIPLE
<p>
Quando una funzione è definita più volte (o un metodo in parecchie classi), il comando ":tag" salterà alla prima delle definizioni.
Se c'è una corrispondenza nel file corrente, quella è usata per prima.
Potete poi saltare ad altre corrispondenze per lo stesso tag con: >
<p>
:tnext
<p>
Ripetete questo comando per trovare ulteriori corrispondenze.
Se sono tante, potete scegliere quella a cui saltare: >
<p>
:tselect nome_tag
<p>
Vim vi farà scegliere da una lista:
<p>
# pri tipo tag	 file ~ 	 1 F	f mch_init	 os_amiga.c ~ 		 mch_init() ~ 	 2 F	f mch_init	 os_mac.c ~ 		 mch_init() ~ 	 3 F	f mch_init	 os_msdos.c ~ 		 mch_init(void) ~ 	 4 F	f mch_init	 os_riscos.c ~ 		 mch_init() ~ 	Batti n.
di scelta (<INVIO> per lasciar perdere): ~
<p>
Potete ora scegliere il numero (nella prima colonna) della corrispondenza a cui volete saltare.
L'informazione nelle altre colonne vi dà una buona idea di dove dove la corrispondenza è definita.

<p>
Per muoversi fra i tag corrispondenti, si possono usare questi comandi:
<p>
:tfirst			vai alla prima corrispondenza 	:[count]tprevious	vai alla [contatore] corrispondenza precedente 	:[count]tnext		vai alla [contatore] prossima corrispondenza 	:tlast			vai alla ultima corrispondenza
<p>
Se [count] è omesso ne viene usato uno solo.

<p>

<p>
TROVARE NOMI TAG
<p>
Usare il completamento della linea comandi permette di evitare di immettere un lungo nome di tag.
Immettete solo la parte iniziale e digitate <Tab>: >
<p>
:tag scrivi_<Tab>
<p>
Vi verrà segnalata la prima corrispondenza.
Se non è quella giusta, digitate <Tab> finché non trovate quella buona.
Talora conoscete solo parte del nome di una funzione.
Oppure avete tante tag che iniziano con la stessa stringa, ma finiscono in modo diverso.
Allora potete dire a Vim di usare un'espressione per trovare il tag.
Supponete di voler saltare a un tag che contiene "blocco".
Prima digitate questo: >
<p>
:tag /blocco
<p>
Adesso usate il completamento della linea comandi: digitate <Tab>.
Vim troverà tutti i tag che contengono "blocco" e userà la prima corrispondenza.
La "/" prima del nome del tag dice a Vim che quel che segue non è un nome di tag, ma un'espressione.
Potete usate tutto quel che mettete in un'espressione di ricerca qui.
Ad es., supponete di voler selezionare un tag che comincia con "scrivi_": >
<p>
:tselect /^scrivi_
<p>
L'accento circonflesso "^" specifica che il nome del tag inizia con "scrivi_".
Altrimenti una corrispondenza verrebbe trovata anche nel mezzo del nome di tag.
Allo stesso modo il carattere "$" posto alla fine richiede solo corrispondenze che si trovino nella parte finale del nome di un tag.

<p>

<p>
UN NAVIGATORE DI TAG
<p>
Dato che CTRL-] vi porta alla definizione dell'identificatore sotto il cursore, potete usate una lista di nomi di identificatore come un indice.
Ecco un esempio.
Prima create una lista di identificatori (ciò richiede "Exuberant ctags"): >
<p>
ctags --c-types=f -f funzioni *.c
<p>
Adesso avviate Vim senza un file, ed editate questo file in Vim, in una finestra separata verticalmente: >
<p>
vim 	:vsplit funzioni
<p>
La finestra contiene una lista di tutte le funzioni.
Ci sono anche altre informazioni, ma potete ignorarle.
Digitate ":setlocal ts=99" per fare un po' di "pulizia".
In questa finestra, definite la mappatura: >
<p>
:noremap <buffer> <CR> 0ye<C-W>w:tag <C-R>"<CR>
<p>
Muovete il cursore sulla linea che contiene una funzione a cui volete saltare.
Poi premete <Invio>.
Vim passerà all'altra finestra e salterà alla funzione che avete selezionato.

<p>

<p>
ARGOMENTI CORRELATI
<p>
Potete impostare 'ignorecase' per non dover digitare maiuscole e minuscole nei nomi di tag.

<p>
L'opzione 'tagbsearch' dice se il file di tag è già in ordine alfabetico o no.
Il default è di supporre che il file di tag sia già ordinato, cosa che rende la ricerca molto più veloce, ma non funziona se il file di tag non è ordinato.

<p>
L'opzione 'taglength' si può usare per dire a Vim il numero di caratteri significativi in un nome di tag.

<p>
Quando usate il programma SNiFF+, potete usate l'interfaccia fra SNiFF e Vim.
Si veda |sniff|.
SNiFF+ è un programma a pagamento.
<p>
Cscope è un programma free.
Non solo trova i posti dove un identificatore è stato dichiarato, ma anche dove viene usato.
Si veda |cscope|.
<p>
============================================================================== *29.2*	La finestra di anteprima
<p>
Quando modificate del codice che contiene una chiamata a funzione, dovete passargli gli argomenti corretti.
Per sapere che valori passare potete guardare a come la funzione è definita.
Il meccanismo dei tag si presta molto bene ad effettuare questo controllo.
Preferibilmente la definizione viene visualizzata in un'altra finestra.
Per questo si può usare la finestra di anteprima.
Per aprire una finestra di anteprima per visualizzare la funzione "scrivi_carattere": >
<p>
:ptag scrivi_carattere
<p>
Vim aprirà una finestra, e salterà al tag "scrivi_carattere".
Poi vi riporterà indietro alla posizione di partenza.
Così potete continuare a modificare il file senza dover ricorrere al comando CTRL-W.
Se il nome di una funzione ricorre nel testo, potete vedere la sua definizione nella finestra di anteprima digitando: >
<p>
CTRL-W }
<p>
Esiste uno script che automaticamente visualizza il testo dove è stata definita la parola sotto il cursore.
Si veda |CursorHold-example|.
<p>
Per chiudere la finestra di anteprima, usate questo comando: >
<p>
:pclose
<p>
Per modificare un file nella finestra di anteprima, usate ":pedit".
Questo può tornare utile per modificare un file "header" [contenente definizioni di solito incluse da più programmi - NdT], ad es.: >
<p>
:pedit definizioni.h
<p>
Infine, ":psearch" si può usare per trovare una parola nel file corrente e nei file da questo inclusi e visualizzare la corrispondenza nella finestra di anteprima.
Questo è particolarmente utile se si usano funzioni di libreria, per le quali non avete un file di tag.
Ad es.: >
<p>
:psearch popen
<p>
Ciò mostrerà il file "stdio.h" nella finestra di anteprima, col prototipo di funzione per popen():
<p>
FILE	*popen __P((const char *, const char *)); ~
<p>
Potete specificare l'altezza della finestra di anteprima, quando è aperta, con l'opzione 'previewheight'.

<p>
============================================================================== *29.3*	Muoversi all'interno di un programma
<p>
Poiché un programma ha una struttura, Vim può riconoscere parti di esso.
Ci sono comandi che si possono usare per muoversi all'interno.
I programmi C spesso contengono costrutti del tipo:
<p>
#ifdef USE_POPEN ~ 	 fd = popen("ls", "r") ~ 	#else ~ 	 fd = fopen("tmp", "w") ~ 	#endif ~
<p>
Ma molto più lunghi, e possibilmente rientrati.
Posizionate il cursore su "#ifdef" e digitate %.
Vim salterà ad "#else".
Digitando % ancora arrivate a "#endif".
Un altro % vi riporta indietro a "#ifdef".
Quando il costrutto è annidato, Vim troverà l'elemento corrispondente.
Questa è una buona maniera per controllare se avete dimenticato un "#endif".
Quando siete nel bel mezzo di un "#if" - "#endif", potete saltare all'inizio dello stesso con: >
<p>
[#
<p>
Se non siete dopo un costrutto "#if" o "#ifdef" Vim manda un segnale acustico di errore.
Per raggiungere il prossimo "#else" o "#endif" usate: >
<p>
]#
<p>
Questi due comandi saltano qualsiasi blocco "#if" - "#endif" che incontrano.
Ad es.:
<p>
#if defined(HAS_INC_H) ~ 	 a = a + inc(); ~ 	# ifdef USE_THEME ~ 	 a += 3; ~ 	# endif ~ 	 set_width(a); ~
<p>
Col cursore sull'ultima linea, "[#" vi porta alla prima linea.
Il blocco "#ifdef" - "#endif" nel mezzo viene saltato.

<p>

<p>
MUOVERSI ALL'INTERNO DI BLOCCHI DI PROGRAMMA
<p>
Nel codice C, i blocchi sono racchiusi fra {}.
Questi blocchi possono essere anche molto lunghi.
Per spostarvi all'inizio del blocco più esterno, usate il comando "[[".
Usate "][" per portarvi alla fine.
Questi comandi suppongono che "{" e "}" siano nella prima colonna.
Il comando "[{" vi porta all'inizio del blocco corrente.
Coppie di {} allo stesso livello vengono saltate.
"]}" salta alla fine. Una panoramica:
<p>
funzione(int a) 	 +->		{ 	 |		 if (a) 	 |	 +->	 { 	[[ |	 |		for (;;)	 --+ 	 |	 |	 +->	{			 | 	 |	[{ |	 |	 foo(32);		 | --+ 	 |	 | [{ |	 if (bar(a)) --+	 | ]}	 | 	 +--	 |	 +--		break;	 | ]} |	 | 		 |		}		 <-+	 |	 | ][ 		 +--		foobar(a)		 |	 | 			 }			 <-+	 | 			}				 <-+
<p>
Quando scrivete in C++ o Java, il blocco più esterno {} è per la "class".
Il livello successivo di {} è per un "method".
Se vi trovate da qualche parte all'interno di una "class", usate "[m" per trovare il precedente inizio di un "method".
"]m" trova il prossimo inizio di un "method".
<p>
Inoltre, "[]" va all'indietro alla fine di una funzione e "]]" va avanti all' inizio di una nuova funzione.
La fine di una funzione è definito da una "}" nella prima colonna.

<p>
int func1(void) 				{ 					return 1; 		 +----------> } 		 | 	 [] |		int func2(void) 		 |	 +->	{ 		 | [[ |		if (flag) 	start	 +--	 +--			return flag; 		 | ][ |		return 2; 		 |	 +->	} 	 ]] | 		 |		int func3(void) 		 +---------->	{ 					return 3; 				}
<p>
Non dimenticate che potete anche usare "%" per muovervi tra (), {} e [] corrispondenti.
Questo funziona anche quando sono separati da parecchie linee di codice.

<p>

<p>
MUOVERSI TRA LE PARENTESI
<p>
I comandi "[(" e "])" funzionano in modo simile a "[{" e "]}", solo che si muovono fra coppie di () invece che di {}.
> 				 [( <		 <-------------------------------- 			 <------- 		if (a == b && (c == d || (e > f)) && x > y) ~ 				 --------------> 			 --------------------------------> > 				 ])
<p>
MUOVERSI TRA I COMMENTI
<p>
Per muoversi all'indietro verso l'inizio di un commento, usate "[/".
Muovetevi in avanti verso la fine di un commento con "]/".
Questo funziona solo per commenti delimitati da /* - */.

<p>
+->	 +-> /* 	 | [/ | * Un commento sulla --+ [/ |	 +-- * vita meravigliosa.	| ]/ 	 |	 */		 <-+ 	 | 	 +--	 foo = bar * 3;	 --+ 						| ]/ 		 /* breve commento */ <-+
<p>
============================================================================== *29.4*	Trovare identificatori globali
<p>
State modificando un programma C e vi domandate se una variabile è dichiarata come "int" o "unsigned".
Un modo veloce per accertarlo è quello di usare il comando "[I".
Supponete il cursore sia sulla parola "column".
Digitate: >
<p>
[I
<p>
Vim elencherà le linee corrispondenti che riesce a trovare.
Non solo nel file corrente, ma anche in tutti i file inclusi (e nei file da questi ultimi a loro volta inclusi, etc.).
Il risultato è del tipo:
<p>
structs.h ~ 	 1: 29 unsigned column; /* column number */ ~
<p>
Il vantaggio rispetto ad usare i tag o la finestra di anteprima è che i file inclusi sono a loro volta controllati.
Il più delle volte si arriva così alla dichiarazione che interessa.
Anche quando il file di tag non è aggiornato.
Anche quando non esiste un file di tag per i file inclusi.
Perché il comando "[I" funzioni, servono tuttavia alcuni prerequisiti.
Innanzitutto, l'opzione 'include' deve specificare come un file è incluso.
Il valore predefinito funzione per C e C++.
Va cambiato in maniera opportuna, se state modificando file scritti in altri linguaggi.
<p>

<p>
LOCALIZZARE I FILE INCLUSI
<p>
Vim troverà i file inclusi nelle directory specificate con l'opzione 'path'.
Se una directory non è listata, alcuni file inclusi non potranno essere trovati.
Potete accertarvene con questo comando: >
<p>
:checkpath
<p>
Verranno elencati i file inclusi che non si riescono a trovare.
Anche i file inclusi nei file che [invece] si riescono a trovare.
Un esempio di output:
<p>
--- File inclusi non trovati nel percorso --- ~ 	<io.h> ~ 	vim.h --> ~ 	 <functions.h> ~ 	 <clib/exec_protos.h> ~
<p>
Il file "io.h" è incluso dal file corrente e non può venire trovato.
"vim.h" invece può essere trovato, e quindi ":checkpath" lo legge e controlla cosa a sua volta includa.
I file "functions.h" e "clib/exec_protos.h", inclusi da "vim.h" non vengono trovati.

<p>
Note: 	Vim non è un compilatore.
Non interpreta istruzioni "#ifdef".
Questo significa che ogni "#include" viene controllata, anche 	se viene dopo una istruzione "#if NEVER".
[Ossia, si 	controllano tutte le "#include", sia quelle in uso che quelle 	inutilizzate.
- NdT]
<p>
Per correggere i file che non possono essere trovati, aggiungete una directory all'opzione 'path'.
Un buon posto per scoprire dove sia il Makefile.
Cercate linee che contengano parametri "-I", tipo "-I/usr/local/X11".
Per aggiungere questa directory usate: >
<p>
:set path+=/usr/local/X11
<p>
Quando ci sono tante subdirectory, potete usare la "wildcard" "*".
Ad es.: >
<p>
:set path+=/usr/*/include
<p>
Questo potrebbe trovare dei file in "/usr/local/include" e anche in "/usr/X11/include".

<p>
Se lavorate su un progetto con un intero albero nidificato di file inclusi, la notazione "**" è utile.
Utilizzandola, verranno cercate tutte le sottodirectory.
Ad es.: >
<p>
:set path+=/projects/invent/**/include
<p>
Così si troveranno file nelle directory:
<p>
/projects/invent/include ~ 	/projects/invent/main/include ~ 	/projects/invent/main/os/include ~ 	etc.

<p>
Ci sono anche ulteriori possibilità.
Si veda l'opzione 'path' per maggiori informazioni.
Se voler vedere quali file inclusi sono stati trovati, usate questo comando: >
<p>
:checkpath!
<p>
Otterrete una (...lunga) lista dei file inclusi, i file che questi a loro volta includono, e così via.
Per non allungare troppo la lista, Vim indica "(Già elencato)" per file che sono già stati censiti, e non lista di nuovo tutti i file che questi includono.

<p>

<p>
SALTARE A UNA CORRISPONDENZA
<p>
"[I" produce una lista con solo una linea di testo.
Quando volete dare un'occhiata più da vicino al primo elemento, potete saltare a quella linea col comando: >
<p>
[<Tab>
<p>
Potete anche usare "[ CTRL-I", poiché CTRL-I ha lo stesso effetto che digitare <Tab>.

<p>
La lista che "[I" produce ha un numero all'inizio di ogni linea.
Quando volete saltare a un altro elemento diverso dal primo, digitate quel numero prima del comando: >
<p>
3[<Tab>
<p>
Salterà al terzo elemento nella lista.
Ricordate che potete usate CTRL-O per tornare indietro dove vi trovavate.

<p>

<p>
COMANDI CORRELATI
<p>
[i		lista solo la prima corrispondenza 	]I		lista solo elementi sotto il cursore 	]i		lista solo il primo elemento sotto il cursore
<p>

<p>
TROVARE IDENTIFICATORI PARTICOLARI
<p>
Il comando "[I" trova qualsiasi identificatore.
Per trovare solo macro, definite con "#define" usate: >
<p>
[D
<p>
Di nuovo, anche i file inclusi vengono controllati.
L'opzione 'define' specifica com'è formata una linea che definisce elementi da ricercare tramite "[D".
Potreste cambiare questa definizione per farla funzionare con linguaggi diversi da C o C++.
I comandi correlati a "[D" sono:
<p>
[d		lista solo la prima corrispondenza 	]D		lista solo elementi sotto il cursore 	]d		lista solo il primo elemento sotto il cursore
<p>
============================================================================== *29.5*	Trovare identificatori locali
<p>
Il comando "[I" ricerca nei file inclusi.
Per cercare solo nel file corrente, e saltare alla prima istruzione dove la parola sotto il cursore è usata: >
<p>
gD
<p>
Pensate a "gD" come: Go_to Definition [Vai alla definizione].
Questo comando è molto utile per trovare una variabile o funzione che sia stata dichiarata localmente ("static", nel gergo C).
Ad es. (il cursore è su "contatore"):
<p>
+-> static int contatore = 0; 	 | 	 | int get_contatore(void) 	gD | { 	 |	 ++contatore; 	 +--	 return contatore; 		 }
<p>
Per delimitare ulteriormente la ricerca, e considerare solo la funzione corrente, usate questo comando: >
<p>
gd
<p>
Questo comando partirà dall'inizio della funzione corrente a trovare la prima occorrenza della parola sotto il cursore.
In realtà, ricerca all'indietro fino a trovare una linea vuota sopra un "{" a colonna 1.
Da lì viene effettuata una ricerca in avanti dell'identificatore.
Ad es.
(cursore su "indice"):
<p>
int find_entry(char *name) 		{ 	 +->	 int indice; 	 | 	gd |	 for (indice = 0; indice < lunghezza_tabella; ++indice) 	 |		if (strcmp(table[indice].name, name) == 0) 	 +--		 return indice; 		}
<p>
==============================================================================
<p>
Capitolo seguente: |usr_30.txt| Editare programmi
<p>
Copyright: vedere |manual-copyright| vim:tw=78:ts=8:ft=help:norl:
<p>
Per segnalazioni scrivere a vimdoc.it at gmail dot com oppure ad Antonio Colombo azc100 at gmail dot com *usr_30.txt*	Per Vim version 7.2.
Ultima modifica: 2007 Nov 10
<p>
VIM USER MANUAL - di Bram Moolenaar 	 Traduzione di questo capitolo: Alessandro Melillo
<p>
Editare programmi
<p>

<p>
Vim ha diversi comandi che sono d'aiuto nello scrivere programmi per computer.
Compila un programma e salta direttamente agli errori riscontrati.
Definisce automaticamente il rientro per molti linguaggi e formatta i commenti.

<p>
|30.1|	Compilazione |30.2|	Rientro dei file in C |30.3|	Rientro automatico |30.4|	Altri rientri |30.5|	Tabulazioni e spazi |30.6|	Formattazione dei commenti
<p>
Capitolo seguente: |usr_31.txt| Sfruttare la GUI Capitolo precedente: |usr_29.txt| Spostarsi attraverso i programmi 	 Indice: |usr_toc.txt|
<p>
============================================================================== *30.1*	Compilazione
<p>
Vim ha una serie di comandi cosiddetti "quickfix".
Questi permettono di compilare un programma all'interno di Vim e successivamente esaminare gli errori generati e correggerli (fortunatamente).
Poi è possibile ricompilare e correggere ogni altro errore si trovasse, sino a che il nostro programma non compili senza errori.

<p>
Il comando seguente lancia "make" (con qualsiasi argomento gli si passi) e cattura il risultato: >
<p>
:make {argomenti}
<p>
Se vengono generati errori, vengono catturati e l'editor vi posiziona nel punto in cui si è verificato il primo errore.
Date un'occhiata a una sessione ":make" d'esempio.
(Le sessioni :make tipiche generano molti errori ed assai meno di quelli stupidi).
Dopo aver scritto ":make" lo schermo appare così:
<p>
:!make | &tee /tmp/vim215953.err ~ 	gcc -g -Wall -o prog main.c sub.c ~ 	main.c: In function 'main': ~ 	main.c:6: too many arguments to function 'do_sub' ~ 	main.c: At top level: ~ 	main.c:10: parse error before '}' ~ 	make: *** [prog] Error 1 ~
<p>
2 returned ~ 	"main.c" 11L, 111C ~ 	(3 of 6): too many arguments to function 'do_sub' ~ 	Premi INVIO o un comando per proseguire ~
<p>
Da qui potete vedere che ci sono errori nel file "main.c".
Premendo <Enter>, Vim mostra il file "main.c", con il cursore posizionato alla linea 6, la prima contenente un errore.
Non avete avuto bisogno di specificare il file od il numero di riga, Vim sapeva dove andare per guardare i messaggi d'errore.

<p>
+---------------------------------------------------+ 		|int main()					 | 		|{						 | 		|	int i=3;				 | cursore -> |	do_sub("foo");				 | 		|	++i;					 | 		|	return (0);				 | 		|}						 | 		|}						 | 		| ~						 | 		|(3 of 12): too many arguments to function 'do_sub' | 		+---------------------------------------------------+
<p>
Il comando seguente va dove si trova il prossimo errore: >
<p>
:cnext
<p>
Vim salta alla linea 10, l'ultima del file, dove c'è una '}' di troppo.
Quando non c'è sufficiente spazio, Vim abbrevia il messaggio d'errore.
Per vedere il messaggio intero usate: >
<p>
:cc
<p>
Potete ottenere un sommario di tutti gli errori con il comando ":clist".
L'output appare così: >
<p>
:clist <	3 main.c: 6:too many arguments to function 'do_sub' ~ 	5 main.c: 10:parse error before '}' ~
<p>
Solo le righe in cui Vim riconosce un nome di file ed un numero di linea vengono elencate.
Assume che quelle siano le linee interessanti e che il resto sia costituito solo da messaggi noiosi.
Comunque, a volte linee non riconosciute contengono qualcosa che volete vedere.
Per esempio, l'output del linker per una funzione non definita.
Per vedere tutti i messaggi aggiungete un "!" al comando: >
<p>
:clist! <	1 gcc -g -Wall -o prog main.c sub.c ~ 	2 main.c: In function 'main': ~ 	3 main.c:6: too many arguments to function 'do_sub' ~ 	4 main.c: At top level: ~ 	5 main.c:10: parse error before '}' ~ 	6 make: *** [prog] Error 1 ~
<p>
Vim evidenzierà l'errore corrente.
Per tornare al precedente, usate: > 	:cprevious
<p>
Altri comandi per spostarvi nella lista errori:
<p>
:cfirst		al primo errore 	:clast		all'ultimo errore 	:cc 3		all'errore numero 3
<p>

<p>
USARE UN ALTRO COMPILATORE
<p>
Il nome del programma da eseguire quando si impartisce il comando ":make" è definito dall'opzione 'makeprg'.
Solitamente è settata a "make", ma gli utenti di Visual C++ dovrebbero impostarlo a "nmake" eseguendo il seguente comando: >
<p>
:set makeprg=nmake
<p>
Potete anche includere argomenti in questa opzione.
Caratteri speciali devono essere protetti con un backslash.
Esempio: >
<p>
:set makeprg=nmake\ -f\ project.mak
<p>
Potete includere parole chiave speciali di Vim nella specifica del comando.
Il carattere % si espande al nome del file corrente.
Così, se eseguite il comando: >
<p>
:set makeprg=make\ %
<p>
Mentre editate main.c, allora ":make" esegue il seguente comando: >
<p>
make main.c
<p>
Questo non è troppo utile, quindi potete ridefinire un po' il comando ed usare il modificatore :r (root): >
<p>
:set makeprg=make\ %:r.o
<p>
Ora il comando eseguito è questo: >
<p>
make main.o
<p>
Maggiori informazioni sui modificatori si trovano qui: |filename-modifiers|.

<p>

<p>
VECCHIE LISTE D'ERRORE
<p>
Supponiamo di eseguire ":make" su un programma.
C'è un messaggio di avviso in un file e uno di errore in un altro.
Correggete l'errore ed usate ancora ":make" per controllare se sia stato realmente corretto.
Adesso volete guardare il messaggio di avvertimento.
Non compare nell'ultima lista di errori, poiché il file con l'avviso non è stato ricompilato.
Si può tornare alla lista precedente con: >
<p>
:colder
<p>
E poi usare ":clist" e ":cc" {nr} per saltare al punto con l'avviso.
Per andare avanti alla successiva lista di errori: >
<p>
:cnewer
<p>
Vim ricorda dieci liste di errori.

<p>

<p>
ALTERNARE I COMPILATORI
<p>
Bisogna dire a Vim in quale formato il nostro compilatore produca i messaggi d'errore.
Ciò viene fatto con l'opzione 'errorformat'.
La sintassi di questa opzione è piuttosto complicata e si può adattare a qualsiasi compilatore.
Potete trovare la spiegazione è qui: |errorformat|.
<p>
Potreste usare diversi compilatori.
Settare l'opzione 'makeprg', e specialmente 'errorformat' ogni volta non è semplice.
Vim offre un metodo semplice per farlo.
Per esempio, per passare ad usare il compilatore Microsoft Visual C++: >
<p>
:compiler msvc 	 Questo comando troverà lo script di Vim per il compilatore "msvc" ed imposterà le opzioni appropriate.
Potete anche scrivere i vostri file di opzioni.
Vedere |write-compiler-plugin|.

<p>
RE-INDIRIZZAMENTO DELL'OUTPUT
<p>
Il comando ":make" redirige l'output del programma eseguito ad un file d'errore.
Come ciò funzioni dipende da diversi fattori quali la 'shell'.
Se il vostro comando ":make" non cattura l'output verificate le pozioni 'makeef' e 'shellpipe'.
Anche le opzioni 'shellquote' e 'shellxquote' potrebbero essere utili.

<p>
Nel caso in cui non riusciate ad ottenere che ":make" rediriga l'output per voi, un'alternativa è compilare il programma in un'altra finestra e reindirizzare l'output in un file.
Quindi farlo leggere a Vim con: >
<p>
:cfile {nomefile}
<p>
Saltando agli errori funzionerà come con il comando ":make".

<p>

<p>
============================================================================== *30.2*	Rientro dei file in C
<p>
Un programma è molto più facile da comprendere quando le linee siano state rientrate appropriatamente.
Vim offre numerosi modi per farlo con meno lavoro.
Per i programmi in C o con uno stile di programmazione simile, come Java o C++ occorre impostare l'opzione 'cindent'.
Vim sa come sono scritti i programmi in C e cercherà in ogni modo di impostare automaticamente il rientro per voi.
Impostate l'opzione 'shiftwidth' al numero di spazi che volete per scendere a un livello più profondo.
Quattro spazi possono andar bene.
Basta un solo comando ":set" per impostare entrambe le opzioni: >
<p>
:set cindent shiftwidth=4
<p>
Con questa opzione abilitata, quanto scrivete qualcosa tipo "if (x)", la linea successiva verrà automaticamente rientrata ad un livello aggiuntivo.

<p>

<p>
if (flag) 	Rientro automatico --->	do_the_work(); 	Ritorno automatico <-- if (other_flag) { 	Rientro automatico --->	do_file(); 	Mantenimento rientro		do_some_more(); 	Ritorno automatico <--	 }
<p>
Quando scrivete qualcosa tra parentesi graffe ({}), il testo verrà rientrato all'inizio ma non alla fine.
Il ritorno indietro verrà fatto dopo che avete digitato '}', poiché Vim non può indovinare cosa state per scrivere.

<p>
Un effetto collaterale del rientro automatico è che vi aiuta a trovare rapidamente gli errori nel codice.
Quando digitate una } per concludere una funzione, il solo vedere che il rientro automatico non si collochi dove previsto vi aiuta a capire che manca una }.
Usate il comando "%" per trovare quale { corrisponda alla } che avete appena digitato.
Anche una ) o un ; mancanti causano un ulteriore rientro.
Così, se vedete più spazio bianco di quello che vi aspettavate, controllate le linee precedenti.

<p>
Quando avete del codice che sia mal formattato, oppure avete inserito e cancellato delle linee, dovrete rientrarlo di nuovo.
L'operatore "=" lo fa.
La forma più semplice è: >
<p>
==
<p>
Questo rientra la linea corrente.
Come con tutti gli operatori, ci sono tre modi per usarlo.
In modo Visual "=" rientra le linee selezionate.
Un utile oggetto testuale è "a{".
Questo seleziona il blocco {} corrente. Così, per rientrare di nuovo il blocco di codice in cui si trova il cursore: >
<p>
=a{
<p>
Se avete del codice veramente mal rientrato, potete rientrare di nuovo l'intero file con: >
<p>
gg=G
<p>
Comunque, non fatelo con dei file che avete rientrato con cura manualmente.
Il rientro automatico fa un buon lavoro, ma in certe situazioni potreste volerlo evitare.

<p>

<p>
IMPOSTARE LO STILE DI RIENTRO
<p>
Persone diverse hanno differenti stili di rientro.
Per default, Vim fa un gradevole buon lavoro di rientro, nel modo in cui lo fa il 90% dei programmatori.
Comunque ci sono diversi stili; quindi, se volete, potete personalizzare lo stile di rientro con l'opzione 'cinoptions'.
Per default 'cinoptions' è vuota e Vim impiega il proprio stile predefinito.
Potete aggiungere istanze quando volete qualcosa di diverso.
Per esempio, per far sì che le parentesi graffe vengano posizionate così:
<p>
if (flag) ~ 	 { ~ 	 i = 8; ~ 	 j = 0; ~ 	 } ~
<p>
Usate questo comando: >
<p>
:set cinoptions+={2
<p>
Ci sono molti oggetti del genere.
Vedere |cinoptions-values|.
<p>
============================================================================== *30.3*	Rientro automatico
<p>
Se non volete attivare l'opzione 'cindent' manualmente ogni volta che editate un file in C? Ecco come richiederla in automatico: >
<p>
:filetype indent on
<p>
In realtà, questo fa molto di più che attivare 'cindent' per i sorgenti C.
Prima di tutto, abilita l'individuazione del tipo di file.
La stessa usata per l'evidenziazione della sintassi.
Una volta conosciuto il tipo di file, Vim cercherà un tipo di rientro per questo tipo di file.
La distribuzione di Vim include un buon numero di questi tipi per vari linguaggi di programmazione.
Il file di rientro poi si preoccuperà di predisporre il giusto rientro per il file corrente.

<p>
Se non vi piace il rientro automatico, potete disattivarlo: >
<p>
:filetype indent off
<p>
Se non vi piace il rientro per un determinato tipo di file, ecco come evitarlo.
Create un file con questa linea: >
<p>
:let b:did_indent = 1
<p>
Adesso dovete salvarlo con un nome specifico:
<p>
{directory}/indent/{filetype}.vim
<p>
Dove {filetype} è il nome del tipo di file, come "cpp" o "java".
Potete vedere l'esatto nome che Vim ha rilevato con questo comando: >
<p>
:set filetype
<p>
In questo file l'output è:
<p>
filetype=help ~
<p>
E quindi usereste "help" come {filetype}.
Per la parte {directory} dovete utilizzare la vostra directory di runtime.
Guardate l'output di questo comando: >
<p>
set runtimepath
<p>
Adesso utilizzate il primo elemento, il nome che precede la prima virgola.
Quindi, se l'output appare così:
<p>
runtimepath=~/.vim,/usr/local/share/vim/vim60/runtime,~/.vim/after ~
<p>
Usate "~/.vim" come {directory}.
Quindi il nome di file risultante è:
<p>
~/.vim/indent/help.vim ~
<p>
Invece di disattivare il rientro, potreste scrivere un vostro file di rientro.
Come farlo è spiegato qui: |indent-expression|.

<p>
============================================================================== *30.4*	Altri rientri
<p>
La forma più semplice di rientro automatico è quella dell'opzione 'autoindent'.
Usa il rientro della riga precedente.
Un po' più furba è l'opzione 'smartindent'.
E' utile per i file che non hanno un file di rientro.
'smartindent' non è intelligente come 'cindent' ma lo è sempre più di 'autoindent'.
Con 'smartindent' impostata viene aggiunto un livello extra di rientro dopo ogni { e tolto un livello dopo ogni }.
Viene aggiunto un livello extra anche per ognuna delle parole contenute nell'opzione 'cinwords'.
Le righe che iniziano con # vengono trattate in maniera speciale: viene tolto ogni rientro.
Il motivo è che le direttive di preprocessore in questo modo inizieranno tutte a colonna 1.
Il rientro viene ripristinato alla linea successiva.
<p>

<p>
CORREZIONE DEI RIENTRI
<p>
Quando state usando 'autoindent' o 'smartindent' per ottenere il rientro della prima linea, molte volte dovrete aggiungere o rimuovere un valore di 'shiftwidth' del rientro.
Un modo rapido per farlo è usare i comandi CTRL-D e CTRL-T in modo Insert.
Ad esempio, state scrivendo uno script di shell che si suppone appaia come questo:
<p>
if test -n a; then ~ 	 echo a ~ 	 echo "-------" ~ 	fi ~
<p>
Iniziate impostando questa opzione: >
<p>
:set autoindent shiftwidth=3
<p>
Iniziate scrivendo la prima linea, <Enter> e l'inizio della seconda:
<p>
if test -n a; then ~ 	echo ~
<p>
Ora vi accorgete di aver bisogno di un rientro.
Scrivete CTRL-T.
Il risultato:
<p>
if test -n a; then ~ 	 echo ~
<p>
Il comando CTRL-T, in modo Insert, aggiunge uno 'shiftwidth' di rientro a prescindere dalla posizione in cui vi trovate nella linea.
Continuate a scrivere la seconda linea, <Enter> e la terza linea.
Questa volta il rientro è OK.
Ancora <Enter> e la prossima linea.
Adesso avrete questo:
<p>
if test -n a; then ~ 	 echo a ~ 	 echo "-------" ~ 	 fi ~
<p>
Per rimuovere il rientro superfluo nell'ultima linea premete CTRL-D.
Ciò toglierà uno 'shiftwidth' di rientro, a prescindere dalla posizione in cui vi trovate nella linea.
Quando siete in modo Normal, potete usare i comandi ">>" e "<<" per cambiare linea.
">" e "<" sono operatori, così avete i soliti tre modi per specificare le linee che volete rientrare.
Una combinazione utile è: >
<p>
>i{
<p>
Ciò aggiungerà un rientro all'attuale blocco di linee, entro {}.
Le linee comprese tra { e } verranno lasciate non modificate.
">a{" le include.
In questo esempio il cursore è su "printf":
<p>
original text		after ">i{"		after ">a{"
<p>
if (flag)		if (flag)		if (flag) ~ 	{			{			 { ~ 	printf("yes");		 printf("yes");	 printf("yes"); ~ 	flag = 0;		 flag = 0;		 flag = 0; ~ 	}			}			 } ~
<p>
============================================================================== *30.5*	Tabulazioni e spazi
<p>
'tabstop' è impostato ad otto di default.
Sebbene lo possiate cambiare, facilmente vi ritroverete nei problemi dopo.
Altri programmi potrebbero non sapere quale valore di tabstop abbiate usato.
Essi probabilmente usano il valore di default di otto spazi ed il vostro testo sembrerà improvvisamente assai diverso.
Parimenti molte stampanti usano un valore fisso di tabstop di otto spazi.
Così è meglio lasciar perdere 'tabstop'.
(Se state lavorando con un file che sia stato scritto con una diversa impostazione di tabstop, vedete |25.3| per correggere ciò).
Rientrare le linee di un programma usando un multiplo di otto spazi vi farà rapidamente andare verso il bordo destro della finestra.
Usare uno spazio solo non fornirà abbastanza differenza alla vista.
Molti preferiscono usare quattro spazi, un buon compromesso.
Sino a quando un <Tab> è di otto spazi e voi invece volete rientrare di quattro, non potete usare un carattere di <Tab> per fare il vostro rientro.
Ci sono due modi per gestire la cosa:
<p>
1.
Usare un mix di <Tab> e di spazi.
Poiché un <Tab> prende il posto di otto spazi, nel vostro file ci staranno meno caratteri.
Inserire un <Tab> è più rapido che inserire otto spazi.
Il backspace lavora più velocemente e bene.
<p>
2.
Usare solo degli spazi.
Evita fastidi con programmi che usano un valore diverso di tabstop.
<p>
Fortunatamente, Vim supporta entrambi i metodi altrettanto bene.

<p>

<p>
SPAZI E TABULATORI
<p>
Usando una combinazione di tabulatori e di spazi lavorate correttamente.
I default di Vim consentono di utilizzare agevolmente ciò.
Potete far vita migliore impostando l'opzione 'softtabstop'.
Questa opzione dice a Vim di far sembrare che il tasto <Tab> sia stato impostato al valore di 'softtabstop', mentre si sta usando una combinazione di spazi e tabulazioni.
Dopo aver eseguito il comando che segue, ogni volta che premerete il tasto <Tab> il cursore si sposterà al limite delle prossime quattro colonne: >
<p>
:set softtabstop=4
<p>
Iniziando dalla prima colonna e premendo <Tab>, avrete quattro spazi inseriti nel vostro testo.
La seconda volta Vim assumerà i quattro spazi e li porrà entro un <Tab> (portandovi così all'ottava colonna).
Così Vim usa il massimo numero possibile di <Tab> e riempie il resto con degli spazi.
L'uso del backspace opera analogamente in direzione opposta.
Un <BS> cancellerà sempre il numero di spazi specificato in 'softtabstop'.
Quindi si adoperano quanti <Tab> è possibile e spazi per riempire i vuoti.
Quanto segue mostra cosa accada premendo <Tab> alcune volte, e poi usando <BS>.
Un "." sta per uno spazio e "------->" per un <Tab>.
<p>
type			 result ~ 	<Tab>			 ....
<Tab><Tab>		 -------> 	<Tab><Tab><Tab>		 ------->....
<Tab><Tab><Tab><BS>	 -------> 	<Tab><Tab><Tab><BS><BS> ....

<p>
Un'alternativa consiste nell'usare l'opzione 'smarttab'.
Quando questa viene impostata, Vim usa 'shiftwidth' ad ogni <Tab> usato per rientrare una linea ed un vero <Tab> quando si digita dopo il primo carattere non-bianco.
Comunque <BS> non opererà come con 'softtabstop'.

<p>

<p>
SOLTANTO SPAZI
<p>
Se non volete affatto tabulatori nel vostro file potete impostare l'opzione 'expandtab': >
<p>
:set expandtab
<p>
Quando questa opzione è impostata il tasto <Tab> inserisce una serie di spazi.
Così otterrete la stessa quantità di spazi come se fosse stato inserito un carattere <Tab> ma non esisterà un vero carattere <Tab> entro il vostro file.
Il tasto backspace cancellerà uno spazio alla volta.
Così dopo aver scritto un solo <Tab> dovrete premere <BS> otto volte per cancellarlo.
Se vi trovate entro un rientro, premendo CTRL-D andrete molto più svelti.

<p>

<p>
CAMBIARE I TABULATORI IN SPAZI (E VICEVERSA)
<p>
Impostando 'expandtab' non si modificano i tabulatori esistenti.
In altri termini ogni tabulatore nel documento resta un tabulatore.
Se desiderate convertire i tabulatori in spazi, usate il comando ":retab".
Usate questi comandi: >
<p>
:set expandtab 	:%retab
<p>
Adesso Vim avrà cambiato il proprio rientro per usare spazi invece dei <Tab>.
Comunque tutti i <Tab> che vengono dopo un carattere diverso dallo spazio vengono conservati.
Se volete convertire anche questi ultimi aggiungete un !: >
<p>
:%retab!
<p>
Ciò è un po' più pericoloso perché può cambiare i tabulatori entro una stringa.
Per vedere se ciò possa avvenire potreste usare questo: >
<p>
/"[^"\t]*\t[^"]*"
<p>
Si raccomanda di non usare tabulazioni dure entro una stringa.
Sostituitele con "\t" per evitare problemi.

<p>
Un altro modo altrettanto valido è: >
<p>
:set noexpandtab 	:%retab!
<p>
============================================================================== *30.6*	Formattazione dei commenti
<p>
Una delle grandi cose di Vim è che capisce i commenti.
Potete chiedere a Vim di formattare un commento e lui farà la cosa giusta.
Supponiamo, ad esempio, che si abbia il seguente commento:
<p>
/* ~ 	 * This is a test ~ 	 * of the text formatting.
~ 	 */ ~
<p>
Potete chiedere a Vim di formattarlo ponendo il cursore all'inizio del commento e scrivendo: >
<p>
gq]/
<p>
"gq" è l'operatore per formattare del testo.
"]/" è il movimento che vi porterà alla fine del commento.
Il risultato sarà:
<p>
/* ~ 	 * This is a test of the text formatting.
~ 	 */ ~
<p>
Osservate come Vim abbia gestito correttamente l'inizio di ogni linea.
Un'alternativa consiste nel selezionare il testo da formattare in modo Visual e scrivere "gq".

<p>
Per aggiungere una nuova linea al commento ponete il cursore sulla linea di mezzo e premete "o".
Il risultato sarà il seguente:
<p>
/* ~ 	 * This is a test of the text formatting.
~ 	 * ~ 	 */ ~
<p>
Vim ha inserito automaticamente un asterisco ed uno spazio al vostro posto.
Adesso potete scrivere il testo del commento.
Se esso venisse più lungo di 'textwidth', Vim andrà a capo.
Anche questa volta l'asterisco verrà inserito automaticamente:
<p>
/* ~ 	 * This is a test of the text formatting.
~ 	 * Typing a lot of text here will make Vim ~ 	 * break ~ 	 */ ~
<p>
Affinché ciò funzioni debbono esserci alcuni flag presenti in 'formatoptions':
<p>
r	inserisce l'asterisco digitando <Enter> in modo Insert 	o	inserisce l'asterisco usando "o" od "O" in modo Normal 	c	spezza il testo del commento secondo 'textwidth'
<p>
Vedere |fo-table| per ulteriori flag.

<p>

<p>
DEFINIZIONE DI UN COMMENTO
<p>
L'opzione 'comments' definisce a cosa debba assomigliare un commento.
Vim distingue tra commenti di una sola linea e commenti che abbiano diverso inizio, fine e parte di mezzo.
Molti commenti su una sola linea iniziano con un carattere specifico.
In C++ viene impiegato //, nei Makefile #, negli script di Vim ".
Ad esempio per far capire a Vim i commenti di C++: >
<p>
:set comments=://
<p>
I due punti separano i flag di un oggetto dal testo da cui si riconosce il commento.
La forma di un oggetto in 'comments' è:
<p>
{flags}:{text}
<p>
La parte {flags} può essere anche vuota, come nel caso attuale.
Molti di questi oggetti possono essere concatenati, separati da virgole.
Ciò consente di riconoscere diversi tipi di commento nello stesso tempo.
Ad esempio, modifichiamo un messaggio di e-mail.
Rispondendo, il testo scritto da altri verrà preceduto dai caratteri ">" e "!".
Il comando funzionerebbe così: >
<p>
:set comments=n:>,n:!
<p>
Ci sono due cose, una per i commenti che iniziano con ">" ed un'altra per quelli che lo fanno con "!".
Entrambi usano il flag "n".
Ciò significa che questi commenti sono annidati l'uno nell'altro.
Così una linea che cominci con ">" può avere un altro commento dopo il ">".
Ciò consente di formattare messaggi come questo:
<p>
> ! Did you see that site? ~ 	> ! It looks really great.
~ 	> I don't like it.
The ~ 	> colors are terrible.
~ 	What is the URL of that ~ 	site? ~
<p>
Provate impostando 'textwidth' ad un valore diverso, e.g., 80, e formattate il testo selezionandolo in modo Visual e scrivendo "gq".
Il risultato sarà:
<p>
> ! Did you see that site? It looks really great.
~ 	> I don't like it.
The colors are terrible.
~ 	What is the URL of that site? ~
<p>
Noterete che Vim non sposta il testo da un tipo di commento ad un altro.
La lettera "I" nella seconda linea potrebbe venire posta alla fine della prima linea, ma poiché questa linea inizia con "> !" e la seconda linea con ">", Vim sa che si tratta di un diverso tipo di commento.

<p>

<p>
COMMENTI IN TRE PARTI
<p>
Un commento C inizia con "/*", ha "*" nel mezzo e "*/" alla fine.
Si dovrà porre in 'comments' affinché appaia così: >
<p>
:set comments=s1:/*,mb:*,ex:*/
<p>
L'inizio è definito con "s1:/*".
La "s" indica l'inizio di un commento in tre parti.
I due punti separano i flags dal testo da essi il commento viene riconosciuto: "/*".
C'è un solo flag: "1".
Ciò dice a Vim che la parte di mezzo è scostata di uno spazio.
La parte di mezzo "mb:*" comincia con "m", che indica che si tratta di una parte di mezzo.
Il flag "b" significa che uno spazio vuoto deve seguire il testo.
Altrimenti Vim potrebbe considerare testo come "*pointer" come il mezzo di un commento.
La parte finale "ex:*/" viene identificata da una "e".
Il flag "x" ha un significato speciale.
Significa che Vim inserirà dopo un asterisco automaticamente, scrivendo / eliminerà gli spazi di troppo.

<p>
Per ulteriori dettagli vedere |format-comments|.

<p>
==============================================================================
<p>
Capitolo seguente: |usr_31.txt| Sfruttare la GUI
<p>
Copyright: vedere |manual-copyright| vim:tw=78:ts=8:ft=help:norl:
<p>
Per segnalazioni scrivere a vimdoc.it at gmail dot com oppure ad Antonio Colombo azc100 at gmail dot com *usr_31.txt*	Per Vim version 7.2.
Ultima modifica: 2007 Mag 08
<p>
VIM USER MANUAL - di Bram Moolenaar 	 Traduzione di questo capitolo: Roberto Franceschini
<p>
Sfruttare la GUI
<p>

<p>
Vim funziona bene in un terminale, ma la sua GUI ha qualche componente in più.
Un navigatore di file può venir impiegato per i comandi che usano un file.
Finestre di dialogo per scegliere tra più alternative.
Tasti di scelta rapida per accedere a voci di menù rapidamente.
<p>
|31.1|	Il Navigatore |31.2|	Conferme |31.3|	Scelte rapide |31.4|	Posizione e dimensione della finestra |31.5|	Varie
<p>
Capitolo seguente: |usr_32.txt| La storia degli undo Capitolo precedente: |usr_30.txt| Editare programmi 	 Indice: |usr_toc.txt|
<p>
============================================================================== *31.1*	Il Navigatore
<p>
Quando utilizzate la voce di menù File/Open...
ottenete un navigatore di file.
Questo rende semplice trovare il file che volete modificare.
Ma cosa fare se voleste dividere la finestra per aprire un altro file? Non c'è una voce di menù per questo.
Potreste usare prima Window/Split e poi File/Open..., ma è lavoro in più.
Poiché digitate la maggior parte dei comandi in Vim, è possibile anche aprire il navigatore digitando un comando.
Per fare in modo che il comando split utilizzi il navigatore, anteponete "browse": >
<p>
:browse split
<p>
Selezionate un file ed il comando ":split" verrà eseguito su di esso.
Se chiudete la finestra di dialogo non succederà niente, la finestra non verrà divisa.
Potete anche specificare un argomento per il nome del file.
Questo verrà utilizzato per indicare al navigatore dove iniziare la ricerca.
Ad esempio: >
<p>
:browse split /etc
<p>
Il navigatore si aprirà iniziando la ricerca nella directory "/etc".

<p>
Potete anteporre il comando ":browse" a qualunque comando che apra un file.
Se non viene specificata alcuna directory, Vim deciderà dove iniziare la ricerca.
Per default utilizza l'ultima directory utilizzata la sessione precedente.
Quindi se voi utilizzate ":browse split" e selezionate un file in "/usr/local/share", la prossima volta che utilizzerete ":browse" la ricerca inizierà nuovamente in "/usr/local/share".
Ciò può essere modificato con l'opzione 'browsedir'.
Può assumere uno di questi tre valori:
<p>
last		Utilizza l'ultima directory selezionata (default) 	buffer		Utilizza la stessa directory del buffer corrente 	current		Utilizza la directory corrente 	 Ad esempio, se voi siete nella directory "/usr", e state editando il file "/usr/local/share/readme", allora il comando: >
<p>
:set browsedir=buffer 	:browse edit
<p>
Avvierà il navigatore in "/usr/local/share".
In alternativa: >
<p>
:set browsedir=current 	:browse edit
<p>
Avvierà il navigatore in "/usr".

<p>
Note: 	Per evitare l'utilizzo del mouse, molti navigatori permettono di 	muoversi usando combinazioni di tasti.
Dato che queste sono 	differenti per ogni sistema, non verranno spiegate qui.
Vim utilizza 	un navigatore standard quando possibile, e la documentazione del 	vostro sistema dovrebbe contenere una spiegazione delle scorciatoie da 	tastiera.

<p>
Se non utilizzate l'interfaccia grafica, potete utilizzare la finestra del "file explorer" per selezionare i file come in un navigatore.
Questo comunque non funziona per il comando ":browse".
Vedere |netrw-browser|.
<p>
============================================================================== *31.2*	Conferme
<p>
Vim vi protegge dal sovrascrivere accidentalmente un file o da altri modi di perdere delle modifiche.
Se fate qualcosa che potrebbe essere sbagliato, Vim produce un messaggio di errore e vi suggerisce di aggiungere ! se veramente volete proseguire.
Per evitare di digitare nuovamente il comando con !, potete fare in modo che Vim vi presenti una finestra di dialogo.
Potete quindi scegliere "OK" o "Cancel" per dire a Vim cosa volete.
Ad esempio, voi state aprendo un file e vi apportate delle modifiche.
Iniziate la modifica di un altro file con: >
<p>
:confirm edit foo.txt
<p>
Vim farà apparire una finestra di dialogo che appare simile a questa:
<p>
+---------------------------------------+ 	|					| 	| ?	Salvare modifiche a "bar.txt"? | 	|					| 	| YES NO		 CANCEL		| 	+---------------------------------------+
<p>
Adesso fate la vostra scelta.
Se volete salvare le modifiche, selezionate "YES".
Se volete abbandonare le modifiche per sempre: "NO".
Se avete dimenticato cosa stavate facendo e volete verificare le modifiche effettuate usate "CANCEL".
Tornerete allo stesso file, con le modifiche ancora lì.
<p>
Come ":browse", il comando ":confirm" può essere anteposto alla maggior parte dei comandi che aprano un altro file.
E possono essere anche combinati: >
<p>
:confirm browse edit
<p>
Se il buffer corrente fosse stato modificato, ciò genererebbe una finestra di dialogo.
Quindi apparirebbe un navigatore per scegliere il file da aprire.
<p>
Note: 	Nelle finestre di dialogo potete usare la tastiera per selezionare la 	scelta.
Solitamente il tasto <Tab> e le frecce cambiano la scelta.
Premendo <Enter> selezionate la scelta.
Questo, comunque, dipende dal 	sistema che utilizzate.
<p>
Il comando ":confirm" funziona anche quando non state usando la GUI.
Invece di aprire una finestra di dialogo, Vim stamperà il messaggio in fondo alla finestra e vi chiederà di premere un tasto per effettuare la scelta.
>
<p>
:confirm edit main.c 	Salvare modifiche a "Untitled"? ~ 	[Y]es, (N)o, (C)ancel: ~
<p>
Ora potete premere il tasto per la scelta.
Non dovrete premere <Enter>, a differenza delle altre digitazioni dalla riga di comando.

<p>
============================================================================== *31.3*	Scelte rapide
<p>
La tastiera si usa per tutti i comandi di Vim.
I menù forniscono un modo più semplice per selezionare i comandi, senza sapere come vengono chiamati.
Ma dovete spostare la vostra mano dalla tastiera ed afferrare il mouse.
I menù possono spesso essere selezionati anche da tastiera.
Dipende dal vostro sistema, ma quasi sempre funziona così.
Usate il tasto <Alt> assieme alla lettera sottolineata del menù.
Per esempio <A-w> (<Alt> e w) aprirà il menù Finestra.
Nel menù Finestra , "split" ha la <p> sottolineata.
Per selezionarlo premete <Alt> e quindi <p> assieme.

<p>
Dopo la prima selezione di un menù con il tasto <Alt>, potete usare le frecce per muovervi attraverso i menù.
La freccia a destra seleziona un sottomenù e la freccia a sinistra lo chiude.
Anche <Esc> chiude un menù.
<Enter> seleziona una scelta.
<p>
Esiste un conflitto utilizzando il tasto <Alt> per scegliere le componenti dei menù ed impiegando le combinazioni del tasto <Alt> per le mappature.
L'opzione 'winaltkeys' dice a Vim cosa può fare con il tasto <Alt>.
Il valore di default "menu" è la scelta migliore: se la combinazione di tasti è una scelta rapida per il menù non può essere mappata.
Tutti gli altri tasti sono disponibili per mappature.
Il valore "no" non consentirà l'uso di alcun tasto <Alt> per i menù.
Così dovrete usare il mouse per i menù, e potranno essere mappate tutte le combinazioni con <Alt>.
Se impostata a "yes" significa che potrà utilizzare le combinazioni con <Alt> per i menù.
Qualche combinazione del tasto <Alt> potrà eseguire anche azioni diverse dal selezionare i menù.

<p>
============================================================================== *31.4*	Posizione e dimensione della finestra
<p>
Per leggere la posizione corrente della finestra di Vim usate: >
<p>
:winpos
<p>
Questo funzionerà solo nella GUI.
L'output può essere simile a questo:
<p>
Posizione finestra: X 272, Y 103 ~
<p>
La posizione è data in pixel dello schermo.
Ora potete usare i numeri per muovere la finestra di Vim.
Per esempio, per muoverla cento pixel a sinistra: >
<p>
:winpos 172 103 < 	Note: 	Può esserci una leggera differenza tra la posizione riportata e dove 	la finestra si posiziona.
Questo a causa del bordo della finestra.
Quest'ultimo è aggiunto dal programma gestore delle finestre.
<p>
Potete utilizzare questo comando nello script di avvio per posizionare la finestra in una posizione specifica.

<p>
La dimensione della finestra di Vim è misurata in caratteri.
Quindi dipende dalla dimensione del font in uso.
Potete visualizzare la dimensione corrente con questo comando: >
<p>
:set lines columns
<p>
Per cambiare la dimensione impostate le opzioni 'lines' e/o 'columns' ad un nuovo valore: >
<p>
:set lines=50 	:set columns=80
<p>
La visualizzazione della dimensione in un terminale funziona proprio come nella GUI.
Nella maggior parte dei terminali non è però possibile impostare la dimensione.

<p>
Puoi avviare la versione X-Windows di gvim con un argomento per specificare la dimensione e la posizione della finestra: >
<p>
gvim -geometry {larghezza}x{altezza}+{x_offset}+{y_offset}
<p>
{larghezza} e {altezza} sono in caratteri, {x_offset} e {y_offset} sono in pixel.
Esempio: >
<p>
gvim -geometry 80x25+100+300
<p>
============================================================================== *31.5*	Varie
<p>
Potete utilizzare gvim per scrivere un messaggio di posta elettronica.
Nel vostro programma di posta elettronica dovete selezionare gvim come editor per i messaggi.
Quando proverete, probabilmente non funzionerà: Il programma di posta pensa che la scrittura del messaggio sia finita, mentre gvim sta girando ancora! Succede che gvim si scollega dalla shell nella quale è stato avviato.
Ciò va bene quando avviate gvim in un terminale, per poter fare altro in quel terminale.
Ma quando volete davvero aspettare che gvim abbia finito, dovete fare in modo che non si scolleghi.
L'argomento "-f" lo fa: >
<p>
gvim -f file.txt
<p>
La "-f" sta per "foreground" (primo piano).
Ora Vim bloccherà la shell da cui è stato avviato fino a che avrete finito di scrivere e siete usciti.

<p>

<p>
AVVIO RITARDATO DELLA GUI
<p>
In Unix è possibile avviare Vim in un terminale.
Questo serve se volete avviare diversi programmi nella stessa shell.
Se voi state lavorando su di un file e, ad un certo punto, volete passare alla GUI, potete avviarla con: >
<p>
:gui
<p>
Vim aprirà la finestra della GUI e non userà più il terminale.
Potete quindi utilizzare il terminale per altri scopi.
L'argomento "-f" viene qui usato per avviare la GUI in primo piano.
Potete anche usare ":gui -f".
<p>

<p>
IL FILE DI AVVIO DI GVIM
<p>
Quando gvim viene avviato, legge il file gvimrc.
Questo è simile al file vimrc usato quando lanciate Vim.
Il file gvimrc può essere utilizzato per impostazioni e comandi che vengono usati solo quando la GUI deve ancora venire avviata.
Per esempio, potete impostare l'opzione 'lines' per avere una diversa dimensione della finestra: >
<p>
:set lines=55
<p>
Non dovete fare ciò entro un terminale, in quanto la sua dimensione è fissa (ad eccezione di xterm che supporta il ridimensionamento).
Il file gvimrc viene cercato nella stessa posizione di vimrc.
Normalmente il suo nome è "~/.gvimrc" in Unix e "$VIM/_gvimrc" in MS-Windows.
La variabile d'ambiente $MYGVIMRC è impostata col suo nome, quindi potete usare questo comando per modificare il file, se ne avete uno: >
<p>
:edit $MYGVIMRC < Se per qualche ragione non voleste utilizzare il file gvimrc normale, potreste specificarne un altro con l'argomento "-U": >
<p>
gvim -U thisrc ...

<p>
Questo permette di avviare gvim per differenti tipi di lavori.
Potete, per esempio, impostare un'altra dimensione di font.
Per evitare definitivamente la lettura del file gvimrc: >
<p>
gvim -U NONE ...

<p>
==============================================================================
<p>
Capitolo seguente: |usr_32.txt| L'albero degli undo
<p>
Copyright: vedere |manual-copyright| vim:tw=78:ts=8:ft=help:norl:
<p>
Per segnalazioni scrivere a vimdoc.it at gmail dot com oppure ad Antonio Colombo azc100 at gmail dot com *usr_32.txt*	Per Vim version 7.2.
Ultima modifica: 2006 Apr 30
<p>
VIM USER MANUAL - di Bram Moolenaar
<p>
L'albero degli undo 		Traduzione di questo capitolo: Antonio Colombo
<p>

<p>
Vim gestisce un undo multiplo.
Se tornate indietro con alcune modifiche e poi fate delle nuove modifiche, create un ramo nell'albero [nella storia] degli undo.
Questo capitolo riguarda i movimenti fra i rami di quest'albero.
<p>
|32.1|	Numerazione modifiche |32.2|	Percorrere la storia delle modifiche |32.3|	Viaggiare nel tempo
<p>
Capitolo seguente: |usr_40.txt| Definire nuovi comandi Capitolo precedente: |usr_31.txt| Sfruttare la GUI 	 Indice: |usr_toc.txt|
<p>
============================================================================== *32.1*	Numerazione modifiche
<p>
Nella sezione |02.5| abbiamo trattato solo una linea di undo/redo.
Ma è anche possibile percorrere altre linee.
Questo capita quando si annullano alcune modifiche (undo) e poi si fanno modifiche differenti (dal redo).
Queste nuove modifiche generano dei rami nell'albero degli undo.

<p>
Cominciamo col testo "uno".
La prima modifica fatta è aggiungere " sue".
Poi torniamo alla prima 's' e la cambiamo in 'd'.
Abbiamo finora due modifiche, numerate 1 e 2, e tre versioni del testo:
<p>
uno ~ 		 | 	 modifica 1 		 | 	 uno sue~ 		 | 	 modifica 2 		 | 	 uno due ~
<p>
facendo undo una volta si torna a "uno sue", e cambiando "uno" con "cose" si crea un ramo nell'albero degli undo:
<p>
uno ~ 		 | 	 modifica 1 		 | 	 uno sue ~ 	 / \ 	 modifica 2 modifica 3 	 |	 | 	 uno due cose sue ~
<p>
Si può ora usare il comando |u| per fare undo.
Usandolo due volte, si torna a "uno".
Se si usa |CTRL-R| per rifare, si va a "uno sue".
Un ulteriore |CTRL-R|vi porta a "cose sue".
Quindi undo e redo vanno su e giù nell'albero, passando dal percorso utilizzato più recentemente.
<p>
Quel che importa qui è l'ordine in cui le modifiche sono fatte.
Undo e redo non sono considerate modifiche, in questo contesto.
Dopo ogni modifica si forma una nuova versione del testo.

<p>
Note Si noti che sono le modifiche sono numerate, il testo che si vede nell'albero qui sopra non ha alcun identificativo.
I testi sono identificati molto spesso dal numero della modifica sopra di essi.
Talora invece sono identificati dal numero di una delle modifiche che stanno sotto di loro, specie quando ci si muove verso l'alto dell'albero, in modo da sapere quale modifica è stata appena annullata.

<p>
============================================================================== *32.2*	Percorrere la storia delle modifiche
<p>
Come si fa ad arrivare a "uno due" adesso? Potete usare questo comando: >
<p>
:undo 2
<p>
Il testo è ora "uno due", siete sotto la modifica 2.
Si può usare il comando |:undo| per saltare sotto ogni modifica nell'albero.

<p>
Ora fate un'altra modifica: cambiate "uno" in "noi":
<p>
uno ~ 		 | 	 modifica 1 		 | 	 uno sue ~ 	 / \ 	 modifica 2 modifica 3 	 |	 | 	 uno due cose sue ~ 	 | 	 modifica 4 	 | 	 noi due ~
<p>
A questo punto cambiate idea e volete tornare a "uno sue".
Usate il comando |g-|.
Questo comando torna indietro nel tempo.
Ovvero non percorre l'albero verso l'alto o verso il basso, ma percorre le modifiche andando indietro in ordine di tempo.

<p>
Se date più volte il comando |g-| vedrete il testo cambiare così: 	cose sue ~ 	uno due ~ 	uno sue ~ 	uno ~
<p>
Usando |g+| vi muovete invece in avanti nel tempo: 	uno ~ 	uno sue ~ 	uno due ~ 	cose sue ~ 	noi due ~
<p>
Usare |:undo| è utile se sapete a quale modifica volete saltare.
|g-| e |g+| sono utili se non sapete esattamente quale è il numero di una modifica.

<p>
Potete inserire un contatore prima di |g-| e |g+| per eseguirli più volte.

<p>
============================================================================== *32.3*	Viaggiare nel tempo
<p>
Dopo che avete lavorato ad un testo per un po' di tempo, l'albero comincia a diventare grande.
A quel punto potreste voler tornare al testo di alcuni minuti prima.

<p>
Per vedere che rami ci sono nell'albero degli undo, usate questo comando: >
<p>
:undolist <	numero modif.
ora ~ 	 3 2 16 secondi fa 	 4 3 5 secondi fa
<p>
Qui potete vedere il numero di foglie in ogni ramo, e quando è stata fatta la modifica.
Assumendo che siamo sotto la modifica 4, a "noi due", si può tornare indietro di dieci secondi con questo comando:
<p>
:earlier 10s
<p>
A seconda del tempo che avete impiegato a fare le modifiche, vi ritroverete in una certa posizione nell'albero.
L'argomento per il comando |:earlier| può essere espresso com "m" per indicare i minuti, ed "h" per le ore.
Per tornare indietro il più possibile usate un numero grande: >
<p>
:earlier 10h
<p>
Per viaggiare ancora in avanti nel tempo usate il comando |:later|: >
<p>
:later 1m
<p>
Gli argomenti sono "s", "m" e "h", ovvero gli stessi di |:earlier|.

<p>
==============================================================================
<p>
Capitolo seguente: |usr_40.txt| Definire nuovi comandi
<p>
Copyright: vedere |manual-copyright| vim:tw=78:ts=8:ft=help:norl:
<p>
Per segnalazioni scrivere a vimdoc.it at gmail dot com oppure ad Antonio Colombo azc100 at gmail dot com *usr_40.txt*	Per Vim version 7.2.
Ultima modifica: 2006 Giu 21
<p>
VIM USER MANUAL - di Bram Moolenaar 	 Traduzione di questo capitolo: Fabio Teatini e Roberta Fedeli
<p>
Definire nuovi comandi
<p>

<p>
Vim è un elaboratore di testi assai estendibile.
Potete prendere una sequenza di comandi che usate spesso e trasformarla in un nuovo comando.
Oppure potete ridefinire un comando esistente.
Gli "autocomandi" permettono di eseguire dei comandi automaticamente.

<p>
|40.1|	Mappatura dei tasti |40.2|	Definizione di comandi da linea di comando |40.3|	Autocomandi
<p>
Capitolo seguente: |usr_41.txt| Preparare uno script Vim Capitolo precedente: |usr_32.txt| L'albero degli undo 	 Indice: |usr_toc.txt|
<p>
============================================================================== *40.1*	Mappatura dei tasti
<p>
Una semplice mappatura è stata spiegata nella sezione |05.3|.
Il principio è che una sola sequenza di tasti premuti viene tradotta in un'altra sequenza di tasti.
E' un meccanismo semplice, ma potente.
La forma più semplice è che ad un singolo tasto venga attribuito il significato di una sequenza di tasti.
Poiché i tasti funzione, salvo <F1>, non hanno un significato predefinito in Vim, questi sono una buona scelta per definire delle mappature.
Esempio: >
<p>
:map <F2> GoData: <Esc>:read !date<CR>kJ
<p>
Questo mostra come vengano usate tre modalità.
Dopo avere raggiunto l'ultima linea con "G", il comando "o" aggiunge una nuova linea e avvia l'Insert mode.
Il testo "Data: " viene inserito ed <Esc> vi porta fuori dall'Insert mode.
Notate che i tasti speciali sono indicati dentro i caratteri <>.
Ciò viene chiamato notazione delle parentesi angolari.
Scrivete ciò come caratteri separati, non premendo il tasto corrispondente.
Ciò rende la mappatura più leggibile e potrete copiare ed incollare il testo senza problemi.
Il carattere ":" porta Vim sulla linea di comando.
Il comando ":read !date" legge l'output emesso dal comando "date" e lo inserisce sotto la linea corrente.
Il <CR> serve per eseguire il comando ":read".
A questo punto di esecuzione il testo apparirà così:
<p>
Date: ~ 	Fri Jun 15 12:54:34 CEST 2001 ~
<p>
Ora "kJ" sposta il cursore in su e unisce le due linee assieme.
Per decidere quale tasto o tasti usare per la mappatura, vedere |map-which-keys|.

<p>

<p>
MAPPATURA E MODALITA'
<p>
Il comando ":map" effettua la ridefinizione per i tasti in Normal mode.
Potete anche definire mappature per altre modalità.
Per esempio, ":imap" si applica all'Insert mode.
Usatelo per inserire una data sotto il cursore: >
<p>
:imap <F2> <CR>Data: <Esc>:read !date<CR>kJ
<p>
Assomiglia molto alla mappatura per <F2> in Normal mode, soltanto l'inizio è diverso.
La mappatura di <F2> in Normal mode c'è ancora.
Così potete mappare lo stesso tasto diversamente per ciascuna modalità.
Attenzione che sebbene questa mappatura parta in Insert mode, essa finisce in Normal mode.
Se voleste continuare in Insert mode, aggiungete una "a" alla mappatura.

<p>
Ecco un riassunto dei comandi di mappatura ed in quale modalità funzionano:
<p>
:map		Normal, Visual ed Operator-pending 	:vmap		Visual 	:nmap		Normal 	:omap		Operator-pending 	:map!		Insert e Command-line 	:imap		Insert 	:cmap		Command-line
<p>
L'Operator-pending mode è quello in cui vi trovate dopo aver scritto un operatore come "d" o "y" e Vim attende che voi digitiate un comando di movimento od un oggetto di testo.
Quindi, quando digitate "dw", il "w" viene inserito in Operator-pending mode.

<p>
Supponete di voler definire <F7> affinché il comando d<F7> cancelli un blocco di programma C (il testo racchiuso nelle parentesi graffe {}).
Allo stesso modo, y<F7> potrebbe copiare il blocco di programma entro un registro anonimo.
Quindi, ciò che dovete fare è di definire <F7> per selezionare il blocco del programma corrente.
Potete farlo con il seguente comando: >
<p>
:omap <F7> a{
<p>
Ciò fa sì che <F7> selezioni un blocco "a{" in Operator-pending mode, proprio come l'avete scritto.
Questa mappatura è utile qualora sulla vostra tastiera risulti difficile la digitazione di un {.

<p>

<p>
ELENCO DELLE MAPPATURE
<p>
Per vedere le mappature attualmente definite, usate ":map" senza argomenti.
Oppure una delle varianti che comprendono la modalità in cui funzionano.
Il risultato potrebbe apparire così:
<p>
_g		 :call MioGrep(1)<CR> ~ 	v <F2>		 :s/^/> /<CR>:noh<CR>`` ~ 	n <F2>		 :.,$s/^/> /<CR>:noh<CR>`` ~ 	 <xHome>	 <Home> 	 <xEnd>	 <End>
<p>

<p>
La prima colonna dell'elenco mostra in quale modalità la mappatura funzioni.
Questo valore è "n" per il Normal mode, "i" per l'Insert mode, ecc..
Uno spazio viene utilizzato per una mappatura definita con ":map", tanto che funzioni sia in Normal che in Visual mode.
Un utile uso dell'elencare le mappature è di provare se i tasti speciali entro parentesi angolari <> siano stati riconosciuti (ma funziona solo quando il colore sia supportato).
Per esempio, quando <Esc> risulta colorato, sta per il carattere di escape.
Quando ha lo stesso colore dell'altro testo, sono solo cinque caratteri.

<p>

<p>
RE-MAPPING
<p>
Il risultato di una mappatura viene esaminato per le altre mappature in essa.
Per esempio, la mappatura per <F2> illustrata di seguito potrebbe essere abbreviata in: >
<p>
:map <F2> G<F3> 	:imap <F2> <Esc><F3> 	:map <F3> oData: <Esc>:read !date<CR>kJ
<p>
In Normal mode <F2> è associato allo spostamento sull'ultima linea ed allora appare come se <F3> fosse stato premuto.
In Insert mode <F2> arresta l'Insert mode con <Esc> ed allora usa anche <F3>.
Allora <F3> viene mappato per fare questo lavoro.

<p>
Immaginate di dover utilizzare sempre intensamente l'Ex mode, e di voler usare il comando "Q" per formattare del testo (era così nelle vecchie versioni di Vim).
Questa mappatura lo farà: >
<p>
:map Q gq
<p>
Ma, in casi rari dovrete usare il modo Ex comunque.
Mappiamo "gQ" a Q, così da poter andare in Ex mode: >
<p>
:map gQ Q
<p>
Ciò che accade ora è che quando scrivete "gQ" viene mappato in "Q".
Presto e bene.
Ma allora "Q" viene mappato in "gq", così scrivendo "gQ" risulta in "gq", e comunque non potete andare in Ex mode.
Per evitare che dei tasti vengano mappati più volte, usate il comando "noremap": >
<p>
:noremap gQ Q
<p>
Ora Vim sa che "Q" non deve essere impiegato per mappature che gli vengano applicate.
Esiste un comando analogo per qualunque modo: 	 	:noremap	Normal, Visual e Operator-pending 	:vnoremap	Visual 	:nnoremap	Normal 	:onoremap	Operator-pending 	:noremap!	Insert e Command-line 	:inoremap	Insert 	:cnoremap	Command-line
<p>

<p>
MAPPING RICORSIVO
<p>
Se una mappatura puntasse a se stessa potrebbe andare avanti all'infinito.
Ciò può essere usato per ripetere un'azione un numero illimitato di volte.
Ad esempio, avete un elenco di file che contengano nella prima linea un numero di versione.
Potete aprire questi file con "vim *.txt".
Adesso state elaborando il primo file. Definite questa mappatura: >
<p>
:map ,, :s/5.1/5.2/<CR>:wnext<CR>,,
<p>
Adesso scrivete ",,".
Ciò avvia la mappatura.
Cambia "5.1" con "5.2" nella prima linea.
Allora compie un ":wnext" per salvare il file ed aprire il prossimo.
La mappatura finisce con ",,".
Ciò avvia un'altra volta la stessa mappatura, così facendo la sostituzione, etc.
Ciò continua sino a quando vi sia un errore.
In questo caso potrebbe essere un file dove il comando substitute non trovasse una corrispondenza per "5.1".
Potete allora effettuare un cambio per inserire "5.1" e continuare scrivendo ancora una volta ",,".
Ovvero se fallisse ":wnext", perché vi trovate già nell'ultimo file della lista.
Quando una mappatura trova un errore a mezza strada il resto della mappatura viene saltato.
CTRL-C interrompe la mappatura (CTRL-Break su MS-Windows).

<p>

<p>
CANCELLAZIONE DI UNA MAPPATURA
<p>
Per rimuovere una mappatura usate ":unmap ".
Il modo nel quale viene applicata la rimozione delle mappatura dipende dal comando usato:
<p>

<p>
:unmap		Normal, Visual e Operator-pending 	:vunmap		Visual 	:nunmap		Normal 	:ounmap		Operator-pending 	:unmap!		Insert e Command-line 	:iunmap		Insert 	:cunmap		Command-line
<p>
Ecco un trucco per definire una mappatura che lavora in Normal ed Operator-pending mode, ma non in Visual mode.
Prima definitelo per tutti e tre i modi, poi cancellatelo per il Visual mode: >
<p>
:map <C-A> /---><CR> 	:vunmap <C-A>
<p>
Notare che i cinque caratteri "<C-A>" stanno per pressione contemporanea dei tasti CTRL-A.

<p>
Per eliminare tutte le mappature usate il comando |:mapclear|.
Potete così osservare la differenza a seconda dei modi diversi.
Attenzione che questo comando non consente di utilizzare undo.

<p>

<p>
CARATTERI SPECIALI
<p>
Il comando ":map" può essere seguito da un altro comando.
Un carattere | separa i due comandi.
Ciò significa anche che il carattere | non può essere usato entro un comando di mappatura.
Per includerne uno usate <Bar> (cinque caratteri).
Esempio: > 	:map <F8> :write <Bar> !checkin %<CR>
<p>
Lo stesso problema c'è con il comando ":unmap", con l'aggiunta che dovete prestare attenzione a non lasciare uno spazio vuoto.
Questi due comandi sono diversi: > 	:unmap a | unmap b 	:unmap a| unmap b
<p>
Il primo comando prova a cancellare la mappatura di "a ", seguito da uno spazio.

<p>
Per usare uno spazio entro una mappatura scrivete <Space> (sette caratteri): >
<p>
:map <Space> W
<p>
Ciò fa sì che la barra spaziatrice sposti in avanti di una parola separata da uno spazio bianco.

<p>
Non si può mettere un commento dopo una mappatura perché il carattere " verrebbe considerato parte della mappatura.

<p>

<p>
MAPPATURE ED ABBREVIAZIONI
<p>
Le abbreviazioni assomigliano molto a delle mappature in Insert mode.
Gli argomenti vengono gestiti nello stesso modo.
La differenza principale è il modo in cui vengono avviate.
Un'abbreviazione si avvia scrivendo un carattere non parola dopo la parola.
Una mappatura parte dopo aver scritto l'ultimo carattere.
Un'altra differenza è che i caratteri che scrivete per un'abbreviazione vengono inseriti nel testo mentre lo state scrivendo.
Quando l'abbreviazione parte questi caratteri vengono cancellati e sostituiti da ciò che l'abbreviazione produce.
Scrivendo i caratteri per una mappatura non viene inserito nulla sino a quando non scriverete l'ultimo carattere che la fa partire.
Se l'opzione 'showcmd' è impostata, i caratteri che sono stati scritti vengono mostrati nell'ultima riga della finestra di Vim.
Un'eccezione si verifica quando una mappatura è ambigua.
Supponiamo che abbiate fatto due mappature: >
<p>
:imap aa foo 	:imap aaa bar
<p>
Ora, mentre scrivete "aa", Vim non può sapere se deve applicare la prima o la seconda mappatura.
Attende che venga digitato un altro carattere.
Se questo fosse una "a", verrebbe applicata la seconda mappatura e risulterebbe "bar".
Se fosse invece uno spazio, ad esempio, verrebbe applicata la prima mappatura ed il risultato sarebbe "foo", ed allora lo spazio viene inserito.

<p>

<p>
INOLTRE...

<p>
La parola chiave <script> può essere usata per effettuare una mappatura locale ad uno script.
Vedere |:map-<script>|.
<p>
La parola chiave <buffer> può essere usata per effettuare una mappatura locale ad un buffer specifico.
Vedere |:map-<buffer>|
<p>
La parola chiave <unique> può essere usata per ottenere che una mappatura fallisca quando essa già esistesse.
Altrimenti una nuova mappatura sovrascriverebbe la vecchia.
Vedere |:map-<unique>|.
<p>
Per far sì che un tasto venga disattivato, mappatelo con <Nop> (cinque caratteri).
Ciò otterrà che il tasto <F7> venga del tutto disattivato: >
<p>
:map <F7> <Nop>| map! <F7> <Nop>
<p>
Non ci deve essere alcuno spazio dopo <Nop>.

<p>
============================================================================== *40.2*	Definizione di comandi da linea di comando
<p>
L'editor Vim vi consente di definire i vostri comandi.
Eseguirete questi comandi proprio come ogni altro comando nel modo Command-line.
Per definire un comando usate l'istruzione ":command", come segue: >
<p>
:command DeleteFirst 1delete
<p>
Ora quando eseguite il comando ":DeleteFirst" Vim esegue ":1delete", che cancella la prima linea.

<p>
Note: 	I comandi definiti dall'utente debbono iniziare con una lettera 	maiuscola.
Non potete usare ":X", ":Next" e ":Print".
L'underscore 	("_") non può essere usata! Potete usare i numeri, ma ciò viene 	sconsigliato.

<p>
Per elencare i comandi definiti dall'utente eseguite il comando che segue: >
<p>
:command
<p>
Come i comandi originali anche quelli definiti dall'utente possono essere abbreviati.
Dovrete solo digitare quanto basta per distinguere un comando dall'altro.
Il completamento da linea di comandi può essere usato per ottenere l'intero comando.

<p>

<p>
NUMERO DI ARGOMENTI
<p>
I comandi definiti dall'utente supportano diversi argomenti.
Il numero di tali argomenti deve venir specificato nell'opzione -nargs.
Supponiamo che il comando d'esempio :DeleteFirst non preveda argomenti, potreste definirlo come segue: >
<p>
:command -nargs=0 DeleteFirst 1delete
<p>
Comunque poiché il default è zero argomenti, non è necessario che aggiungiate "-nargs=0".
Gli altri valori di -nargs sono come segue:
<p>
-nargs=0	Nessun argomento 	-nargs=1	Un solo argomento 	-nargs=*	Qualsiasi numero di argomenti 	-nargs=?	Zero od uno argomenti 	-nargs=+	Uno o più argomenti
<p>

<p>
USARE GLI ARGOMENTI
<p>
Nella definizione di un comando gli argomenti vengono rappresentati dalla parola chiave <args>.
Ad esempio: >
<p>
:command -nargs=+ Say :echo "<args>"
<p>
Ora scrivendo >
<p>
:Say Hello World
<p>
Vim scriverà a schermo "Hello World".
Comunque aggiungendo virgolette doppie non funzionerebbe.
Ad esempio: >
<p>
:Say he said "hello"
<p>
Per inserire entro una stringa caratteri speciali, opportunamente protetti per usarli come un'espressione usate "<q-args>": >
<p>
:command -nargs=+ Say :echo <q-args>
<p>
Adesso il precedente comando ":Say" verrà correttamente eseguito: >
<p>
:echo "he said \"hello\""
<p>
La parola chiave <f-args> contiene la stessa informazione di <args>, fatta eccezione per un formato da usare come funzione per la chiamata di argomenti.
Ad esempio: >
<p>
:command -nargs=* DoIt :call AFunction(<f-args>) 	:DoIt a b c
<p>
Esegue il comando seguente: >
<p>
:call AFunction("a", "b", "c")
<p>

<p>
INTERVALLO DI LINEE
<p>
Qualche comando prevede un intervallo tra i propri argomenti.
Per dire a Vim che state definendo un comando dovrete specificare l'opzione -range.
I valori per questa opzione sono i seguenti:
<p>
-range		E' ammesso un intervallo; il default è la linea 			attuale.
-range=%	E' ammesso un intervallo; il default è l'intero file.
-range={count}	E' ammesso un intervallo; l'ultimo numero in esso 			viene usato come un unico numero il cui default è 			{count}.

<p>
Quando un intervallo viene specificato le parole chiave <line1> e <line2> danno il numero della prima e dell'ultima linea dell'intervallo.
Ad esempio, il comando seguente definisce il comando SaveIt, che salva l'intervallo di linee specificato entro il file "save_file": >
<p>
:command -range=% SaveIt :<line1>,<line2>write! save_file
<p>

<p>
ALTRE POSSIBILITA'
<p>
Alcune delle altre opzioni sono come segue:
<p>
-count={numero}		Il comando inizia a contare dal valore di 				default {numero}.
Il valore risultante può 				venire usato per mezzo della parola chiave 				<count>.
-bang			Potete usare un !.
Se presente, usando <bang> 				si otterrà un !.
-register		Potete specificare un registro.
(Il default è 				il registro senza nome.) 				La specifica del registro è disponibile come 				<reg> (a.k.a.
<register>).
-complete={tipo}	Tipo di completamento usato dalla linea di 				comando.
Vedere |:command-completion| per 				l'elenco dei valori possibili.
-bar			Il comando può essere seguito da | ed un altro 				comando, oppure " ed un commento.
-buffer			Il comando è disponibile soltanto per il 				buffer corrente.

<p>
In ultimo c'è la parola chiave <lt>.
Sta per il carattere <.
Usatelo per evitare il significato speciale degli elementi menzionati <>.
<p>

<p>
RIDEFINIZIONE E CANCELLAZIONE
<p>
Per ridefinire lo stesso comando usate l'argomento !: >
<p>
:command -nargs=+ Say :echo "<args>" 	:command! -nargs=+ Say :echo <q-args>
<p>
Per cancellare un comando utente impiegate ":delcommand".
Supporta un solo argomento che è il nome del comando.
Esempio: >
<p>
:delcommand SaveIt
<p>
Per cancellare tutti i comandi utente: >
<p>
:comclear
<p>
Attenzione, non si torna indietro!
<p>
Più particolari di ciò nel manuale di riferimento: |user-commands|.

<p>
============================================================================== *40.3*	Autocomandi
<p>
Un autocomando è un comando che viene eseguito automaticamente in risposta ad un dato evento, come un file che venga letto o scritto od una modifica del buffer.
Tramite l'impiego degli autocomandi potete allenare Vim a modificare dei file compressi, ad esempio.
Ciò avviene nel plugin |gzip|.
Gli autocomandi sono molto potenti.
Usateli con cura e vi aiuteranno, evitandovi di scrivere molti comandi.
Usateli con noncuranza e vi daranno un sacco di grattacapi.
<p>
Immaginate di voler modificare la data alla fine di un file ogni volta che esso venga scritto.
Prima definite una funzione: >
<p>
:function DateInsert() 	: $delete 	: read !date 	:endfunction
<p>
Volete che questa funzione venga chiamata sempre, appena prima dopo che un file venga salvato.
Ciò farà sì che avvenga: >
<p>
:autocmd FileWritePre * call DateInsert()
<p>
"FileWritePre" è l'evento tramite il quale viene fatto agire questo comando: Proprio prima di salvare un file.
Il "*" è un modello che fa corrispondere il nome del file.
In questo caso tutti i file corrispondono.
Avendo abilitato questo comando, quando eseguite uno ":write", Vim cerca qualsiasi autocomando che corrisponda con FileWritePre e lo esegue, e allora esegue ":write".
La forma generale del comando :autocmd comando è quella che segue: >
<p>
:autocmd [gruppo] {eventi} {file_pattern} [nested] {comando}
<p>
Il nome [gruppo] è facoltativo.
Viene usato per gestire e chiamare i comandi (maggiori particolari su di ciò più avanti).
Il parametro {eventi} è un elenco di eventi (separati da una virgola) che innescano il comando.
{file_pattern} è il nome di un file, di solito con le wildcard.
Ad esempio, usando "*.txt" fa sì che l'autocomando venga utilizzato con tutti i file il cui nome termini in ".txt".
Il flag facoltativo [nested] consente l'annidamento degli autocomandi (vedere più avanti) ed, in ultimo, {comando} è il comando che dovrà essere eseguito.

<p>
EVENTI
<p>
Uno degli eventi più utili è BufReadPost.
Viene fatto partire dopo che si sia creato un file nuovo.
Viene comunemente usato per impostare valori di opzione.
Ad esempio, sapete che i file "*.gsm" sono in linguaggio assembler GNU.
Per ottenere il giusto file di sintassi, definite questo autocomando: >
<p>
:autocmd BufReadPost *.gsm set filetype=asm
<p>
Se Vim riesce ad identificare il tipo di file, imposterà l'opzione 'filetype' al vostro posto.
Ciò avvia l'evento Filetype.
Impiegatelo per fare qualcosa quando aprite un certo tipo di file.
Ad esempio, per caricare un elenco di abbreviazioni per file di testo: >
<p>
:autocmd Filetype text source ~/.vim/abbrevs.vim
<p>
Aprendo un nuovo file potete fare inserire a Vim uno scheletro: >
<p>
:autocmd BufNewFile *.[ch] 0read ~/skeletons/skel.c
<p>
Vedere |autocmd-events| per un elenco completo degli eventi.

<p>

<p>
ESPRESSIONI
<p>
L'argomento {file_pattern} può essere proprio un elenco di tipi di file separati da una virgola.
Ad esempio: "*.c,*.h" seleziona i file che terminano con ".c" ed ".h".
Potete usare le wildcard usate di solito per i file.
Ecco un esempio di quelle usate più spesso:
<p>
*		Seleziona qualsiasi carattere per qualunque numero di 			volte esso appaia 	?		Seleziona qualsiasi carattere una sola volta 	[abc]		Seleziona il carattere a, b o c 	.		Seleziona un punto 	a{b,c}		Seleziona "ab" ed "ac"
<p>
Se la stringa di ricerca includesse una barra (/) Vim confronterebbe solo nomi di directory.
Senza la barra soltanto l'ultima parte di un nome di file viene usata.
Ad esempio, "*.txt" trova "/home/biep/readme.txt".
Anche la stringa "/home/biep/*" lo selezionerebbe.
Ma "home/foo/*.txt" non lo farebbe.
Includendo una barra, Vim ricerca al stringa sia entro il percorso completo del file ("/home/biep/readme.txt") che entro quello relativo (e.g., "biep/readme.txt").

<p>
Note: 	Se si lavora con un file system che impiega la barra rovesciata per 	separare i file, come MS-Windows, potrete impiegare barre diritte 	negli autocomandi.
Ciò rende più facile scrivere la stringa di 	ricerca, poiché la barra rovesciata ha un significato speciale.
Anche 	ciò rende portatili gli autocomandi.

<p>

<p>
CANCELLAZIONE
<p>
Per cancellare un autocomando usate lo stesso comando di quando lo avete definito, ma tralasciate il {comando} alla fine ed usate un !.
Esempio: >
<p>
:autocmd! FileWritePre *
<p>
Ciò cancellerà tutti gli autocomandi per l'evento "FileWritePre" che impieghino l'elemento "*".

<p>

<p>
ELENCO
<p>
Per elencare tutti gli autocomandi attualmente definiti, usate questo: >
<p>
:autocmd
<p>
La lista può essere lunghissima, specialmente se si usa la determinazione del tipo di file.
Per elencare solo parte dei comandi, specificate il gruppo, l'evento e/o l'elemento.
Ad esempio, per elencare tutti gli autocomandi BufNewFile: >
<p>
:autocmd BufNewFile
<p>
Per elencare tutti gli autocomandi corrispondenti alla stringa di ricerca "*.c": >
<p>
:autocmd * *.c
<p>
Usando "*" per gli eventi elencherà tutti gli eventi.
Per elencare tutti gli autocomandi per il gruppo dei programmi c: >
<p>
:autocmd cprograms
<p>

<p>
GRUPPI
<p>
L'elemento {gruppo}, che usate per definire un autocomando, raggruppa assieme i relativi autocomandi.
Ciò può venir usato per cancellare tutti gli autocomandi appartenenti ad un certo gruppo, ad esempio.
Definendo molti autocomandi per un certo gruppo, usate il comando ":augroup".
Ad esempio, definendo degli autocomandi per dei programmi C: >
<p>
:augroup cprograms 	: autocmd BufReadPost *.c,*.h :set sw=4 sts=4 	: autocmd BufReadPost *.cpp :set sw=3 sts=3 	:augroup END
<p>
Ciò farà lo stesso di: >
<p>
:autocmd cprograms BufReadPost *.c,*.h :set sw=4 sts=4 	:autocmd cprograms BufReadPost *.cpp :set sw=3 sts=3
<p>
Per cancellare tutti gli autocomandi del gruppo "cprograms": >
<p>
:autocmd! cprograms
<p>

<p>
ANNIDAMENTO
<p>
Di solito i comandi eseguiti come risultato di un evento di autocomando non generano a loro volta nuovi eventi.
Se leggeste un file in conseguenza dell'evento FileChangedShell, esso non farà partire gli autocomandi che potessero impostare la sintassi, ad esempio.
Per far sì che gli eventi li facciano partire aggiungete l'argomento "nested": >
<p>
:autocmd FileChangedShell * nested edit
<p>

<p>
L'ESECUZIONE DEGLI AUTOCOMANDI
<p>
E' possibile avviare un autocomando fingendo che un evento sia avvenuto.
Ciò è utile per ottenere che un autocomando ne avvii un altro.
Esempio: >
<p>
:autocmd BufReadPost *.new execute "doautocmd BufReadPost " .
expand("<afile>:r")
<p>
Ciò definisce un autocomando che si avvia quando viene creato un nuovo file.
Il nome del file deve terminare in ".new".
Il comando ":execute" utilizza la valutazione di espressione per creare un nuovo comando ed eseguirlo.
Scrivendo il file "tryout.c.new" il comando eseguito sarà: >
<p>
:doautocmd BufReadPost tryout.c
<p>
La funzione expand() prende l'argomento "<afile>", che sta per il nome del file per cui era stato eseguito l'autocomando, e prende la radice del nome del file con ":r".

<p>
":doautocmd" viene eseguito sul buffer corrente.
Il comando ":doautoall" lavora come "doautocmd" eccetto per il fatto che viene eseguito per tutti i buffers.

<p>

<p>
USARE COMANDI IN MODO NORMALE
<p>
I comandi eseguiti da un autocomando sono comandi a linea di comando.
Se volete usare dei comandi in modalità Normal, potete usare il comando ":normal".
Ad esempio: >
<p>
:autocmd BufReadPost *.log normal G
<p>
Ciò farà saltare il cursore sull'ultima linea dei file *.log quando iniziate a modificarli.
Usare il comando ":normal" è un po' ingannevole.
Prima di tutto accertatevi che il suo argomento sia un comando completo, includente tutti gli argomenti.
Usando "i" per andare nell'Insert mode, ci deve essere anche un <Esc> per uscire ancora dall'Insert mode.
Se usate una "/" per avviare la ricerca di una stringa, ci deve essere un <CR> per eseguirla.
Il comando ":normal" utilizza tutto il testo che lo segue come comandi.
Così non ci può essere alcun | ed un altro comando a seguirlo.
Per lavorare con questo comando metterlo entro un comando ":execute".
Ciò rende possibile anche di passare caratteri non stampabili in modo conveniente.
Esempio: >
<p>
:autocmd BufReadPost *.chg execute "normal ONew entry:\<Esc>" | 		\ 1read !date
<p>
Ciò mostra anche l'utilizzo della barra rovescia per frazionare un lungo comando su più linee.
Si può usare negli script di Vim (non dalla linea di comando).

<p>
Volendo far eseguire agli autocomandi qualcosa di complicato, che comporti di saltare in giro per il file e di tornare poi nella posizione originale, potreste voler ripristinare la vista sul file.
Vedere |restore-position| per un esempio.

<p>

<p>
IGNORARE GLI EVENTI
<p>
A volte non vorrete far partire un autocomando.
L'opzione 'eventignore' contiene un elenco di eventi che saranno totalmente ignorati.
Ad esempio, quanto segue fa sì che vengano ignorati eventi di ingresso e di uscita da una finestra: >
<p>
:set eventignore=WinEnter,WinLeave
<p>
Per ignorare tutti gli eventi usate il comando che segue: >
<p>
:set eventignore=all
<p>
Per ripristinare l'aspetto normale lasciate vuoto 'eventignore': >
<p>
:set eventignore=
<p>
==============================================================================
<p>
Capitolo seguente: |usr_41.txt| Preparare uno script Vim
<p>
Copyright: vedere |manual-copyright| vim:tw=78:ts=8:ft=help:norl:
<p>
Per segnalazioni scrivere a vimdoc.it at gmail dot com oppure ad Antonio Colombo azc100 at gmail dot com *usr_41.txt*	Per Vim version 7.2.
Ultima modifica: 2008 Giu 21
<p>
VIM USER MANUAL - di Bram Moolenaar 		Traduzione di questo capitolo: Antonio Colombo
<p>
Preparare uno script Vim
<p>

<p>
Il linguaggio script di Vim è usato per il file di inizializzazione vimrc, nei file di sintassi, e molto altro.
Questo capitolo spiega gli elementi che possono venir usati in uno script di Vim.
Ce ne sono molti, così questo capitolo è lungo.

<p>
|41.1|	Introduzione |41.2|	Variabili |41.3|	Espressioni |41.4|	Condizioni |41.5|	Esecuzione di una espressione |41.6|	Utilizzo funzioni |41.7|	Definizione funzioni |41.8|	Liste e Dizionari |41.9|	Eccezioni |41.10|	Osservazioni varie |41.11|	Scrivere un plugin |41.12|	Scrivere un plugin per un tipo_file |41.13|	Scrivere un plugin per un compilatore |41.14|	Scrivere un plugin veloce a caricarsi |41.15|	Scrivere librerie di script |41.16|	Distribuzione di script Vim
<p>
Capitolo seguente: |usr_42.txt| Aggiungere nuovi menù Capitolo precedente: |usr_40.txt| Definire nuovi comandi 	 Indice: |usr_toc.txt|
<p>
============================================================================== *41.1*	Introduzione				*vim-script-intro* *script*
<p>
Il vostro primo incontro con gli script di Vim è il file vimrc.
Vim lo legge all'avvio e ne esegue i comandi.
Potete impostare delle opzioni con il valore che preferite, ed usare al suo interno ogni comando che cominci per ":" (questi comandi sono talora designati come comandi Ex o comandi della linea di comando).
Anche i file di sintassi sono degli script Vim.
E lo sono pure i file che impostano opzioni per uno specifico tipo di file.
Una macro complessa può essere definita da un file script di Vim separato.
Potete pensare ad altri usi voi stessi.

<p>
Partiamo da un semplice esempio: >
<p>
:let i = 1 	:while i < 5 	: echo "il contatore è" i 	: let i += 1 	:endwhile < 	Note: 	I ":" non sono obbligatori in questo caso.
Vanno necessariamente 	usati solo se immettete un comando direttamente.
In un file di script 	Vim possono essere omessi.
Noi li useremo comunque, per sottolineare 	che questi sono comandi coi ":" e per distinguerli dai comandi che si 	danno in modo Normal.
Note: 	Potete provare gli esempi copiando (comando yank) le linee da questo 	testo ed eseguendole con :@"
<p>
L'output dell'esempio precedente è:
<p>
il contatore è 1 ~ 	il contatore è 2 ~ 	il contatore è 3 ~ 	il contatore è 4 ~
<p>
Nella prima linea, Il comando ":let" assegna un valore a una variabile.
La forma generale è: >
<p>
:let {variabile} = {espressione}
<p>
In questo caso il nome della variabile è "i" e l'espressione è un valore semplice, il numero 1.
Il comando ":while" inizia un ciclo.
In forma generale: >
<p>
:while {condizione} 	: {comandi} 	:endwhile
<p>
I comandi fino ad ":endwhile" che chiude il ciclo sono eseguiti finché la condizione rimane verificata.
La condizione qui usata è l'espressione "i < 5".
Questa espressione è vera finché la variabile i assume valori inferiori a 5.
Note: 	Se scriveste un ciclo che duri più del previsto, potete interromperlo 	premendo CTRL-C (CTRL-Break in ambiente MS-Windows).

<p>
Il comando ":echo" visualizza gli argomenti che gli vengono passati.
In questo caso la stringa di caratteri "il contatore è" ed il valore della variabile i.
Poiché i vale 1, visualizzerà:
<p>
il contatore è 1 ~
<p>
Poi c'è il comando ":let i += 1".
E' equivalente ad usare ":let i = i+1".
Questo aggiunge 1 alla variabile i ed assegna il nuovo valore alla variabile stessa.

<p>
L'esempio è stato dato per spiegare i comandi, ma se voleste davvero eseguire un simile ciclo, lo si può scrivere in maniera molto più concisa: >
<p>
:for i in range(1, 4) 	: echo "il contatore è" i 	:endfor
<p>
Il funzionamento di |:for| e |range()| verrà spiegato più oltre.
Seguite i puntatori se siete impazienti.

<p>

<p>
TRE TIPI DI NUMERI
<p>
I numeri possono essere decimali, esadecimali od ottali.
Un numero esadecimale inizia con "0x" o con "0X".
Ad esempio "0x1f" è il numero decimale 31.
Un numero ottale inizia con uno 0.
"017" è il numero decimale 15.
Attenzione: non mettete uno zero davanti ad un numero decimale, verrebbe interpretato come un numero ottale! Il comando ":echo" stampa sempre numeri decimali.
Ad es.: >
<p>
:echo 0x7f 036 <	127 30 ~
<p>
Un numero diventa negativo quando è preceduto da un segno "-".
Questo vale anche per numeri esadecimali ed ottali.
Un segno "-" è usato anche per indicare una sottrazione.
Confrontate questo esempio con il precedente: >
<p>
:echo 0x7f -036 <	97 ~
<p>
Gli spazi bianchi in una espressione vengono ignorati.
Comunque se ne raccomanda l'uso per separare gli elementi e rendere l'espressione di più facile lettura.
Per esempio, per evitare nell'esempio la confusione con un numero negativo, mettete un spazio fra il segno "-" e il numero che lo segue: >
<p>
:echo 0x7f - 036
<p>
============================================================================== *41.2*	Variabili
<p>
Un nome di variabile è composto di lettere ASCII, cifre ed il carattere "_".
Il primo carattere del nome non può essere un numero.
Nomi validi di variabile sono:
<p>
contatore 	_aap3 	nome_molto_lungo_di_variabile_con_sottolineature 	LunghezzaFunz 	LUNGHEZZA
<p>
Nomi di variabile non validi sono "pippo+pluto" e "6var".
Queste variabili sono globali [valgono per tutti i buffer di una sessione Vim - NdT].
Per vedere una lista di tutte le variabili correntemente definite usate questo comando: >
<p>
:let
<p>
Potete usare variabili globali in qualsiasi posto.
Questo implica anche che quando la variabile "contatore" è usata in un file di script, potrebbe anche essere usata in un altro file.
Questo porta quanto meno a confusione, od al peggio crea problemi veri.
Per evitarli, potete usare una variabile locale per un file di script, mettendogli come prefisso "s:".
Ad esempio, uno script contiene questi comandi: >
<p>
:let s:contatore = 1 	:while s:contatore < 5 	: source altro.vim 	: let s:contatore += 1 	:endwhile
<p>
Poiché "s:contatore" vale solo per questo script, potete essere certi del fatto che lo script "altro.vim" non ne cambierà il valore.
Se "altro.vim" usa una variabile "s:contatore", si tratterà di una copia diversa, propria di quello script.
Per saperne di più sulle variabili locali ad uno script si veda: |script-variable|.

<p>
Ci sono ulteriori tipi di variabili, si veda |internal-variables|.
Quelle usate più spesso sono:
<p>
b:name		variabile locale propria di un buffer 	w:name		variabile locale propria di una finestra (window) 	g:name		variabile globale (anche in una funzione) 	v:name		variabile predefinita da Vim
<p>

<p>
ANNULLARE VARIABILI
<p>
Le variabili occupano memoria e vengono visualizzate nell'output del comando ":let".
Per cancellare una variabile usate il comando ":unlet". Ad es.: >
<p>
:unlet s:contatore
<p>
Questo cancella la variabile di script locale "s:contatore" e libera la memoria che essa occupava.
Se non siete sicuri dell'esistenza della variabile, e non volete vedere un messaggio di errore nel caso la variabile non esista, aggiungete al comando il "!" >
<p>
:unlet! s:contatore
<p>
Quando uno script Vim termina, le variabili locali che ha usato non saranno annullate automaticamente.
La prossima volta che lo script verrà eseguito, potrà ancora usare il vecchio valore della variabile.
Ad es.: >
<p>
:if !exists("s:contatore_chiamate") 	: let s:contatore_chiamate = 0 	:endif 	:let s:contatore_chiamate = s:contatore_chiamate + 1 	:echo "Chiamato" s:contatore_chiamate "volte"
<p>
La funzione "exists()" controlla l'esistenza di una variabile.
Il suo argomento è il nome della variabile di cui volete controllare l'esistenza.
Non la variabile in sé! Se scriveste: >
<p>
:if !exists(s:contatore_chiamate)
<p>
Allora il valore di s:contatore_chiamate sarebbe usato come nome della variabile la cui esistenza viene controllata da exists().
Questo non è ciò che volete.
Il punto esclamativo ! nega un valore.
Quando il valore della funzione era "vero" (true) diventa "falso" (false).
Quando era "falso" diventa "vero".
Potete leggerlo come la parola "non" (not).
Ossia "if !exists()" si può leggere come "if not exists()", ovvero "se è falso il valore ritornato da exists()".
Vim considera "vero" qualsiasi valore diverso da zero.
Zero è falso.
Note: 	Vim automaticamente converte una stringa in un numero quando sta 	cercando un numero.
Usando una stringa che non comincia con un 	numero, il numero risultante è zero.
Guardando l'esempio seguente: > 		:if "vero" <	Il "vero" verrà interpretato come uno zero, ossia come falso!
<p>
STRINGHE VARIABILI E COSTANTI
<p>
Finora alle variabili sono stati assegnati solo valori numerici.
Si possono usare come valori anche stringhe di caratteri.
Numeri e stringhe sono i tipi fondamentali di costanti che Vim consente.
Il tipo della variabile è dinamico, viene impostato ogni volta che si assegna un valore alla variabile stessa con ":let:".
Per ulteriori informazioni sul tipo di variabile vedere |41.8|.
Per assegnare il valore di una stringa ad una variabile, dovete usare una costante di tipo stringa.
Ne esistono due tipi.
La prima è una stringa di caratteri, racchiusa in doppi apici: >
<p>
:let nome = "pietro" 	:echo nome <	pietro ~
<p>
Se volete inserire un doppio apice all'interno della vostra stringa, metteteci davanti un "\" (backslash, barra retroversa).
>
<p>
:let nome = "\"pietro\"" 	:echo nome <	"pietro" ~
<p>
Per evitare di usare "\", potete racchiudere la stringa fra apici: >
<p>
:let nome = '"pietro"' 	:echo nome <	"pietro" ~
<p>
All'interno di una stringa racchiusa fra apici singoli, tutti i caratteri restano invariati.
Solo l'apice singolo stesso è speciale: ne dovete inserire due per ottenerne uno.
Un "\" viene anch'esso preso alla lettera, così non lo potete usare per cambiare il significato del carattere che lo segue.
Nelle stringhe racchiuse fra doppi apici è possibile usare i caratteri speciali.
Eccone qualcuno utile:
<p>
\t		<Tab> tabulatore 	\n		<NL> a capo 	\r		<CR> <Invio> 	\e		<Esc> escape 	\b		<BS> "cancella un carattere" 	\"		" doppi apici 	\\		\ barra retroversa (backslash) 	\<Esc>		<Esc> escape (forma alternativa) 	\<C-W>		CTRL-W carattere "iniziale" per spostarsi tra finestre
<p>
Gli ultimi due sono solo a titolo di esempio.
La forma "\<nome_car>" si può usare per inserire il carattere speciale "nome_car".
Si veda |expr-quote| per la lista completa degli elementi speciali di una stringa.

<p>
============================================================================== *41.3*	Espressioni
<p>
Vim ha un modo ricco ma semplice per gestire le espressioni.
Potete leggere qui la definizione: |expression-syntax|.
Qui mostreremo gli elementi più comuni.
I numeri, le stringhe e le variabili citate, sono già espressioni.
Così ovunque ci si aspetti un'espressione, potete usare un numero, una stringa od una variabile.
Altri elementi fondamentali in una espressione sono:
<p>
$NOME		variabile d'ambiente 	&nome		opzione 	@r		registro
<p>
Esempio: >
<p>
:echo "Il valore di 'tabstop' è" &ts 	:echo "La tua home directory [Unix] è" $HOME 	:if @a > 5
<p>
La forma &nome si può usare per salvare il valore di una opzione, impostare l'opzione a un nuovo valore, fare qualcosa, e ripristinare il valore precedente.
>
<p>
:let salva = &ic 	:set noic 	:/L'Inizio/,$delete 	:let &ic = save_ic
<p>
Questo serve ad essere certi che l'espressione "L'Inizio" sia usata con l'opzione 'ignorecase' non impostata.
Alla fine, prende il valore che l'utente aveva impostato.
(Un altro modo di fare lo stesso potrebbe essere l'aggiunta di "\C" all'espressione da ricercare, vedere |/\C|.)
<p>

<p>
OPERAZIONI MATEMATICHE
<p>
Diventa più interessante se combiniamo questi elementi fondamentali.
Cominciamo con la operazioni matematiche.

<p>
a + b		addizione 	a - b		sottrazione 	a * b		moltiplicazione 	a / b		divisione 	a % b		modulo (resto della divisione)
<p>
Valgono le solite regole di precedenza.
Ad es.: >
<p>
:echo 10 + 5 * 2 <	20 ~
<p>
Il raggruppamento viene fatto con le parentesi.
Niente sorprese qui. Ad es.: >
<p>
:echo (10 + 5) * 2 <	30 ~
<p>
Le stringhe si possono riunire con ".".
Ad es.: >
<p>
:echo "foo" .
"bar" <	foobar ~
<p>
Quando si danno più argomenti al comando ":echo", questi vengono separati tra loro con uno spazio.
Nell'esempio l'argomento è una singola espressione, così non viene inserito alcuno spazio.

<p>
L'espressione condizionale viene presa dal linguaggio C:
<p>
a ? b : c
<p>
Se "a" è vera, si usa "b", altrimenti si usa "c".
Ad es.: >
<p>
:let i = 4 	:echo i > 5 ? "i è grande" : "i è piccolo" <	i è piccolo ~
<p>
Le tre parti dei costrutti vengono sempre valutate prima, per cui potreste vederle funzionare come:
<p>
(a) ? (b) : (c)
<p>
============================================================================== *41.4*	Condizioni
<p>
Il comando ":if" esegue i comandi che lo seguono, fino all'":endif", solo se la condizione è verificata.
La forma generica è:
<p>
:if {condizione} 	 {comandi} 	:endif
<p>
Solo quando l'espressione {condizione} viene considerata vera (valore diverso da zero) i {comandi} vengono eseguiti.
Questi debbono essere comandi validi.
Se contengono spazzatura, Vim non riesce a trovare l'":endif".
Potete anche usare ":else". La forma generica è:
<p>
:if {condizione} 	 {comandi} 	:else 	 {comandi} 	:endif
<p>
Il secondo {comandi} viene eseguito solo se il primo non lo è.
Infine, abbiamo l'":elseif":
<p>
:if {condizione} 	 {comandi} 	:elseif {condizione} 	 {comandi} 	:endif
<p>
Questo equivale ad usare ":else" e poi "if", ma senza la necessità di inserire un ulteriore ":endif".
Un esempio utile per il vostro file vimrc è verificare l'opzione 'term' e fare qualcosa in funzione del suo valore: >
<p>
:if &term == "xterm" 	: " Fai qualcosa per xterm 	:elseif &term == "vt100" 	: " Fai qualcosa per un terminale vt100 	:else 	: " Fai qualcosa per gli altri tipi di terminale 	:endif
<p>

<p>
OPERAZIONI LOGICHE
<p>
Ne abbiamo già utilizzate alcune negli esempi precedenti.
Quelle di più frequente utilizzo sono:
<p>
a == b		uguale a 	a != b		differente da 	a > b		maggiore di 	a >= b		maggiore o uguale a 	a < b		minore di 	a <= b		minore o uguale a
<p>
Il risultato è 1 se la condizione è verificata, altrimenti è 0.
Ad es.: >
<p>
:if v:version >= 700 	: echo "Congratulazioni" 	:else 	: echo "State usando una vecchia, versione, passate alla nuova!" 	:endif
<p>
Qui "v:version" è una variabile definita da Vim, che assume il valore della versione di Vim.
600 sta per la versione 6.0.
La versione 6.1 ha il valore 6.01.
Questo è molto utile per scrivere uno script che debba funzionare con molte versioni di Vim. |v:version|
<p>
Gli operatori logici lavorano sia con numeri che con stringhe.
Confrontando due stringhe, viene usata la differenza matematica.
Questa confronta il valore dei byte, ma può non andare bene per alcuni linguaggi.
Confrontando una stringa con un numero, la stringa viene prima convertita a numero.
Questo è un po' arbitrario, perché quando una stringa non appare come un numero, viene utilizzato il numero 0.
Ad es.: >
<p>
:if 0 == "uno" 	: echo "sì" 	:endif
<p>
Ciò darà come risultato "sì", poiché "uno" non appare come un numero, e così viene convertito nel numero zero.

<p>
Per le stringhe ci sono due ulteriori elementi;
<p>
a =~ b		corrisponde a 	a !~ b		non corrisponde a
<p>
L'elemento di sinistra "a" viene usato come una stringa.
L'elemento di destra "b" viene usato come espressione, simile a quelle usate per la ricerca.
Ad es.: >
<p>
:if str =~ " " 	: echo "str contiene uno spazio" 	:endif 	:if str !~ '\.$' 	: echo "str non finisce con un punto" 	:endif
<p>
Notate l'uso della stringa inclusa fra apici singoli nell'espressione.
Ciò è utile perché i "\" andrebbero scritti due volte all'interno di una stringa inclusa fra doppi apici, e le espressioni regolari tendono a contenere parecchi "\".

<p>
L'opzione 'ignorecase' viene usata nel confronto tra stringhe.
Se non volete ciò, aggiungete "#" per tener conto di maiuscole e minuscole, e "?" per non farlo.
Così "==?" verifica se due stringhe siano uguali, trascurando maiuscole e minuscole.
E "!~#" controlla se una espressione non corrisponde, controllando anche maiuscole e minuscole.
Per la tabella completa degli operatori, si veda |expr-==|.

<p>

<p>
ALTRI CICLI
<p>
Il comando ":while" è già stato citato.
Ci sono altri due comandi che si possono usare tra ":while" e ":endwhile":
<p>
:continue		Ritorna all'inizio del ciclo "while"; il ciclo 				inizia una nuova iterazione.
:break			Salta in avanti fino a ":endwhile"; il ciclo 				termina l'esecuzione.

<p>
Ad es.: >
<p>
:while contatore < 40 	: call fa_qualche_controllo() 	: if salta_un_giro 	: continue 	: endif 	: if abbiamo_finito 	: break 	: endif 	: sleep 50m 	:endwhile
<p>
Il comando ":sleep" fa fare a Vim un pisolino.
"50m" significa "per cinquanta millisecondi".
Un altro esempio è ":sleep 4", che fa dormire per quattro secondi.

<p>
Altri cicli si possono fare con il comando ":for", vedere più oltre in |41.8|.

<p>
============================================================================== *41.5*	Esecuzione di una espressione
<p>
Finora i comandi nello script venivano eseguiti direttamente da Vim.
Il comando ":execute" permette di eseguire il risultato di una espressione.
È questa una maniera molto potente per costruire comandi ed eseguirli.
Un esempio è per saltare ad un tag, che sia contenuto in una variabile: > 	:execute "tag " .
nome_tag
<p>
Il "." si usa per concatenare la stringa "tag " con il valore della variabile "nome_tag".
Supponiamo che "tag_name" abbia come valore "get_cmd", allora il comando che verrà eseguito è: >
<p>
:tag get_cmd
<p>
Il comando ":execute" può solo eseguire i comandi che iniziano con ":".
Il comando ":normal" esegue i comandi che si possono dare in modo Normal.
Comunque, l'argomento di ":normal" non è una espressione, ma i caratteri del comando letterale.
Ad es.: >
<p>
:normal gg=G
<p>
Questo comando salta alla prima linea e formatta tutte le linee usando l'operatore "=".
Per far funzionare ":normal" con un'espressione, combinatelo con ":execute".
Ad es.: >
<p>
:execute "normal " .
comandi_normali
<p>
La variabile "comandi_normali" deve contenere comandi del modo Normal.
Assicuratevi che l'argomento di ":normal" sia un comando completo.
Altrimenti Vim raggiungerà la fine dell'argomento, ma non eseguirà il comando.
Ad es.
se voi iniziate in modo Insert, dovete anche uscire dal modo Insert.
Ad esempio: >
<p>
:execute "normal Inuovo testo \<Esc>"
<p>
Ciò inserisce "nuovo testo " nella linea corrente.
Si noti l'uso del tasto speciale "\<Esc>".
Ciò evita di dover immettere un vero carattere <Esc> nel vostro script.

<p>
Se non volete eseguire una stringa, ma valutarla per utilizzarne il valore, potete usare la funzione eval(): >
<p>
:let optname = "path" 	:let optval = eval('&' .
optname)
<p>
Un carattere "&" è anteposto a "path", quindi l'argomento di eval() è in questo esempio "&path".
Il risultato sarà quindi il valore della opzione 'path'.
Lo stesso risultato si può ottenere con: > 	:exe 'let optval = &' .
optname
<p>
============================================================================== *41.6*	Utilizzo funzioni
<p>
Vim definisce parecchie funzioni e fornisce un grande numero di funzionalità in questo modo.
Qualche esempio verrà dato in questa sezione.
Potete trovare qui la lista completa: |functions|.
<p>
Una funzione si invoca col comando ":call".
I parametri vengono passati alla funzione fra parentesi, separati da virgole.
Ad es.: >
<p>
:call search("Data: ", "W")
<p>
Questo invoca la funzione search(), con argomenti "Date: " e "W".
La funzione search() usa il proprio primo argomento come una espressione da ricercare e il secondo come un indicatore.
L'indicatore "W" significa che la ricerca non aggiri la fine del file.

<p>
Una funzione può essere invocata all'interno di una espressione.
Ad es.: >
<p>
:let line = getline(".") 	:let repl = substitute(line, '\a', "*", "g") 	:call setline(".", repl)
<p>
La funzione getline() ottiene una linea dal buffer corrente.
Il suo argomento è una specificazione del numero di linea.
In questo caso viene usato "." che significa la linea in cui è posizionato il cursore.
La funzione substitute() fa qualcosa di simile al comando ":substitute".
Il primo argomento è la stringa in cui effettuare la sostituzione.
Il secondo è l'espressione da cercare, il terzo argomento la stringa con cui rimpiazzarla.
Gli ultimi argomenti, per finire, sono indicatori.
La funzione setline() imposta la linea, specificata dal primo argomento, ad una nuova stringa, il secondo argomento.
In questo esempio, la linea sotto il cursore viene rimpiazzata con il risultato della funzione substitute().
Così l'effetto dei tre comandi è uguale a: >
<p>
:substitute/\a/*/g
<p>
L'uso delle funzioni si fa più interessante quando fate più lavoro prima e dopo la invocazione di substitute().

<p>

<p>
FUNZIONI						*function-list*
<p>
Ci sono parecchie funzioni.
Le citiamo qui sotto, raggruppate secondo il loro impiego.
Potete trovare una lista in ordine alfabetico qui: |functions|.
Usate CTRL-] sul nome di funzione per saltare ad una documentazione più dettagliata su di essa.

<p>
Manipolazione di stringhe: 	nr2char()		ottiene un carattere dal suo valore ASCII 	char2nr()		ottiene il valore ASCII di un carattere 	str2nr()		converte una stringa a Numero 	str2float()		converte una stringa a Numero con virgola 	printf()		formatta una stringa secondo elementi % 	escape()		premette '\' a caratteri in una stringa 	shellescape()		protegge una stringa per uso con comando shell 	tr()			traduce caratteri da un assieme all'altro 	strtrans()		modifica una stringa rendendola stampabile 	tolower()		passa una stringa a caratteri minuscoli 	toupper()		passa una stringa a caratteri maiuscoli 	match()			si posiziona ad una espressione in una stringa 	matchend()		si posiziona a fine espressione in una stringa 	matchstr()		trova una espressione in una stringa 	matchlist()		come matchstr() ma opera usando una lista 	stridx()		primo indice ad una stringa in una stringa 	strridx()		ultimo indice ad una stringa in una stringa 	strlen()		lunghezza di una stringa 	substitute()		sostituisce una espressione in una stringa 	submatch()		ottiene un dato valore in una ":substitute" 	strpart()		ottiene una parte di una stringa 	expand()		espande caratteri speciali 	iconv()			converte testo da una codifica a un'altra 	byteidx()		restituisce indice a carattere in una stringa 	repeat()		ripete una stringa più volte 	eval()			ottiene valore di espressione in una stringa
<p>
Manipolazione di Liste: 	get()			ottiene elemento, ignora errori di indice 	len()			numero di elementi in una Lista 	empty()			controlla se una Lista è vuota 	insert()		inserisce elemento in una lista 	add()			aggiunge elemento in fondo a una Lista 	extend()		aggiunge una Lista a una Lista 	remove()		toglie elemento/i da una Lista 	copy()			fa una copia nominale di una Lista 	deepcopy()		fa una copia vera di una Lista 	filter()		toglie elementi scelti da una Lista 	map()			cambia ogni elemento della Lista 	sort()			ordina Lista 	reverse()		ordina all'indietro una Lista 	split()			genera Lista da una Stringa 	join()			congiunge elementi da Lista in una Stringa 	range()			restituisce Lista con una sequenza di numeri 	string()		rappresentazione di una Lista con una Stringa 	call()			chiama una funzione con una Lista per argomenti 	index()			indice di un valore in una Lista 	max()			massimo valore in una Lista 	min()			minimo valore in una Lista 	count()			numero occorrenze di un valore in una Lista 	repeat()		ripete una Lista più volte
<p>
Manipolazione di Dizionari: 	get()			ottiene elemento, ignorando errori di indice 	len()			numero di elementi in un Dizionario 	has_key()		controlla esistenza chiave in un Dizionario 	empty()			controlla se un Dizionario è vuoto 	remove()		toglie elemento da un Dizionario 	extend()		aggiunge elementi di un Dizionario a un altro 	filter()		toglie elementi scelti da un Dizionario 	map()			cambia ogni elemento del Dizionario 	keys()			ottiene Lista di chiavi del Dizionario 	values()		ottiene Lista di valori del Dizionario 	items()			ottiene Lista coppie chiave-valore del Diz.
copy()			fa una copia nominale di un Dizionario 	deepcopy()		fa una copia vera di un Dizionario 	string()		rappresentazione di un Diz.
con una Stringa 	max()			massimo valore in un Dizionario 	min()			minimo valore in un Dizionario 	count()			numero occorrenze di un valore in un Diz.

<p>
Calcoli usando numeri con virgola [Float]: 	float2nr()		converte Numero con virgola a Numero intero 	abs()			valore assoluto (funziona anche per Numero) 	round()			arrotondamento 	ceil()			arrotondamento per eccesso (prossimo intero) 	floor()			arrotondamento per difetto (intero minore) 	trunc()			troncamento delle cifre dopo la virgola 	log10()			logarithm in base 10 	pow()			elevamento a potenza di x all'esponente y 	sqrt()			radice quadrata 	sin()			seno 	cos()			coseno 	atan()			arcotangente
<p>
Variabili: 	type()			tipo di una variabile 	islocked()		controllo se una variabile è non modificabile 	function()		ottiene Funcref per un nome funzione 	getbufvar()		imposta valore variabile da un dato buffer 	setbufvar()		imposta variabile in un dato buffer 	getwinvar()		ottiene variabile da una data finestra 	gettabwinvar()		ottiene variabile da una data fin.
& linguetta 	setwinvar()		imposta variabile in una data finestra 	settabwinvar()		imposta variabile in una data fin.
& linguetta 	garbagecollect()	libera memoria non più usata, se possibile
<p>
Posizione del cursore e del marcatore: 	col()			numero di colonna del cursore o marcatore 	virtcol()		colonna sullo schermo del cursore o marcatore 	line()			numero di linea del cursore o marcatore 	wincol()		numero colonna del cursore nella finestra 	winline()		numero linea del cursore nella finestra 	cursor()		posiziona il cursore a linea/colonna 	getpos()		ottieni posizione cursore, marcatore, etc.
setpos()		imposta posizione cursore, marcatore, etc.
byte2line()		dice a che linea si trova un certo byte 	line2byte()		dice posizione in byte di una data linea 	diff_filler()		ottieni num.
linee riempimento sopra una linea
<p>
Modificare il testo nel buffer corrente: 	getline()		ottiene una linea o Lista linee dal buffer 	setline()		sostituisce una linea nel buffer 	append()		aggiungere una linea o Lista linee al buffer 	indent()		fa rientrare una data linea 	cindent()		fa rientrare una data linea (stile C) 	lispindent()		fa rientrare una data linea (stile Lisp) 	nextnonblank()		trova la prossima linea non vuota 	prevnonblank()		trova la linea non vuota precedente 	search()		trova una espressione nel testo 	searchpos()		trova una espressione nel testo 	searchpair()		trova l'altro capo, di start/skip/end 	searchpairpos()		trova l'altro capo, di start/skip/end 	searchdecl()		cerca la dichiarazione di un nome
<p>
Funzioni di sistema e manipolazione di file: 	glob()			valorizza espressioni regolari (wildcard) 	globpath()		valorizza espressione lista-di-directory 	findfile()		trova un file in una lista di directory 	finddir()		trova una directory in una lista di direct.
resolve()		trova nome file dato puntatore (shortcut) 	fnamemodify()		modifica nome file 	pathshorten()		accorcia nomi directory in un path 	simplify()		semplifica un path senza cambiarne il valore 	executable()		controlla esistenza programma eseguibile 	filereadable()		controlla se possibile leggere un file 	filewritable()		controlla se possibile scrivere un file 	getfperm()		ottiene permessi utilizzo di un file 	getftype()		ottiene il tipo di un file 	isdirectory()		controlla se una data directory esiste 	getfsize()		ottiene lunghezza di un file 	getcwd()		ottiene directory di lavoro corrente 	haslocaldir()		controlla la finestra corrente ha usato |:lcd| 	tempname()		ottiene nome di un file temporaneo 	mkdir()			crea una nuova directory 	delete()		cancella un file 	rename()		rinomina un file 	system()		ottiene codice ritorno da comando shell 	hostname()		ottiene nome del computer 	readfile()		legge un file in una Lista linee 	writefile()		scrive una Lista linee su un file
<p>
Data e Ora: 	getftime()		ottiene data ultima modifica di un file 	localtime()		ottiene la data corrente 	strftime()		converte una data in formato stampabile 	reltime()		ottiene accurato tempo corrente o trascorso 	reltimestr()		converte risultati reltime() in stringa
<p>
Buffer, finestre e lista argomenti: 	argc()			numero argomenti nella lista argomenti 	argidx()		posizionamento corrente nella lista argomenti 	argv()			ottiene un argomento dalla lista argomenti 	bufexists()		controlla se un buffer esiste 	buflisted()		controlla se un buffer esiste ed è listato 	bufloaded()		controlla se un buffer esiste ed è caricato 	bufname()		ottiene nome di un dato buffer 	bufnr()			ottiene numero buffer di un dato buffer 	tabpagebuflist()	ottiene Lista di buffer in una linguetta 	tabpagenr()		ottiene il numero di una linguetta 	tabpagewinnr()		come winnr() per una data linguetta 	winnr()			ottiene numero finestra di finestra corrente 	bufwinnr()		ottiene numero finestra di un dato buffer 	winbufnr()		ottiene numero buffer di una data finestra 	getbufline()		ottiene una lista di linee da un dato buffer
<p>
Linea comando: 	getcmdline()		ottieni la linea comando corrente 	getcmdpos()		ottieni posizione cursore su linea comando 	setcmdpos()		imposta posizione cursore su linea comando 	getcmdtype()		ottiene il tipo della linea comando corrente
<p>
Quickfix e lista locazione: 	getqflist()		ottiene lista errori quickfix 	setqflist()		modifica una lista quickfix 	getloclist()		ottiene lista elementi locazione 	setloclist()		modifica lista elementi locazione
<p>
Completamento in modalità Insert: 	complete()		imposta corrispondenze trovate 	complete_add()		aggiungi a corrispondenze trovate 	complete_check()	controlla se completamento va interrotto 	pumvisible()		controlla se il menù popup è visualizzato
<p>
Piegature: 	foldclosed()	controlla se piegatura chiusa in una linea data 	foldclosedend()		come foldclosed() ma restituisce ultima linea 	foldlevel()		controlla livello piegatura in una linea data 	foldtext()		specifiche linea che indica piegatura chiusa 	foldtextresult()	ottieni testo visualizzato in piegatura chiusa
<p>
Sintassi ed evidenziazione: 	clearmatches()		annulla tutte le corrispondenze definite dai 				comandi |matchadd()| e |:match| 	getmatches()		ottiene tutte le corrispondenze definite dai 				comandi |matchadd()| e |:match| 	hlexists()		controlla se esiste gruppo evidenziazione 	hlID()			ottieni ID di un gruppo evidenziazione 	synID()			ottieni ID sintattico ad una data posizione 	synIDattr()		ottieni un dato attributo di un ID sintattico 	synIDtrans()		ottieni traduzione di un ID sintattico 	diff_hlID()		ottieni ID evidenz.
modo diff in una posizione 	matchadd()		definisce espressione regolare da evidenziare 				(un "match", ossia una corrispondenza) 	matcharg()		ottieni informazioni su argomenti |:match| 	matchdelete()		annulla una corrispondenza definita dai 				comandi |matchadd()| o |:match| 	setmatches()		ripristina una lista di corrispondenze salvata 				da |getmatches()|
<p>
Controllo ortografico: 	spellbadword()		trova parole errate al cursore od oltre 	spellsuggest()		ottieni correzioni ortografiche suggerite 	soundfold()		ottiene parole di suono simile a una parola
<p>
Storia: 	histadd()		aggiunge un elemento a una storia 	histdel()		toglie un elemento a una storia 	histget()		ottiene un elemento da una storia 	histnr()		ottiene indice più alto di una storia
<p>
Interazione: 	browse()		richiedi file da visualizzare 	browsedir()		richiedi directory da visualizzare 	confirm()		chiede all'utente di fare una scelta 	getchar()		ottiene un carattere dall'utente 	getcharmod()		ottiene modificatori ultimo carattere immesso 	feedkeys()		mette caratteri nella coda dei caratteri 				immessi (ma non ancora trattati) [typeahead 				queue] 	input()			ottiene una linea dall'utente 	inputlist()		fa scegliere all'utente elemento in una Lista 	inputsecret()		ottiene una linea dall'utente senza mostrarla 	inputdialog()		ottiene una linea dall'utente usando GUI 	inputsave()		salva caratteri immessi e pulisce 	inputrestore()		ripristina caratteri immessi
<p>
GUI: 	getfontname()		ottieni nome font attualmente in uso 	getwinposx()		posizione X della finestra GUI Vim 	getwinposy()		posizione Y della finestra GUI Vim
<p>
Vim server: 	serverlist()		restituisce lista nomi server 	remote_send()		invia caratteri comando a server Vim 	remote_expr()		valuta una espressione in un server Vim 	server2client()		invia risposta a un cliente di un server Vim 	remote_peek()		controlla se esiste risposta da un server Vim 	remote_read()		legge risposta da Vim server 	foreground()		sposta finestra Vim in primo piano 	remote_foreground()	sposta finestra server Vim in primo piano
<p>
Posizione e dimensioni finestra: 	winheight()		ottieni altezza di una data finestra 	winwidth()		ottieni larghezza di una data finestra 	winrestcmd()		ottieni comando per ripristinare dimens.
fin.
winsaveview()		ottieni veduta della finestra corrente 	winrestview()		ripristina vista salvata d.
finestra corrente
<p>
Varie: 	type()			restituisce il tipo di una variabile 	mode()			ottiene modalità di edit corrente 	visualmode()		dice ultima modalità visuale utilizzata 	hasmapto()		controlla se esiste mappatura 	mapcheck()		controlla se esiste mappatura corrispondente 	maparg()		ottiene valore di una mappatura 	exists()		controlla se variabile, funzione, etc.
esiste 	has()			controlla se Vim supporta una estensione data 	changenr()		ottieni numero della modifica più recente 	cscope_connection()	controlla se esiste una connessione cscope 	did_filetype()		controlla se già usato autocomando tipo_file 	eventhandler()		controlla se invocato da un gestore eventi 	getpid()		ottiene identificativo di processo of Vim
<p>
libcall()		richiama una funzione in una libreria esterna 	libcallnr()		come sopra, la funzione restituisce un numero
<p>
getreg()		ottieni contenuto di un registro 	getregtype()		ottieni tipo di un registro 	setqflist()		crea una Lista quickfix 	setreg()		imposta contenuto e tipo di un registro
<p>
taglist()		ottieni Lista di tag corrispondenti 	tagfiles()		ottieni Lista di file di tag
<p>
============================================================================== *41.7*	Definizione funzioni
<p>
Vim vi consente di definire le proprie funzioni.
La dichiarazione di una funzione comincia così: >
<p>
:function {nome}({var1}, {var2}, ...) 	: {corpo_della_funzione} 	:endfunction < 	Note: 	I nomi di funzione devono cominciare con una lettera maiuscola.

<p>
Definiamo una breve funzione che restituisce il minore di due numeri.
Comincia con questa linea:
<p>
:function Min(num1, num2)
<p>
Ciò dice a Vim che la funzione si chiama "Min" ed ha due argomenti: "num1" e "num2".
La prima cosa di cui avete bisogno è di tentare di vedere quale numero sia il più piccolo: > 	: if a:num1 < a:num2
<p>
Il prefisso speciale "a:" dice a Vim che la variabile è un argomento della funzione.
Assegniamo alla variabile "minore", il valore del numero più piccolo: >
<p>
: if a:num1 < a:num2 	: let minore = a:num1 	: else 	: let minore = a:num2 	: endif
<p>
La variabile "minore" è una variabile locale.
Variabili usate all'interno di una funzione sono locali se non hanno prefissi come "g:", "a:", o "s:".

<p>
Note: 	Per accedere ad una variabile globale dall'interno di una funzione 	dovete premettere "g:" alla variabile stessa.
Così "g:giorno" 	all'interno di una funzione viene usato per la variabile globale 	"giorno", mentre "giorno" è un'altra variabile, locale alla 	funzione.

<p>
Usate il comando ":return" per restituire il numero più piccolo all'utente.
Infine, indicate la fine della funzione: >
<p>
: return minore 	:endfunction
<p>
La definizione completa della funzione è la seguente: >
<p>
:function Min(num1, num2) 	: if a:num1 < a:num2 	: let minore = a:num1 	: else 	: let minore = a:num2 	: endif 	: return minore 	:endfunction
<p>
Se preferite funzioni concise, questa fa la stessa cosa: >
<p>
:function Min(num1, num2) 	: if a:num1 < a:num2 	: return a:num1 	: endif 	: return a:num2 	:endfunction < Una funzione definita dall'utente viene invocata esattamente nello stesso modo con cui vengono invocate le funzioni predefinite di Vim.
Solo il nome è diverso.
La funzione Min si può usare così: >
<p>
:echo Min(5, 8)
<p>
Solo adesso la funzione verrà eseguita, e le linee saranno interpretate da Vim.
Se ci sono errori, come usare una variabile o una funzione indefinite, si otterrà un messaggio di errore.
Quando si definisce una funzione, errori di questo tipo non vengono rilevati.

<p>
Quando una funzione trova ":endfunction" o se ":return" viene usato senza un argomento, la funzione restituisce zero.

<p>
Per ridefinire una funzione già esistente, usate il "!" nel comando ":function": >
<p>
:function! Min(num1, num2, num3)
<p>

<p>
USARE UN INTERVALLO
<p>
Al comando ":call" si può dare un intervallo di linee su cui agire.
Ciò può avere uno o due significati.
Quando una funzione è stata definita con la parola chiave "range", terrà conto dell'intervallo di linee stesso.
Alla funzione verranno passate le variabili "a:firstline" e "a:lastline".
Queste avranno i numeri di linea dall'intervallo in cui la funzione è stata chiamata.
Ad es: >
<p>
:function Conta_parole() range 	: let numero_linea = a:firstline 	: let n = 0 	: while numero_linea <= a:lastline 	: let n = n + len(split(getline(numero_linea))) 	: let numero_linea = numero_linea + 1 	: endwhile 	: echo "trovate " .
n .
" parole" 	:endfunction
<p>
Potete chiamare questa funzione con: >
<p>
:10,30call Conta_parole()
<p>
Verrà eseguita una volta sola, e scriverà il numero di parole.
L'altro modo per usare un intervallo di linee consiste nel definire una funzione senza la parola chiave "range".
La funzione sarà chiamata una volta per ogni linea nell'intervallo, con il cursore posizionato su quella linea.
Ad es.: >
<p>
:function Numero() 	: echo "La linea numero " .
line(".") .
" contiene: " . getline(".") 	:endfunction
<p>
Se chiamate questa funzione con: >
<p>
:10,15call Numero()
<p>
la funzione verrà invocata sei volte.

<p>

<p>
NUMERO VARIABILE DI ARGOMENTI
<p>
Vim vi consente di definire funzione che abbia un numero variabile di argomenti.
Il comando seguente, ad es., definisce una funzione che deve avere almeno 1 argomento (inizio) e può avere più di 20 argomenti in aggiunta al primo: >
<p>
:function Mostra(inizio, ...)
<p>
La variabile "a:1" contiene il primo argomento facoltativo, "a:2" il secondo, e così via.
La variabile "a:0" contiene il numero di argomenti aggiuntivi.
Ad es.: >
<p>
:function Mostra(inizio, ...) 	: echohl Title 	: echo "Mostra è " .
a:inizio 	: echohl None 	: let indice = 1 	: while indice <= a:0 	: echo " Arg " .
indice .
" è " .
a:{index} 	: let indice = indice + 1 	: endwhile 	: echo "" 	:endfunction
<p>
La funzione usa il comando ":echohl" per specificare l'evidenziazione da usare per il successivo comando ":echo".
":echohl None" torna alla visualizzazione normale.
Il comando ":echon" si comporta come ":echo", ma non scrive il carattere per andare a capo.

<p>
Si può anche usare la variabile a:000, che è una Lista di tutti gli argomenti "...".
Vedere |a:000|.
<p>

<p>
LISTA DELLE FUNZIONI
<p>
Il comando ":function" lista i nomi e gli argomenti di tutte le funzioni definite dall'utente: >
<p>
:function <	function Show(start, ...) ~ 	function GetVimIndent() ~ 	function SetSyn(name) ~
<p>
Per vedere cosa fa una funzione, usate il suo nome come argomento per ":function": >
<p>
:function SetSyn <	1 if &syntax == '' ~ 	2 let &syntax = a:name ~ 	3 endif ~ 	 endfunction ~
<p>

<p>
DEBUGGING
<p>
Il numero linea è utile quando ricevete un messaggio di errore o in fase di debug.
Si veda |debug-scripts| a proposito del debug.
Potete anche impostare l'opzione 'verbose' a 12 o più per vedere tutte le chiamate di funzione.
Impostatelo a 15 o più per visualizzare ogni linea eseguita.

<p>

<p>
CANCELLARE UNA FUNZIONE
<p>
Per cancellare la funzione Mostra(): >
<p>
:delfunction Mostra
<p>
Se la funzione non esiste, viene visualizzato un messaggio di errore.

<p>
REFERENZE A FUNZIONI
<p>
Talvolta può servire che una variabile punti a una funzione o a un'altra.
Si può fare con la funzione function().
Cambia il nome di una funzione in una referenza: >
<p>
:let result = 0		" o 1 	:function! Right() 	: return 'Right!' 	:endfunc 	:function! Wrong() 	: return 'Wrong!' 	:endfunc 	: 	:if result == 1 	: let Afunc = function('Right') 	:else 	: let Afunc = function('Wrong') 	:endif 	:echo call(Afunc, []) <	Wrong! ~
<p>
Note Il nome di una variabile che contiene una referenza a una funziona deve iniziare con una lettera maiuscola.
Altrimenti potrebbe essere confusa col nome di una funzione predefinita.
La maniera per far eseguire una funzione il cui nome è contenuto in una variabile è quello di usare la funzione call().
Il suo primo argomento è la referenza alla funzione, il secondo argomento è una Lista che contiene gli argomenti.

<p>
Riferimenti a funzioni sono molto utili utilizzando un Dizionario, come viene spiegato nella sezione che segue.

<p>
============================================================================== *41.8*	Liste e Dizionari
<p>
Finora abbiamo usato i tipi fondamentali di variabili, Stringhe e Numeri.
Vim permette anche due tipi composti: Liste e Dizionari.

<p>
Una Lista è una sequenza ordinata di cose.
Le cose possono essere ogni tipo di valore, quindi si può fare una Lista di numeri, una lista di Liste e perfino una lista di elementi differenti.
Per creare una lista con tre stringhe: >
<p>
:let alist = ['aap', 'mies', 'noot']
<p>
Gli elementi della lista sono rinchiusi fra parentesi quadre e separati da virgole.
Per creare una Lista vuota: >
<p>
:let alist = []
<p>
Potere aggiungere elementi a una lista con la funziona add(); >
<p>
:let alist = [] 	:call add(alist, 'foo') 	:call add(alist, 'bar') 	:echo alist <	['foo', 'bar'] ~
<p>
La concatenazione di elementi ad una lista si fa col +: >
<p>
:echo alist + ['foo', 'bar'] <	['foo', 'bar', 'foo', 'bar'] ~
<p>
O, se volete estendere una Lista direttamente: >
<p>
:let alist = ['one'] 	:call extend(alist, ['two', 'three']) 	:echo alist <	['one', 'two', 'three'] ~
<p>
Si noti che usando add() si ottiene un risultato diverso: >
<p>
:let alist = ['one'] 	:call add(alist, ['two', 'three']) 	:echo alist <	['one', ['two', 'three']] ~
<p>
Il secondo argomenti di add() è aggiunto come un elemento singolo.

<p>

<p>
CICLO FOR
<p>
Una delle cose carine che si possono fare con una Lista è visitarla: >
<p>
:let alist = ['one', 'two', 'three'] 	:for n in alist 	: echo n 	:endfor <	one ~ 	two ~ 	three ~
<p>
In questo modo si passa attraverso ogni elemento della Lista "alist", assegnandone il valore alla variabile "n".
La forma generica di un ciclo for è >
<p>
:for {nome_variabile} in {designazione_di_Lista} 	: {comandi} 	:endfor
<p>
Per visitare la lista un dato numero di volte vi serve una Lista di una lunghezza specifica.
La funzione range() ne crea una per voi: >
<p>
:for a in range(3) 	: echo a 	:endfor <	0 ~ 	1 ~ 	2 ~
<p>
Si noti che il primo elemento della Lista prodotta da range() è zero, quindi l'ultimo elemento è inferiore di uno alla lunghezza della lista.
Potete anche specificare il valore massimo, l'incremento, e pure andare "all'indietro": >
<p>
:for a in range(8, 4, -2) 	: echo a 	:endfor <	8 ~ 	6 ~ 	4 ~
<p>
Un esempio più utile, che percorre le linee di un buffer: >
<p>
:for line in getline(1, 20) 	: if line =~ "Date: " 	: echo matchstr(line, 'Date: \zs.*') 	: endif 	:endfor
<p>
Si esaminano qui le linee da 1 a 20 (incluso) visualizzando ogni data trovata.

<p>

<p>
DIZIONARI
<p>
Un Dizionario contiene coppie chiave-valore.
Potete velocemente consultare un Dizionario se conoscete la chiave.
Un Dizionario è creato fra parentesi graffe:
<p>
:let uk2nl = {'one': 'een', 'two': 'twee', 'three': 'drie'}
<p>
Ora potete consultare elementi (parole) mettendo la chiave fra parentesi quadre: >
<p>
:echo uk2nl['two'] <	twee ~
<p>
La forma generica di definizione di un Dizionario è: >
<p>
{<chiave> : <valore>, ...}
<p>
Un Dizionario vuoto non contiene alcuna chiave: >
<p>
{}
<p>
Numerose sono le possibilità offerte dai Dizionari.
Ci sono anche varie funzioni che si possono utilizzare con essi.
Ad esempio, potete ottenere una lista delle chiavi e visitarla: >
<p>
:for key in keys(uk2nl) 	: echo key 	:endfor <	three ~ 	one ~ 	two ~
<p>
Noterete che le chiavi non sono in ordine.
Potete ottenere la lista in un ordine da voi specificato: >
<p>
:for key in sort(keys(uk2nl)) 	: echo key 	:endfor <	one ~ 	three ~ 	two ~
<p>
Non c'è modo di ottenere l'ordine nel quale gli elementi sono stati introdotti.
A questo scopo è necessario utilizzare una Lista, che memorizza gli elementi in una sequenza ordinata.

<p>

<p>
FUNZIONI DEI DIZIONARI
<p>
Gli elementi in un Dizionario di ottengono di solito fornendo un indice fra parentesi quadre: >
<p>
:echo uk2nl['one'] <	een ~
<p>
Per ottenere lo stesso risultato, usando meno segni di interpunzione: >
<p>
:echo uk2nl.one <	een ~
<p>
Questa notazione funziona solo se la chiave è composta da lettere ASCII, numeri e dal carattere "_" (underscore).
Potete anche assegnare valori allo stesso modo: >
<p>
:let uk2nl.four = 'vier' 	:echo uk2nl <	{'three': 'drie', 'four': 'vier', 'one': 'een', 'two': 'twee'} ~
<p>
E ora qualcosa di speciale: potete definire direttamente una funzione ed inserire una referenza a quella funzione nel Dizionario: >
<p>
:function uk2nl.translate(line) dict 	: return join(map(split(a:line), 'get(self, v:val, "???")')) 	:endfunction
<p>
Cominciamo a provarla: >
<p>
:echo uk2nl.translate('three two five one') <	drie twee ??? een ~
<p>
La prima cosa speciale che si nota è il "dict" alla fine della linea ":function".
Questo segnala che la funzione è usata da un Dizionario.
La variabile locale "self" farà riferimento a quel Dizionario.
Ora spezziamo il complesso comando che genera il risultato: >
<p>
split(a:line)
<p>
La funzione split() piglia una stringa, la spezza in parole separate da spazi e restituisce una lista delle parole così ottenute.
Quindi nell'esempio restituisce: >
<p>
:echo split('three two five one') <	['three', 'two', 'five', 'one'] ~
<p>
Questa lista è il primo argomento alla funzione map().
map() visiterà la lista, valutando il suo secondo argomento con la variabile "v:val" impostata al valore di ogni elemento.
Si tratta della scrittura abbreviata di un ciclo "for".
Questo comando: >
<p>
:let alist = map(split(a:line), 'get(self, v:val, "???")')
<p>
è equivalente a: >
<p>
:let alist = split(a:line) 	:for idx in range(len(alist)) 	: let alist[idx] = get(self, alist[idx], "???") 	:endfor
<p>
La funzione get() controlla se una chiave è presente in un Dizionario.
Se esiste, ne ritrova il valore.
Se non esiste, restituisce un valore di default, '???' in questo caso.
E' questa una maniera comoda per gestire situazioni in cui una chiave può non essere presente, e non si desidera un messaggio di errore.

<p>
La funzione join() fa il lavoro inverso respetto a split(): unisce assieme una lista di parole, mettendo uno spazio fra ognuna di esse.
Questa combinazione di split(), map() e join() è una maniera elegante di filtrare una linea di parole in maniera molto concisa.

<p>

<p>
PROGRAMMAZIONE ORIENTATA AGLI OGGETTI
<p>
Ora che potete inserire sia valori che funzioni in un Dizionario, potete in pratica utilizzare un Dizionario come un oggetto.
Sopra abbiamo usato un Dizionario per tradurre da Olandese a Inglese.
Potremmo voler fare lo stesso per altri linguaggi.
Creiamo prima un oggetto (noto anche come Dizionario) che abbia la funzione di traduzione, ma senza parole da tradurre: >
<p>
:let transdict = {} 	:function transdict.translate(line) dict 	: return join(map(split(a:line), 'get(self.words, v:val, "???")')) 	:endfunction
<p>
E' lievemente differente dalla funzione di prima, usa 'self.words' per consultare le traduzioni delle parole.
Ma noi non abbiamo un 'self.words'.
Quindi la si potrebbe definire una classe astratta.
<p>
Ora possiamo realizzare un oggetto che traduca in Olandese: >
<p>
:let uk2nl = copy(transdict) 	:let uk2nl.words = {'one': 'een', 'two': 'twee', 'three': 'drie'} 	:echo uk2nl.translate('three one') <	drie een ~
<p>
E un traduttore in Tedesco: >
<p>
:let uk2de = copy(transdict) 	:let uk2de.words = {'one': 'ein', 'two': 'zwei', 'three': 'drei'} 	:echo uk2de.translate('three one') <	drei ein ~
<p>
Potete vedere che la funzione copy() è usata per fare una copia del dizionario "transdict" e quindi la copia è modificata per aggiunger le parole.
L'originale resta immutato, naturalmente.

<p>
Ora potete far un passo ulteriore, e usare il vostro traduttore preferito: >
<p>
:if $LANG =~ "de" 	: let trans = uk2de 	:else 	: let trans = uk2nl 	:endif 	:echo trans.translate('one two three') <	een twee drie ~
<p>
Qui "trans" fa riferimento a uno dei due oggetti (Dizionari).
Nessuna copia è qui fatta.
Ulteriori informazioni su Liste e Dizionari può essere trovata a |list-identity| e |dict-identity|.

<p>
Ora potreste usare un linguaggio non supportato.
Potete forzare la funzione translate() a non fare alcunché: >
<p>
:let uk2uk = copy(transdict) 	:function! uk2uk.translate(line) 	: return a:line 	:endfunction 	:echo uk2uk.translate('three one wladiwostok') <	three one wladiwostok ~
<p>
SI noti che un ! è stato usato per ricoprire il riferimento a una funzione esistente.
A questo punto usate "uk2uk" quando il linguaggio non viene riconosciuto: >
<p>
:if $LANG =~ "de" 	: let trans = uk2de 	:elseif $LANG =~ "nl" 	: let trans = uk2nl 	:else 	: let trans = uk2uk 	:endif 	:echo trans.translate('one two three') <	one two three ~
<p>
Per ulteriori letture vedere |Lists| e |Dictionaries|.

<p>
============================================================================== *41.9*	Eccezioni
<p>
Cominciamo con un esempio: >
<p>
:try 	: read ~/templates/pascal.tmpl 	:catch /E484:/ 	: echo "Spiacente, il file_modello Pascal non è disponibile." 	:endtry
<p>
Il comando ":read" non può essere eseguito se il file non esiste.
Invece di lasciar visualizzare un messaggio di errore, questo codice cattura l'errore e dà all'utente un messaggio più comprensibile.

<p>
Per i comandi compresi fra ":try" e ":endtry" gli errori sono trasformati in eccezioni.
Una eccezione è una stringa di caratteri.
Nel caso di un errore la stringa contiene il messaggio di errore.
E ogni messaggio di errore ha un identificativo di messaggio.
In questo caso, l'errore che intercettiamo contiene l'identificativo "E484:".
Questo identificativo è una costante (il testo del messaggio può variare, ad es. può essere tradotto).
<p>
Quando il comando ":read" genera un altro errore, la stringa "E484:" non sarà contenuta nel messaggio di errore.
Ragion per cui questa eccezione non sarà intercettata, e quindi riceveremo il relativo messaggio di errore.

<p>
Si potrebbe essere tentati di scrivere: >
<p>
:try 	: read ~/templates/pascal.tmpl 	:catch 	: echo "Spiacente, il file modello Pascal non è disponibile." 	:endtry
<p>
Così si intercettano tutti gli errori.
In questo modo però non si vedono errori "utili" tipo: "E21: Non posso fare modifiche, 'modifiable' è inibito"
<p>
Un altro meccanismo utile è il comando ":finally": >
<p>
:let tmp = tempname() 	:try 	: exe ".,$write " .
tmp 	: exe "!filter " .
tmp 	: .,$delete 	: exe "$read " .
tmp 	:finally 	: call delete(tmp) 	:endtry
<p>
Questo script Vim fa passare le linee dal cursore fino alla fine del file attraverso il comando "filter", che ha come argomento un nome di file.
Sia che il filtro funzioni, sia se qualche errore accade tra ":try" e ":finally" o l'utente cancella l'operazione di filtro premendo CTRL-C, la chiamata "call delete(tmp)" è eseguita sempre.
Questo consente di essere sicuri di non lasciarsi dietro file temporanei di lavoro.

<p>
Maggiore informazione a riguardo della gestione eccezioni si trova nel manuale: |exception-handling|.

<p>
============================================================================== *41.10*	Osservazioni varie
<p>
Diamo qui una serie di osservazioni relative agli script Vim.
Sono spiegate anche altrove, ma sono qui riunite per convenienza.

<p>
Il carattere di fine linea dipende dal sistema operativo.
Per Unix si usa un solo carattere <NL>.
Per MS-DOS, Windows, OS/2 etc.
si usa, <CR><LF>.
Questo è importante quando si usano mappature che finiscono con <CR>. Si veda |:source_crnl|.
<p>

<p>
SPAZI BIANCHI
<p>
Linee bianche possono essere inserite dappertutto, e vengono ignorate.

<p>
Spazi bianchi prima di un testo (spazi e/o TAB) sono sempre ignorati.
Gli spazi bianchi fra parametri (ad es.
tra il 'set' e 'cpoptions' nell'esempio qui sotto) sono ridotti ad un unico spazio, che serve da separatore.
Gli spazi bianchi dopo l'ultimo carattere (visibile) possono essere ignorati oppure no, a seconda della situazione.
Si veda sotto.
<p>
Per un comando ":set" che usa il segno "=" (uguale), tipo: >
<p>
:set cpoptions =aABceFst
<p>
lo spazio bianco subito PRIMA del segno "=" è ignorato.
Ma non è consentito alcuno spazio bianco DOPO il segno "="!
<p>
Per inserire uno spazio bianco nel valore di una opzione, bisogna farlo precedere da un "\" (barra retroversa) come nell'esempio seguente: >
<p>
:set tags=il\ mio\ bel\ file
<p>
Lo stesso esempio scritto come >
<p>
:set tags=Il mio bel file
<p>
produrrà un errore, perché viene interpretato come: >
<p>
:set tags=il 	:set mio 	:set bel 	:set file
<p>

<p>
COMMENTI
<p>
Il carattere " (il doppio apice) inizia un commento.
A partire da questo carattere il resto della linea è considerato un commento ed è ignorato, tranne che nei comandi che non considerano i commenti, come mostrato negli esempi qui sotto.
Un commento può cominciare in qualsiasi posizione della linea.
<p>
Bisogna fare attenzione ai commenti per alcuni comandi.
Ad es.: >
<p>
:abbrev dev development		" abbreviazione 	:map <F3> o#include		" inserisci include 	:execute cmd			" eseguilo 	:!ls *.c			" lista i file C
<p>
La abbreviazione 'dev' sarà espansa come 'development " abbreviazione'.
La mappatura di <F3> sarà costituita dall'intera linea dopo 'o# ....' compreso '" inserisci include'.
Il comando "execute" darà un errore.
Il comando "!" passerà tutto quel che lo segue allo shell, che darà un errore perché manca un carattere '"' che chiuda il primo '"'.
Non sono permessi commenti dopo i comandi ":map", ":abbreviate", ":execute" e "!" (ci sono alcuni altri comandi con la stessa limitazione).
Per i comandi ":map", ":abbreviate" e ":execute" si può però scrivere: >
<p>
:abbrev dev development|" abbreviazione 	:map <F3> o#include|" inserisci include 	:execute cmd			|" eseguilo
<p>
Il carattere '|' separa un comando da quello successivo.
Ed il comando successivo è solo un commento.
Per l'ultimo comando bisogna fare due cose: una è |:execute| e l'altra è l'uso di '|': > 	:exe '!ls *.c'			|" list C files
<p>
Si noti che non c'è alcuno spazio prima del '|' nella abbreviazione e nella mappatura.
Per questi comandi, ogni carattere fino a fine linea o a '|' è compreso.
Per questo motivo, non sempre è chiaro se sono presenti degli spazi dopo l'ultimo carattere visibile sulla linea; >
<p>
:map <F4> o#include
<p>
Per evidenziare questi problemi, potete attivare l'opzione 'list' mentre state modificando degli script Vim.

<p>
In Unix si può commentare la prima linea di uno script in una maniera speciale in modo da rendere lo script vim eseguibile: > 	#!/usr/bin/env vim -S 	echo "questo è uno script Vim" 	quit
<p>
Il comando "#" di per sé lista una linea col suo numero di linea.
L'aggiunta del punto esclamativo lo rende un comando che non fa nulla, ed allo stesso tempo permette di inserire il comando shell che consente [a Vim] di eseguire [come comandi Vim] le successive righe del file.
|:#!| |-S|
<p>

<p>
TRABOCCHETTI
<p>
Problemi anche maggiori sono presenti nell'esempio seguente: >
<p>
:map ,ab o#include 	:unmap ,ab
<p>
Il comando "unmap" non funzionerà, perché tenta di togliere la mappatura di ",ab " (c'è uno spazio bianco dopo il "b" - NdT).
Questa mappatura non esiste.
Sarà quindi visualizzato un messaggio di errore, difficile da comprendere, perché lo spazio bianco finale in ":unmap ,ab " non è visibile.

<p>
Lo stesso capita quando si usa un commento dopo un comando 'unmap': >
<p>
:unmap ,ab " commento
<p>
Qui il commento verrà ignorato.
Comunque, Vim tenterà di togliere la mappatura ',ab ', che non esiste.
Riscrivetelo come: >
<p>
:unmap ,ab| " commento
<p>

<p>
RITORNARE DOVE ERAVAMO
<p>
Talora volete fare una modifica, e ritornare al punto in cui si trovava il cursore prima della modifica.
Anche un ripristino della posizione relativa dello schermo sarebbe gradita, con la stessa linea di prima visualizzata in cima alla finestra.
L'esempio che segue copia la linea sotto il cursore, la mette sopra la prima linea del file, e torna al punto di partenza: >
<p>
map ,p ma"aYHmbgg"aP`bzt`a
<p>
Spiegazione: > 	ma"aYHmbgg"aP`bzt`a <	ma			marcatura "a" di posizione corrente 	 "aY			copia linea corrente nel registro "a" 	 Hmb		marcatura "b" su linea in cima alla pagina 		gg		vai alla prima linea del file 		 "aP		mettici sopra la linea nel registro "a" 		 `b		vai alla linea in cima alla pagina 		 zt	posiziona testo nella finestra come prima 			 `a	torna alla posizione in cui era il cursore
<p>

<p>
PER LA DISTRIBUZIONE
<p>
Per evitare che i vostri nomi di funzione entrino in conflitto con funzioni che altri hanno preparato, usate questo schema: - Premettete una vostra stringa ad ogni nume funzione.
Io uso spesso una abbreviazione.
Ad es., "OW_" è usato per le funzioni Opzioni Window.
- Mettete la definizione delle vostre funzioni in un unico file.
Impostate una variabile globale per indicare che la funzione è stata caricata.
Quando volete caricare di nuovo il file, cancellate prima le funzioni.
Ad es: >
<p>
" Questa è la funzione XXX
<p>
if exists("XXX_caricata") 	 delfun XXX_uno 	 delfun XXX_due 	endif
<p>
function XXX_uno(a) 		...
corpo della funzione ...
endfun
<p>
function XXX_due(b) 		...
corpo della funzione ...
endfun
<p>
let XXX_caricata = 1
<p>
============================================================================== *41.11*	Scrivere un plugin				*write-plugin*
<p>
Potete scrivere uno script Vim in modo tale che chi vuole lo possa usare.
Questo si chiama un "plugin".
Gli utenti Vim possono copiare il vostro script Vim nella loro directory dei plugin e cominciare ad usare le sue funzioni.
Si veda |add-plugin|.
<p>
Ci sono di fatto due tipi di plugin:
<p>
global plugin: Per ogni tipo di file.
filetype plugin: Solo per file di un dato tipo.

<p>
In questa sezione è spiegato solo il "global plugin".
La maggior parte delle cose dette vale anche per i "filetype plugin".
Le informazioni relative ai "filetype plugin" sono nella sezione seguente |write-filetype-plugin|.

<p>

<p>
NOME
<p>
Innanzitutto dovete scegliere un nome per il vostro plugin.
Lo scopo per cui è stato scritto il plugin dovrebbe essere riconoscibile dal nome che ha.
E dovrebbe essere poco probabile che qualcun altro scriva un plugin con lo stesso nome, ma che faccia cose differenti.
E per favore, limitate il nome a 8 caratteri, per evitare problemi sui vecchi sistemi Windows.

<p>
Uno script che corregge errori di digitazione potrebbe essere chiamato "typecorr.vim".
Lo useremo qui come esempio.
<p>
Se il plugin deve poter essere usato da tutti, deve seguire alcune linee guida.
Le vediamo una alla volta.
L'esempio completo del plugin è riportato alla fine.
<p>

<p>
CORPO
<p>
Cominciamo dal corpo del plugin, le linee che fanno il lavoro vero: >
<p>
14	iabbrev li il 15	iabbrev altor altro 16	iabbrev voule vuole 17	iabbrev sopratutto 18		\ soprattutto 19	let s:contatore = 4
<p>
La lista vera dovrebbe essere molto più lunga, naturalmente.

<p>
La numerazione delle linee è stata aggiunta per uso didattico, non dovete metterla nel vostro file plugin!
<p>

<p>
INTESTAZIONE
<p>
Probabilmente aggiungerete nuove correzioni al vostro plugin, e vi ritroverete con diverse versioni sparse qua e là.
E quando distribuirete il vostro file plugin, la gente vorrà sapere chi ha scritto questo meraviglioso plugin e a chi possono essere inviate considerazioni al riguardo.
Ragion per cui, dovreste mettere una intestazione all'inizio del vostro plugin: >
<p>
1	" Plugin generale di Vim per correggere errori di digitazione 2	" Ultima Modifica:	2000 Ott 15 3	" Manutentore:	Bram Moolenaar <Bram@vim.org>
<p>
A proposito di copyright e licenze: Poiché i plugin sono molto utili, e non ha gran senso restringerne la distribuzione, siete invitati a considerare l'idea di dichiarare il vostro plugin di pubblico dominio, oppure di usare la licenza Vim |license|.
Una breve nota al riguardo vicino all'inizio del plugin dovrebbe essere sufficiente.
Ad es.: >
<p>
4	" Licenza:	Questo file è di pubblico dominio.

<p>

<p>
CONTINUAZIONE LINEA, AL NETTO DA EFFETTI SECONDARI	*use-cpo-save*
<p>
Nella linea 18 qui sopra, il meccanismo usato per la continuazione è descritto in |line-continuation|.
Utenti che hanno attivato l'opzione 'compatible' avranno del problemi, e otterranno un messaggio di errore.
Non possiamo semplicemente cambiare l'opzione 'compatible', perché questo avrebbe molti altri effetti oltre a quello desiderato.
Per evitare di toccare 'compatible' imposteremo invece l'opzione 'cpoptions' al suo valore predefinito in Vim e la riporteremo poi al valore che aveva.
Questo ci consente di usare le linee di continuazione e nello stesso tempo rende lo script utilizzabile da un numero molto maggiore di utenti.
Si fa in questo modo: >
<p>
11	let s:salva_cpo = &cpo 12	set cpo&vim ..
42	let &cpo = s:salva_cpo
<p>
Prima si memorizza il valore precedente di 'cpoptions' nella variabile s:salva_cpo.
Alla fine del plugin questo valore viene ripristinato.
<p>
Notate l'uso di una variabile locale allo script |s:var|.
Una variabile globale con lo stesso nome potrebbe essere già in uso da qualche altra parte.
Usate sempre delle variabili locali allo script per azioni limitate solo all'interno dello script.

<p>

<p>
NON CARICARE
<p>
È possibile che un utente non voglia sempre caricare questo plugin.
Oppure l'amministratore del sistema l'ha messo nella directory dei plugin di uso comune a tutti gli utenti, ma un utente vuole usare il suo proprio plugin.
Quindi all'utente deve essere offerta la possibilità di evitare l'uso di questo specifico plugin.
Questo si ottiene così: >
<p>
6	if exists("loaded_typecorr") 7	 finish 8	endif 9	let loaded_typecorr = 1
<p>
Si evita così anche che, nel caso lo script sia caricato una seconda volta, si riceva un messaggio di errore perché la funzione erà già definita, e possano presentarsi dei problemi per degli autocomandi aggiunti più di una volta.

<p>

<p>
MAPPATURE
<p>
Per rendere il plugin più interessante, introduciamo una mappatura che aggiunga una correzione per la parola che si trova sotto il cursore.
Potremmo scegliere una combinazione di tasti per questa mappatura, ma l'utente magari la usa già per fare qualcosa d'altro.
Per permettere all'utente di definire la sequenza di tasti che vuole usare per una mappatura all'interno di un plugin, si può usare l'elemento <Leader>: >
<p>
22	 map <unique> <Leader>a <Plug>TypecorrAdd
<p>
Il comando "<Plug>TypecorrAdd" rende questo possibile, come vedremo dopo.

<p>
L'utente può dare alla variabile "mapleader" la combinazione di tasti con cui vuole che cominci questa mappatura.
Se l'utente ha impostato: >
<p>
let mapleader = "_"
<p>
la mappatura definirà "_a".
Se l'utente non ha fatto nulla, il valore predefinito (che è "\", barra retroversa) sarà utilizzato.
In quel caso la mappatura definita sarà "\a".

<p>
Note Poiché <unique> è usato, sarà inviato un messaggio di errore nel caso la stessa mappatura sia già stata definita.
|:map-<unique>|
<p>
E se l'utente volesse definire una sua sequenza di tasti? Glielo si può permettere con questo meccanismo: >
<p>
21	if !hasmapto('<Plug>TypecorrAdd') 22	 map <unique> <Leader>a <Plug>TypecorrAdd 23	endif
<p>
Qui controlliamo se una mappatura per "<Plug>TypecorrAdd" esiste già, e definiamo la mappatura con "<Leader>a" solo se non esiste.
L'utente ha quindi la possibilità di mettere nel suo file vimrc: >
<p>
map ,c <Plug>TypecorrAdd
<p>
E quindi la sequenza di tasti mappata sarà ",c" invece che "_a" o "\a".

<p>

<p>
PARTI
<p>
Se uno script si allunga, potrebbe essere desiderabile dividere il lavoro in parti.
Potete usare sia delle funzioni che delle mappature per questo.
Ma non volete che queste funzioni e mappature interferiscano con altre, contenute in altri script.
Per esempio, potreste definire una funzione Add(), ma un altro script potrebbe tentare di definire la stessa funzione.
Per evitare questo, definiamo la funzione come locale, esistente solo all'interno del nostro script, premettendo "s:" al suo nome.

<p>
Definiamo una funzione che aggiunge una nuova correzione di errore di digitazione: >
<p>
30	function s:Add(errato, corretto) 31	 let buono = input("Digitare correzione per " .
a:errato .
": ") 32	 exe ":iabbrev " .
a:errato .
" " . buono .. 36	endfunction
<p>
Ora possiamo richiamare la funzione s:Add() dall'interno dello script.
Se un altro script definisce ancora s:Add(), esisterà solo dentro quello script, e può essere chiamata solo dallo script in cui è stata definita.
Ci può anche essere una funzione globale.
Ci può anche essere una funzione globale Add() (senza "s:"), che è distinta dalle altre due.

<p>
<SID> si può usare senza mappature.
Genera un ID dello script, che identifica lo script in cui si trova.
Nel nostro plugin di correzione errori di digitazione lo usiamo in questo modo: >
<p>
24	noremap <unique> <script> <Plug>TypecorrAdd <SID>Add ..
28	noremap <SID>Add :call <SID>Add(expand("<cword>"), 1)<CR>
<p>
Ovvero, quando un utente digita "\a", viene richiamata questa sequenza: >
<p>
\a -> <Plug>TypecorrAdd -> <SID>Add -> :call <SID>Add()
<p>
Se un altro script mappasse <SID>Add, un altro script ID sarebbe generato, e quindi verrebbe definito un'altra mappatura.

<p>
Note Usiamo qui <SID>Add() invece che s:Add().
Questo perché la mappatura viene immessa dall'utente, ossia dall'esterno dello script.
Il <SID> si traduce nell'ID dello script, in modo che Vim sappia in che script cercare la funzione Add().

<p>
La cosa è un po' complicata, ma serve per far sì che il plugin funzioni assieme ad altri plugin.
La regola fondamentale è che voi usiate <SID>Add() nelle mappature e s:Add() da altre parti (nello script stesso, in autocomandi o in comandi utente).

<p>
Possiamo anche rendere disponibile la mappatura in un menù: >
<p>
26	noremenu <script> Plugin.Aggiungi\ Correzione <SID>Add
<p>
Il menù "Plugin" è raccomandato per aggiungere elementi di menù a plugin.
In questo caso c'è solo un elemento.
Se si aggiungono più elementi, la creazione di un sottomenù è auspicabile.
Ad esempio, "Plugin.CVS" potrebbe essere usato per un plugin che offre le operazioni CVS "Plugin.CVS.checkin", "Plugin.CVS.checkout", etc.
[CVS è un software per gestire sorgenti, "checkin" inserisce un sorgente, "checkout" lo preleva per aggiornarlo - NdT]
<p>
Note Nella linea 28 ":noremap" è usato per evitare che qualsiasi altra mappatura provochi problemi.
Qualcuno potrebbe aver ridefinito ":call", ad esempio.
Nella linea 24 usiamo anche ":noremap", ma vogliamo che "<SID>Add" sia ri-mappato.
Per questo "<script>" è usato qui.
Questo permette mappature che valgono solo all'interno dello script.
|:map-<script>| La stessa cosa è fatta nella linea 26 per ":noremenu". |:menu-<script>|
<p>

<p>
<SID> E <Plug>					*using-<Plug>*
<p>
Sia <SID> che <Plug> sono usati per evitare che mappature di combinazioni di tasti entrino in conflitto con altri che devono essere usati solo da altre mappature.
Note Questa è la differenza fra usare <SID> e <Plug>:
<p>
<Plug>	è visibile all'esterno dello script.
È usato per mappature per cui 	l'utente voglia utilizzare una particolare sequenza di tasti.
<Plug> 	è un codice speciale che un tasto della tastiera non è in grado di 	produrre.
Per rendere molto difficile che altri plugin usino la stessa sequenza 	di caratteri, usate questa struttura: 	<Plug> nome_script nome_mappatura 	Nel nostro esempio il nome_script è "Typecorr" e il nome_mappatura 	è "Add".
Il risultato è "<Plug>TypecorrAdd".
Solo il primo carattere del 	nome_script e del nome_mappatura deve essere maiuscolo, in modo da 	poter capire dove comincia il nome_mappatura.

<p>
<SID>	è l'ID dello script, un identificatore unico a quello script.
Internamente Vim traduce <SID> in "<SNR>123_", dove "123" può essere 	un numero qualsiasi.
Per cui una funzione "<SID>Add()" avrà come nome 	"<SNR>11_Add()" in uno script, e "<SNR>22_Add()" in un altro.
Potete 	vederlo se usate il comando ":function" per ottenere una lista di 	funzioni.
La traduzione di <SID> nelle mappature è esattamente la 	stessa, ed è questo il modo con cui potete invocare una funzione 	locale ad uno script da una mappatura.

<p>

<p>
COMANDI UTENTE
<p>
Aggiungiamo ora un comando utente per aggiungere una correzione: >
<p>
38	if !exists(":Correzione") 39	 command -nargs=1 Correzione :call s:Add(<q-args>, 0) 40	endif
<p>
Il comando utente viene definito solo se non esiste già un comando con lo stesso nome.
Altrimenti otterremmo un messaggio di errore.
Sostituire il comando utente già esistente col nostro, scrivendo ":command!" non è una buona idea, in quanto l'utente si domanderebbe perché il comando che LUI ha definito non funziona.
|:command|
<p>

<p>
VARIABILI NEGLI SCRIPT
<p>
Quando una variabile ha un nome che comincia con "s:" è una variabile dello script.
Si può solo usare all'interno di uno script, Non esiste all'esterno dello script.
Questo consente di evitare problemi quando si utilizza lo stesso nome di variabile in script differenti.
La variabile sarà disponibile per tutto il tempo in cui si usa Vim.
E la stessa variabile verrà riutilizzata se si ricarica lo stesso script una seconda volta.
|s:var|
<p>
Il bello è che queste variabili possono anche essere usate in funzioni, autocomandi e comandi utente che sono definiti nello script.
Nel nostro esempio di script possiamo aggiungere alcune linee per contare il numero di correzioni: >
<p>
19	let s:contatore = 4 ..
30	function s:Add(from, correct) ..
34	 let s:contatore = s:contatore + 1 35	 echo s:contatore .
" correzioni finora" 36	endfunction
<p>
Dapprima s:contatore è inizializzato a 4 nello script stesso.
Quando, più tardi, la funzione s:Add() viene invocata, incrementa s:count.
Non importa da DOVE la funzione è stata chiamata, poiché, essendo stata definita nello script, userà solo variabili interne a questo script.

<p>

<p>
IL RISULTATO
<p>
Questo è lo script completo risultante: >
<p>
1	" Plugin generale di Vim per correggere errori di digitazione 2	" Ultima Modifica:	2000 Ott 15 3	" Manutentore:	Bram Moolenaar <Bram@vim.org> 4	" Licenza:	Questo file è di pubblico dominio.
5 6	if exists("loaded_typecorr") 7	 finish 8	endif 9	let loaded_typecorr = 1 10 11	let s:salva_cpo = &cpo 12	set cpo&vim 13 14	iabbrev li il 15	iabbrev altor altro 16	iabbrev voule vuole 17	iabbrev sopratutto 18		\ soprattutto 19	let s:contatore = 4 20 21	if !hasmapto('<Plug>TypecorrAdd') 22	 map <unique> <Leader>a <Plug>TypecorrAdd 23	endif 24	noremap <unique> <script> <Plug>TypecorrAdd <SID>Add 25 26	noremenu <script> Plugin.Aggiungi\ Correzione <SID>Add 27 28	noremap <SID>Add :call <SID>Add(expand("<cword>"), 1)<CR> 29 30	function s:Add(errato, corretto) 31	 let buono = input("Digitare correzione per " .
a:errato .
": ") 32	 exe ":iabbrev " .
a:errato .
" " .
buono 33	 if a:corretto | exe "normal viws\<C-R>\" \b\e" | endif 34	 let s:contatore = s:contatore + 1 35	 echo s:contatore .
" correzioni finora" 36	endfunction 37 38	if !exists(":Correzione") 39	 command -nargs=1 Correzione :call s:Add(<q-args>, 0) 40	endif 41 42	let &cpo = s:salva_cpo
<p>
La linea 33 non è stata ancora spiegata.
Applica la nuova correzione alla parola sotto il cursore.
Il comando |:normal| è usato per fare uso della nuova abbreviazione.
Note mappature e abbreviazioni sono espanse qui, anche se la funzione è stata invocata da una mappatura definita come ":noremap".

<p>
L'uso di "unix" come opzione 'fileformat' è raccomandato.
Gli script Vim in questo modo funzioneranno anche in tutti gli altri ambienti software.
Script che abbiano 'fileformat' impostato a "dos" non funzionano sotto Unix.
Si veda anche |:source_crnl|.
Per essere sicuri di usarlo, scrivete, prima di scrivere il file che contiene lo script: >
<p>
:set fileformat=unix
<p>

<p>
DOCUMENTAZIONE						*write-local-help*
<p>
E' una buona idea preparare anche un po' di documentazione per il vostro plugin.
Questo è ancora più necessario quando il suo comportamento può essere personalizzato dall'utente.
Si veda |add-local-help| per come aggiungere la vostra documentazione a quella di Vim.

<p>
Qui vedete un semplice esempio di file di aiuto, di nome "typecorr.txt": >
<p>
1	*typecorr.txt*	Plugin per correzione di errori di digitazione.
2 3	Se vi capita di fare errori di digitazione, questo plugin li 4	correggerà automaticamente.
5 6	Al momento le correzioni sono poche.
Potete aggiungerne, se volete.
7 8	Mappatura: 9	<Leader>a o <Plug>TypecorrAdd 10		Aggiunge una correzione per la parola sotto il cursore.
11 12	Comandi: 13	:Correzione {parola} 14		Aggiunge una correzione per {parola}.
15 16							*typecorr-settings* 17	Questo plugin non ha alcuna impostazione particolare.

<p>
La prima linea è l'unica per la quale il formato è importante.
Sarà questa ad essere estratta dal file di aiuto per essere inserita nella sezione "LOCAL ADDITIONS" del file help.txt |local-additions|.
Il primo "*" deve essere nella prima colonna della prima linea di testo.
Dopo aver aggiunto il vostro file di aiuto date il comando ":help" per controllare che le linee in questione siano correttamente allineate.

<p>
Potete aggiungere altri tag (racchiusi fra **) nel vostro file di aiuto.
Ma state attenti ad evitare nomi di tag di help già esistenti.
Potreste inserire il nome del vostro plugin nei loro nome, come "typecorr-settings" nel nostro esempio.

<p>
L'uso di puntatori ad altre parti del file di help (racchiusi fra ||) è auspicabile.
Questo facilita l'utente nel reperimento dell'aiuto a loro associato.

<p>

<p>
DETERMINAZIONE DEL TIPO FILE				*plugin-filetype*
<p>
Se il tipo del vostro file non è già determinato da Vim, dovreste creare un piccolo script che lo determini in un file a parte.
Di solito lo script consiste in un autocomando che imposta il tipo file quando il nome del file corrisponde a un dato modello.
Ad es.: >
<p>
au BufNewFile,BufRead *.foo			set filetype=foofoo
<p>
Scrivete il file contenente quest'unica linea come "ftdetect/foofoo.vim" nella prima directory che compare in 'runtimepath'.
In Unix questa sarebbe "~/.vim/ftdetect/foofoo.vim".
La convenzione è di usare il nome del tipo file come nome dello script.

<p>
I controlli possono essere molto più sofisticati, se volete, come ad es.
una ispezione del contenuto del file per riconoscere il linguaggio.
SI veda anche |new-filetype|.

<p>

<p>
SOMMARIO						*plugin-special*
<p>
Lista delle particolarità che contraddistinguono un plugin:
<p>
s:name			variabili interne allo script.

<p>
<SID>			Script-ID, usato per mappature e funczioni interne 			allo script.

<p>
hasmapto()		Funzione per accertare se l'utente ha già definito 			mappature per funzionalità contenute nello script.

<p>
<Leader>		Valore di "mapleader", che l'utente definisce come 			sequenza di tasti con cui iniziano le mappature del 			plugin.

<p>
:map <unique>		Emette un messaggio se una mappatura esiste già.

<p>
:noremap <script>	Usa solo mappature interne allo script, non mappature 			valide globailmente.

<p>
exists(":Cmd")		Controlla se un comando utente esiste già.

<p>
============================================================================== 							 *ftplugin* *41.12*	Scrivere un plugin per un tipo_file	*write-filetype-plugin*
<p>
A plugin per un tipo_file è simile a un plugin globale, ma imposta opzioni e definisce mappature solo per il buffer corrente.
Si veda |add-filetype-plugin| per informazioni sull'uso di questo tipo di plugin.

<p>
Leggete prima la sezione precedente sui plugin globali |41.11|.
Tutto quel che si dice lì vale anche per i plugin per un tipo_file.
Ci sono alcune regole in più, che sono spiegate qui di seguito.
La caratteristica fondamentale è che un plugin per un tipo_file dovrebbe avere effetto solo sul buffer corrente.

<p>

<p>
DISABILITAZIONE
<p>
Se state scrivendo un plugin per un tipo_file che potrà essere usato da molta gente, dovete concedere loro la possibilità di evitare di usarlo.
Mettete questo in testa al plugin: >
<p>
" Usa solo se non esiste già un latro plugin attivo 	if exists("b:did_ftplugin") 	 finish 	endif 	let b:did_ftplugin = 1
<p>
Occorre usare questa tecnica per evitare che lo stesso plugin sia eseguito due volte per lo stesso buffer (succede quando si usa un comando ":edit" senza fornirgli alcun argomento).

<p>
A questo punto gli utenti possono disabilitare completamente il plugin predefinito creando un plugin per un tipo_file composto solo da questa linea:
<p>
let b:did_ftplugin = 1
<p>
Per ottenere questo, la directory che contiene il vostro plugin per un tipo_file deve venire prima della directory $VIMRUNTIME nella list di directory contenuta nella opzione 'runtimepath'!
<p>
Se volete usare il plugin predefinito, ma cambiare una delle impostazioni, potete inserire l'impostazione da cambiare in uno script: >
<p>
setlocal textwidth=70
<p>
Poi lo scrivete nella directory "after" ["dopo"], così che venga eseguito DOPO il plugin di tipo_file predefinito (in questo caso "vim.vim").
Si veda |after-directory|.
In Unix questa directory è: "~/.vim/after/ftplugin/vim.vim".
Note Il plugin predefinito avrà impostato "b:did_ftplugin", ma la cosa viene qui ignorata.

<p>

<p>
OPZIONI
<p>
Per far sì che il plugin per un tipo_file agisca solo sul buffer corrente usate il comando:
<p>
:setlocal
<p>
per impostare le opzioni.
Ed impostate solo le opzioni che agiscono solo sul buffer corrente (si veda l'aiuto relativo a ogni singola opzione per controllare quali lo facciano).
Quando si usa |:setlocal| per opzioni globali o per opzioni che riguardano una particolare finestra, il valore potrebbe cambiare in numerosi buffer, e non è questo l'obiettivo che si dovrebbe avere in un plugin per un tipo_file.

<p>
Quando una opzione ha un valore che è una lista di indicatori o elementi, potete utilizzare la sintassi "+=" e "-=" per non modificare i valori già impostati.
Tenete presente che l'utente possa aver già cambiato il valore di una opzione.
Ripristinare il valore predefinito e poi cambiarlo come serve è spesso una buona idea.
Ad es.: >
<p>
:setlocal formatoptions& formatoptions+=ro
<p>

<p>
MAPPATURE
<p>
Per far sì che le mappature siano applicate solo nel buffer corrente usate il comando: >
<p>
:map <buffer>
<p>
Questo va combinato con la mappatura in due passi spiegata più sopra.
Ecco un esempio di come si definisce una funzionalità in un plugin per un tipo_file: >
<p>
if !hasmapto('<Plug>JavaImport') 	 map <buffer> <unique> <LocalLeader>i <Plug>JavaImport 	endif 	noremap <buffer> <unique> <Plug>JavaImport oimport ""<Left><Esc>
<p>
|hasmapto()| è usato per controllare se l'utente ha già definito una mappatura per <Plug>JavaImport.
In caso negativo, il plugin per un tipo_file definisce la mappatura predefinita.
Questa inizia con |<LocalLeader>|, che permette all'utente di scegliere il tasto (o i tasti) con cui vuole che inizino le mappature dei plugin per un tipo_file.
Il valore predefinito è la barra rovesciata ("\").
"<unique>" è usato per mandare un messaggio di errore se la mappatura esiste già o entra in conflitto con una mappatura esistente.
|:noremap| è usato per evitare che ogni altra mappatura che l'utente abbia definito possa interferire.
Potreste voler usare ":noremap <script>" per far sì che si possano ri-mappare mappature definite in questo script, che comincino con <SID>.

<p>
L'utente deve avere la possibilità di disabilitare una mappatura in un plugin per un tipo_file, senza disabilitarlo completamente.
Ecco un esempio di come si può fare questo per il tipo_file "mail" (messaggi di posta elettronica): >
<p>
" Aggiungi mappature, a meno che l'utente preferisca evitarlo.
if !exists("no_plugin_maps") && !exists("no_mail_maps") 	 " Citate un testo inserendo "> " 	 if !hasmapto('<Plug>MailQuote') 	 vmap <buffer> <LocalLeader>q <Plug>MailQuote 	 nmap <buffer> <LocalLeader>q <Plug>MailQuote 	 endif 	 vnoremap <buffer> <Plug>MailQuote :s/^/> /<CR> 	 nnoremap <buffer> <Plug>MailQuote :.,$s/^/> /<CR> 	endif
<p>
Due variabili globali sono usate: no_plugin_maps		disabilita mappature per ogni plugin di un tipo_file no_mail_maps		disabilita mappature per un dato tipo_file
<p>

<p>
COMANDI UTENTE
<p>
Per aggiungere un comando utente per un dato tipo_file, in modo che possa solo essere usato in un buffer, usate l'argomento "-buffer" di |:command|.
Ad es.: >
<p>
:command -buffer Make make %:r.s
<p>

<p>
VARIABILI
<p>
Un plugin per un tipo_file sarà utilizzato in ogni buffer contenente un file di quel tipo.
La variabile interna di script |s:var| sarà la stessa per tutti i buffer in cui il plugin viene utilizzato.
Usate variabili interne al buffer |b:var| se volete che una variabile sia usata sono all'interno di un unico buffer.

<p>

<p>
FUNZIONI
<p>
Quando si definisce una funzione, questa va definita soltanto una volta.
Ma il plugin di tipo_file verrà invocato ogni volta che verrà aperto un file con quel dato tipo file.
La tecnica seguente fa sì che la funzione venga definita una volta sola.
>
<p>
:if !exists("*s:Func") 	: function s:Func(arg) 	: ...
: endfunction 	:endif <
<p>
ANNULLARE						*undo_ftplugin*
<p>
Quando l'utente imposta ":setfiletype xyz" l'effetto del tipo_file "precedente" dovrebbe essere annullato.
Impostate la variabile b:undo_ftplugin con i comandi che annulleranno le impostazioni di un vostro plugin per un tipo_file.
Ad es.: >
<p>
let b:undo_ftplugin = "setlocal fo< com< tw< commentstring<" 		\ .
"| unlet b:match_ignorecase b:match_words b:match_skip"
<p>
L'uso di ":setlocal" con "<" subito dopo il nome dell'opzione reimposta per quell'opzione il suo valore globale.
Nella maggior parte dei casi è questa la maniera migliore di ripristinare i valori "precedenti" delle opzioni.

<p>
Occorre togliere la indicazione "C" da 'cpoptions' per consentire la continuazione della linea, come detto prima |use-cpo-save|.

<p>

<p>
NOME FILE
<p>
Il tipo_file deve far parte del nome del plugin |ftplugin-name|.
Usate una di queste tre forme:
<p>
.../ftplugin/roba.vim 	.../ftplugin/roba_mia.vim 	.../ftplugin/roba/tua.vim
<p>
"roba" è il tipo_file, "mia" e "tua" sono nomi a piacere.

<p>

<p>
SOMMARIO						*ftplugin-special*
<p>
Lista delle particolarità che contraddistinguono un plugin di tipo_file:
<p>
<LocalLeader>		Valore di "maplocalleader", che l'utente definisce 			come la combinazione di tasti con cui iniziano le 			mappature per un plugin di tipo_file.

<p>
:map <buffer>		Definisce una mappatura che vale solo all'interno del 			buffer.

<p>
:noremap <script>	Ri-mappa solo mappature definite in questo script e 			che cominciano con <SID>.

<p>
:setlocal		Imposta una opzione solo per il buffer corrente.

<p>
:command -buffer	Definisce un comando utente valido solo in questo 			buffer.

<p>
exists("*s:Func")	Controlla se una funzione è stata già definita.

<p>
Si veda anche |plugin-special|, che descrive le proprietà specifiche dei 			plugin.

<p>
============================================================================== *41.13*	Scrivere un plugin per un compilatore 						*write-compiler-plugin*
<p>
Un plugin per un compilatore imposta le opzioni da usare con un dato compilatore.
L'utente può invocarlo con il comando |:compiler|.
L'uso principale che se ne fa è per impostare le opzioni 'errorformat' e 'makeprg'.
<p>
Un esempio è la maniera più semplice di introdurlo.
Questo comando modificherà tutti i plugin predefiniti per i compilatori: >
<p>
:next $VIMRUNTIME/compiler/*.vim
<p>
Usate |:next| per passare al file di plugin successivo.

<p>
Ci sono due caratteristiche notevoli di questi file.
La prima è un meccanismo che permette a un utente di fare modifiche o aggiunte al file di plugin predefinito.
I file predefiniti cominciano con: >
<p>
:if exists("current_compiler") 	: finish 	:endif 	:let current_compiler = "mine"
<p>
Quando scrivete un file per un compilatore e lo mettere nella vostra propria directory di file di esecuzione ("runtime directory") (ad es., ~/.vim/compiler in Unix), voi potete impostare la variabile "current_compiler" in modo che il file predefinito non esegua (in seguito) le impostazioni che contiene.
*:CompilerSet* Il secondo metodo consiste nell'usare ":set" per ":compiler!" e ":setlocal" per ":compiler".
Vim fornisce il comando utente ":CompilerSet" a questo scopo.
D'altra parte, precedenti versioni di Vim non ne sono dotate, e per questo motivo un vostro plugin dovrebbe definirla solo dopo aver controllato.
Ecco un esempio: >
<p>
if exists(":CompilerSet") != 2 command -nargs=* CompilerSet setlocal <args> endif CompilerSet errorformat&		" usa 'errorformat' predefinito CompilerSet makeprg=nmake < Quando scrivete un plugin per un compilatore da distribuire con Vim o da mettere in una directory di esecuzione ("runtime directory") a livello di sistema, usate il meccanismo delineato più sopra.
Se "current_compiler" era già stato impostato da un plugin dell'utente, questo verrà ritenuto valido e non sostituito in alcun modo.

<p>
Quando scrivete un plugin di compilatore per modificare impostazioni contenute nel plugin predefinito, non controllate la variabile "current_compiler".
Un plugin di questo tipo dovrebbe venire eseguito per ultimo, e quindi dovrebbe trovarsi in una directory in fondo alla lista di directory specificata in 'runtimepath'.
In Unix il suo nome potrebbe essere ~/.vim/after/compiler.

<p>
============================================================================== *41.14*	Scrivere un plugin veloce a caricarsi	*write-plugin-quickload*
<p>
Un plugin più crescere e divenire piuttosto lungo.
Il ritardo alla partenza può diventare notevole, e magari il plugin non vi serve quasi mai.
E' a questo punto che può venir buono un plugin veloce a caricarsi.

<p>
L'idea di fondo è che il plugin è caricato due volte.
La prima volta per definire i comandi utenti e le mappature che offrono la funzionalità.
la seconda volta per definire le funzioni che implementano la funzionalità.

<p>
Può sembrare sorprendente che "caricamento veloce" voglia dire caricare il plugin due volte.
Quel che si vuol dire è che si carica velocemente all'inizio, rimandando la parte più sostanziosa dello script alla seconda volta, il che vuol dire solo quando ne avete veramente bisogno.
Quando la funzionalità viene utilizzata spesso, il risultato è in effetti più lento!
<p>
Note Da Vim 7 c'è una altra possibilità: usate la funzionalità |autoload| |41.15|.

<p>
L'esempio che segue mostra il procedimento: >
<p>
" Vim global plugin for demonstrating quick loading 	" Last Change:	2005 Feb 25 	" Maintainer:	Bram Moolenaar <Bram@vim.org> 	" License:	This file is placed in the public domain.

<p>
if !exists("s:did_load") 		command -nargs=* BNRead call BufNetRead(<f-args>) 		map <F19> :call BufNetWrite('something')<CR>
<p>
let s:did_load = 1 		exe 'au FuncUndefined BufNet* source ' .
expand('<sfile>') 		finish 	endif
<p>
function BufNetRead(...) 		echo 'BufNetRead(' .
string(a:000) .
')' 		" read functionality here 	endfunction
<p>
function BufNetWrite(...) 		echo 'BufNetWrite(' .
string(a:000) .
')' 		" write functionality here 	endfunction
<p>
Quando lo script è caricato la prima volta "s:did_load" non è impostato.
I comandi fra l' "if" e l' "endif" vengono eseguiti.
Questi terminano com un comando |:finish|, e quindi il resto dello script non viene eseguito.

<p>
La seconda volta che lo script viene caricato "s:did_load" esiste e i comandi dopo l' "endif" vengono eseguiti.
Qui sono definite le funzioni (che possono essere "pesanti") BufNetRead() e BufNetWrite().

<p>
Se copiate questo script nella vostra directory dei plugin Vim lo eseguirà alla partenza.
Questa è la sequenza degli eventi che si producono:
<p>
1.
Il comando "BNRead" è definito e il tasto <F19> è mappato quando lo script viene letto alla partenza.
Un autocomando |FuncUndefined| è definito.
Il comando ":finish" fa concludere velocemente lo script.
<p>
2.
L'utente immette il comando BNRead o preme il tasto <F19>.
La funzione BufNetRead() o BufNetWrite() sarà invocata.
<p>
3.
Vim non trova la funzione e chiama l'autocomando per l'evento |FuncUndefined| Poiché l'espressione "BufNet*" corrisponde alla funzione invocata, il comando "source fname" sarà eseguito.
"fanme" sarà uguale al nome dello script (in qualsiasi posto si trovi), perché proviene dalla espansione di "<sfile>" (vedere |expand()|).

<p>
4.
Lo script è caricato ancora, la variabile "s:did_load" esiste e le sue funzioni vengono a questo punto definite.

<p>
Si noti che le funzioni che sono caricate in seguito sono quelle che corrispondono all'espressione dell'autocomando |FuncUndefined|.
Dovete accertarvi che nessun altro plugin definisca funzioni che corrispondono alla stessa espressione regolare.

<p>
============================================================================== *41.15*	Scrivere librerie di script		*write-library-script*
<p>
Alcune funzionalità serviranno in parecchi posti.
Quando questo supera il limite delle "poche linee", vorrete metterle in un unico script, e usarle da parecchi altri script.
Chiameremo quell'unico script uno script di libreria.
<p>
Caricare uno script di libreria è possibile, ma dovete evitare di caricarlo ancora, una volta che sia stato caricato.
Questo su può fare con la funzione |exists()|.
Esempio: >
<p>
if !exists('*MyLibFunction') 	 runtime library/mylibscript.vim 	endif 	call MyLibFunction(arg)
<p>
Occorre qui sapere che MyLibFunction() sia definita un uno script "library/mylibscript.vim" in una delle directory in 'runtimepath'.

<p>
Per semplificare la faccenda, Vim fornisce il meccanismo di autoload.
Così il nostro esempio diventerebbe: >
<p>
call mylib#myfunction(arg)
<p>
Molto più semplice, vero? Vim riconoscerà il nome di funzione e quando non è definito cercherà lo script "autoload/mylib.vim" in 'runtimepath'.
Quello script deve contenere la definizione della funzione "mylib#myfunction()".

<p>
Potete mettere molte altre funzioni nello script mylib.vim, potete organizzare le vostre funzioni in uno script di libreria.
Ma dovere usare nomi di funzione in cui la parte prima del simbolo "#" indichi il nome dello script.
Altrimenti Vim non saprebbe quale script caricare.

<p>
Se, presi dall'entusiasmo, scrivete un mucchio di script di libreria, potreste voler usare delle sotto-directory.
Esempi: >
<p>
call netlib#ftp#read('somefile')
<p>
Sotto Unix lo script di libreria usato qui potrebbe essere:
<p>
~/.vim/autoload/netlib/ftp.vim
<p>
Dove le funzioni sono definite così: >
<p>
function netlib#ftp#read(fname) 		" Read the file fname through ftp 	endfunction
<p>
Si noti che il nome con cui è definita la funzione è esattamente lo stesso che il nome usato per richiamare la funzione.
E la parte prima dell'ultimo "#" riflette esattamente il nome della sotto-directory e dello script.

<p>
Potete usare lo stesso meccanismo per delle variabili: >
<p>
let weekdays = dutch#weekdays
<p>
Questo farà caricare lo script "autoload/dutch.vim", che dovrebbe contenere qualcosa del tipo di: >
<p>
let dutch#weekdays = ['zondag', 'maandag', 'dinsdag', 'woensdag', 		\ 'donderdag', 'vrijdag', 'zaterdag']
<p>
Per ulteriori letture vedere: |autoload|.

<p>
============================================================================== *41.16*	Distribuzione di script Vim			*distribute-script*
<p>
Gli utenti Vim possono cercare script sul sito Web vim: http://www.vim.org.
Se avete fatto qualcosa che potrebbe essere utile ad altri, condividetelo!
<p>
Gli script Vim si possono usare su ogni sistema.
I comandi tar e zip potrebbero non essere disponibili in alcuni sistemi.
Se volete riunire più file e/o comprimerli, si raccomanda di usare il comando di utilità "zip".

<p>
Per la massima portabilità, usate Vim stesso per impaccare i vostri script.
E' possibile farlo con il programma di utilità vimball.
Si veda |vimball|.
<p>
E' una buona cosa se aggiungete una linea che permetta un aggiornamento automatico.
Si veda |glvs-plugins|.
<p>
==============================================================================
<p>
Capitolo seguente: |usr_42.txt| Aggiungere nuovi menù
<p>
Copyright: vedere |manual-copyright| vim:tw=78:ts=8:ft=help:norl:
<p>
Per segnalazioni scrivere a vimdoc.it at gmail dot com oppure ad Antonio Colombo azc100 at gmail dot com *usr_42.txt*	Per Vim version 7.2.
Ultima modifica: 2008 Mag 05
<p>
VIM USER MANUAL - di Bram Moolenaar 		 Traduzione di questo capitolo: Luca Ferraro
<p>
Aggiungere nuovi menù
<p>

<p>
A questo punto sapete che Vim è molto flessibile.
Ciò include i menù usati nella GUI.
Potete definire le vostre proprie opzioni di menù per rendere alcuni comandi più facilmente accessibili.
Cito è possibile solo per utenti felici di usare il mouse!
<p>
|42.1|	Introduzione |42.2|	Comandi dei menù |42.3|	Varie |42.4|	Toolbar ed i menù popup
<p>
Capitolo seguente: |usr_43.txt| Utilizzo dei tipi di file Capitolo precedente: |usr_41.txt| Preparare uno script Vim 	 Indice: |usr_toc.txt|
<p>
============================================================================== *42.1*	Introduzione
<p>
I menù che Vim usa sono definiti nel file "$VIMRUNTIME/menu.vim".
Se volete scrivere i vostri menù personali, potreste prima dare un'occhiata a questo file.
Per definire un elemento del menù, utilizzate il comando ":menu".
La forma fondamentale di questo comando è molto semplice: >
<p>
:menu {elemento-menù} {comando}
<p>
L' {elemento-menù} descrive in quale posizione del menù inserire l'elemento.
Un tipico {elemento-menù} è "File.Save", che rappresenta l'elemento "Save" sotto il menù "File".
Un punto viene utilizzato per separare i nomi.
Un esempio: >
<p>
:menu File.Save :update<CR>
<p>
Il comando ":update" salva il file quando esso sia stato modificato.
Potete aggiungere un altro livello: "Edit.Settings.Shiftwidth" definisce un sotto menù "Settings" nel menù "Edit", con l'elemento "Shiftwidth".
Potreste utilizzare anche livelli inferiori.
Non usatelo troppo, vi toccherebbe spostare il mouse un bel po' per poter usare così un elemento.
Il commando ":menu" è molto simile al comando ":map" : il lato sinistro specifica quale elemento verrà lanciato ed il destro definisce i caratteri che verranno eseguiti.
{keys} sono caratteri, vengono usati solo come li avevate scritti.
Così nell'Insert mode, quando {keys} è puro testo, questo testo viene inserito.

<p>

<p>
TASTI DI SCELTA RAPIDA
<p>
Il carattere ampersand (&), viene utilizzato per indicare un tasto di scelta rapida.
Per esempio, potete utilizzare Alt-F per selezionare il menù "File" e quindi premere S per il comando "Save".
(L'opzione 'winaltkeys' può peraltro disabilitare questa possibilità!).
Comunque il {menù-item} appare come "&File.&Save".
I caratteri acceleratori verranno sottolineati nel menù.
Dovrete fare attenzione che ogni tasto venga usato una sola volta in ciascun menù.
Altrimenti non sapreste quale dei due potrebbe venire usato.
Vim non vi avvisa di ciò.
<p>

<p>
PRIORITA'
<p>
La definizione corrente dell'elemento di menù File.Save è come segue: >
<p>
:menu 10.340 &File.&Save<Tab>:w :confirm w<CR>
<p>
Il numero 10.340 è chiamato il numero di priorità.
Questo viene utilizzato dall'editor per decidere in quale posizione inserire l'elemento di menù.
Il primo numero (10) indica la posizione sulla barra dei menù.
I menù con i valori più bassi vengono posizionati a sinistra, quelli con valori più alti a destra.
Questi sono le priorità usate per i menù standard:
<p>
10	20 40 50 60 70		9999
<p>
+------------------------------------------------------------+ 	| File	Edit Tools Syntax Buffers Window		Help | 	+------------------------------------------------------------+
<p>
Notate che al menù Help viene dato un numero molto grande, per farlo apparire il più a destra possibile.
Il secondo numero (340) determina la posizione dell'elemento nel menù a discesa.
I numeri più bassi vanno in alto, quelli più alti in fondo.
Queste sono le priorità nel menù File:
<p>
+-----------------+ 	 10.310	|Open...	 | 	 10.320	|Split-Open...	 | 	 10.325	|New		 | 	 10.330	|Close		 | 	 10.335	|---------------- | 	 10.340	|Save		 | 	 10.350	|Save As...	 | 	 10.400	|---------------- | 	 10.410	|Split Diff with | 	 10.420	|Split Patched By | 	 10.500	|---------------- | 	 10.510	|Print		 | 	 10.600	|---------------- | 	 10.610	|Save-Exit	 | 	 10.620	|Exit		 | 			+-----------------+
<p>
Notate che c'è un intervallo tra i numeri.
Qui è dove potete inserire i vostri elementi personali, se lo volete davvero (spesso è meglio lasciare stare i menù standard ed aggiungere un nuovo menù per i vostri elementi personali).
Quando create un sotto-menù, potete aggiungere un altro ".numero" alla priorità.
Così ogni nome nel {menù-item} ha i propri numeri di priorità.
<p>
CARATTERI SPECIALI
<p>
Il {menù-item} in questo esempio è "&File.&Save<Tab>:w".
Ciò evidenzia un punto importante: {menù-item} deve essere una sola parola.
Se volete mettere un punto, spazio o tabulatore nel nome usate la notazione <> (<space> e <tab>, ad esempio) o premettere al carattere un backslash (\).
>
<p>
:menu 10.305 &File.&Do\ It\.\.\.
:exit<CR> 	 In questo esempio, l'elemento di menù "Do It..." contiene uno spazio ed il comando è ":exit<CR>".

<p>
Il carattere <Tab> nel nome del menù viene usato per separare la parte che definisce il nome del menù da quella che da un'indicazione all'utente.
La parte dopo il <Tab> viene visualizzata allineata nel menù.
Nel menù File.Save il nome usato è "&File.&Save<Tab>:w".
Così il nome del menù è File.Save e l'indicazione è ":w".

<p>

<p>
SEPARATORI
<p>
Le linee di separazione, utilizzare per raggruppare assieme elementi di menù, possono essere definite usando un nome che inizi e finisca in un '-'.
Ad esempio "-sep-".
Se si usano diversi separatori i nomi debbono essere differenti.
Altrimenti i nomi non vanno.
Il comando da un separatore non verrà mai eseguito, ma voi dovete definirne comunque uno.
Un solo due punti va bene. Esempio: >
<p>
:amenu 20.510 Edit.-sep3- :
<p>
============================================================================== *42.2*	Comandi dei menù
<p>
Potete definire elementi del menù che esistono solo per alcune modalità.
Ciò funziona proprio come le variazioni nel comando ":map" :
<p>
:menu		Normal, Visual e Operator-pending mode 	:nmenu		Normal mode 	:vmenu		Visual mode 	:omenu		Operator-pending mode 	:menu!		Insert e Command-line mode 	:imenu		Insert mode 	:cmenu		Command-line mode 	:amenu		All modes
<p>
Per evitare che i comandi di un elemento del menù vengano mappati, usate il comando ":noremenu", ":nnoremenu", ":anoremenu", etc.

<p>

<p>
UTILIZZO DI :AMENU
<p>
Il comando ":amenu" è leggermente diverso.
Esso assume che le {keys} che voi date debbano essere eseguite in Normal mode.
Quando Vim è in Visual od Insert mode quando il menù viene usato, Vim prima deve tornare al Normal mode.
":amenu" inserisce un CTRL-C o un CTRL-O per voi.
Per esempio, se usate questo comando: >
<p>
:amenu 90.100 Mine.Find\ Word *
<p>
Allora i comandi del menù risultanti saranno:
<p>
Normal mode:		* 	Visual mode:		CTRL-C * 	Operator-pending mode:	CTRL-C * 	Insert mode:		CTRL-O * 	Command-line mode:	CTRL-C *
<p>
Se siete in modalità Command-line, il CTRL-C abbandonerà il comando sinora scritto.
In Visual e Operator-pending mode CTRL-C fermerà la modalità.
In Insert mode CTRL-O eseguirà il comando e quindi ritornerà in Insert mode.
CTRL-O funziona per un solo comando.
Se avete necessità di usare due o più comandi, inseriteli in una funzione e quindi chiamate questa funzione.
Esempio: >
<p>
:amenu Mine.Next\ File :call <SID>NextFile()<CR> 	:function <SID>NextFile() 	: next 	: 1/^Code 	:endfunction
<p>
Questa opzione del menù va al prossimo file nella lista degli argomenti con ":next".
Poi cerca la linea che inizia con "Code".
Il <SID> prima del nome della funzione è l'ID dello script.
Ciò rende la funzione locale allo script di Vim corrente.
Ciò evita problemi quando una funzione con lo stesso nome viene definita in un altro file di script.
Vedere |<SID>|.
<p>

<p>
MENU' SILENTI
<p>
Il menù esegue le {keys} come le avete scritte.
Per un comando ":" ciò significa che vedrete il comando scritto sulla linea di comando.
Se è un comando lungo, allora apparirà il prompt hit-Enter.
Ciò potrebbe essere molto fastidioso! Per evitare ciò rendete muto il menù.
Ciò viene fatto con l'argomento <silent>.
Ad esempio, prendete al chiamata a NextFile() nell'esempio precedente.
Quando usate questo menù vedrete ciò sulla linea di comando:
<p>
:call <SNR>34_NextFile() ~
<p>
Per evitare la comparsa del testo, inseriamo "<silent>" come primo argomento: >
<p>
:amenu <silent> Mine.Next\ File :call <SID>NextFile()<CR>
<p>
Non utilizzate "<silent>" troppo spesso.
Non è necessario per comandi brevi.
Se realizzate dei menù per qualcun altro, poter vedere il comando eseguito darà un suggerimento su ciò che egli può avere scritto, invece di usare il mouse.

<p>

<p>
ELENCARE I MENU'
<p>
Quando un comando del menù viene usato senza la parte {keys}, esso elenca i menù già definiti.
Potete specificare un questo si comporta richiamando il contenuto di un menù già definito.
Potete specificare un {menù-item} od una parte di esso, per elencare menù specifici.
Esempio: >
<p>
:amenu
<p>
Ciò elenca tutti i menù.
Che è una lista lunga! Meglio specificate il nome di un menù per ottenere una lista più corta: >
<p>
:amenu Edit
<p>
Questo mostra solo gli elementi del menù "Edit" per tutte le modalità.
Per mostrare solo uno specifico elemento del menù per l'Insert mode: >
<p>
:imenu Edit.Undo
<p>
Attenti a scrivere esattamente il nome giusto.
Qui contano maiuscole e minuscole.
Ma l'&' per gli acceleratori può venire omesso.
Il <Tab> e ciò che viene dopo può ugualmente venir lasciato fuori.
<p>

<p>
CANCELLARE I MENU'
<p>
Per cancellare un menù, si utilizza lo stesso comando usato per elencarli, ma con "menu" cambiato in "unmenu".
Così ":menu" diventa ":unmenu", ":nmenu" diventa ":nunmenu", ecc.
Per eliminare l'elemento "Tools.Make" per l'Insert mode: >
<p>
:iunmenu Tools.Make
<p>
Potete cancellare un intero menù, con tutti i propri elementi, usando il nome del menù stesso: Esempio: >
<p>
:aunmenu Syntax
<p>
Ciò cancella il menù Syntax e tutti i suoi elementi.

<p>
============================================================================== *42.3*	Varie
<p>
Potete cambiare l'aspetto dei menù tramite delle flag in 'guioptions'.
Nel valore di default esse sono tutte incluse, tranne "M".
Potete rimuovere una flag con un comando del tipo: >
<p>
:set guioptions-=m < 	m		Quando rimossa la barra dei menù non è visualizzata.

<p>
M		Quando aggiunta non sono caricati i menù di default.

<p>
g		Quando rimossa i menù inattivi sono completamente 			rimossi (Non funziona su tutti i sistemi).

<p>
t		Quando rimossa il "tearoff" non viene abilitato.

<p>
La linea punteggiata in cima ai menù non è una linea di separazione.
Quando selezionate questo elemento il menù viene "teared-off": Viene mostrato entro una finestra separata.
Questo viene chiamato menù tearoff.
E' utile quando usate lo stesso menù spesso.
<p>
Per la traduzione degli elementi dei menù, vedete |:menutrans|.

<p>
Poiché bisogna utilizzare il mouse per selezionare gli elementi dei menù, è bene usare il comando ":browse" per selezionare un file.
Ed il comando ":confirm" per avere una finestra di dialogo invece di un messaggio di errore, ad esempio, quando il buffer corrente ha subito modifiche.
Questi due possono venir combinati: >
<p>
:amenu File.Open :browse confirm edit<CR>
<p>
":browse" fa apparire un navigatore di file per selezionare il file da aprire.
":confirm" fa apparire una finestra di dialogo se il file corrente ha subito modifiche.
Potete scegliere se salvare le modifiche, gettarle via o cancellare il comando.
Per elementi più complicati, le funzioni confirm() e inputdialog() possono venir utilizzate.
I menù di default contengono qualche esempio.
<p>
============================================================================== *42.4*	Toolbar ed i menù popup
<p>
Ci sono due menù speciali: ToolBar e PopUp.
Elementi che iniziano con questi nomi non compaiono nella barra del menù normale.

<p>

<p>
TOOLBAR
<p>
La toolbar compare solo se la flag "T" è inclusa nell'opzione 'guioptions'.
La toolbar utilizza icone piuttosto che testo per rappresentare il comando.
Per esempio, il {menù-item} chiamato "ToolBar.New" provoca la comparsa dell'icona "New" sulla toolbar.
Vim ha un set di 28 icone built-in.
Potete trovare una tabella qui: |builtin-tools|.
La maggior parte di queste è già usata nella toolbar di default.
Potete ridefinirne l'azione (dopo che i menù di default siano a punto).
Potete aggiungere una nuova bitmap per un elemento della toolbar.
Oppure definire un nuovo elemento per la toolbar con una bitmap.
Per esempio, definiamo un nuovo elemento di toolbar con: >
<p>
:tmenu ToolBar.Compile Compila il file corrente 	:amenu ToolBar.Compile :!cc % -o %:r<CR>
<p>

<p>
Ora bisogna creare una nuova icona.
Per gli utenti di MS-Windows, questa deve essere in formato bitmap, con il nome "Compile.bmp".
Per Unix viene usato il formato XPM, il nome è "Compile.xpm".
Le dimensioni devono essere 18x18 pixel (sotto Windows è possibile utilizzare anche altre dimensioni, ma l'aspetto è poco elegante).
Mettete le bitmap nella directory "bitmaps" entro una delle directory del 'runtimepath'.
Ad esempio, per Unix "~/.vim/bitmaps/Compile.xpm".
<p>
Potete definire anche delle didascalie per le icone della toolbar.
Una didascalia è una breve testo che spiega cosa farà un elemento della toolbar.
Per esempio "Open file".
Apparirà quando il puntatore del mouse si trova sull'elemento, senza spostarsi per un attimo.
Ciò è molto utile per capire l'immagine se non fosse chiara.
Esempio: >
<p>
:tmenu ToolBar.Make Run make in the current directory < 	Note: 	Fate molta attenzione alle maiuscole/minuscole.
"Toolbar" e "toolbar" 	sono diverse da "ToolBar"!
<p>
Per eliminare una didascalia, usate il comando |:tunmenu|.

<p>
L'opzione 'toolbar' può essere utilizzata per mostrare del testo invece di una bitmap, oppure entrambi testo ed una bitmap.
Molti usano solo la bitmap poiché il testo prende più spazio.

<p>

<p>
MENU' POPUP
<p>
I menù popup compaiono dove si trova il mouse.
In MS-Windows li attivate facendo clic con il tasto destro del mouse.
Allora potete selezionare un elemento con il tasto sinistro del mouse.
In Unix i menù popup si attivano facendo clic col tasto destro del mouse e poi rilasciandolo.
I menù popup compaiono solo se l'opzione 'mousemodel' è stata impostata su "popup" o su "popup_setpos".
La differenza tra le due è che "popup_setpos" muove il cursore verso la posizione in cui si trova il puntatore del mouse.
Quando si fa clic entro una selezione, questa verrà utilizzata non modificata.
Quando c'è una selezione, ma fate clic fuori di essa, la selezione viene rimossa.
Esistono menù popup separati per ogni modalità.
Così non ci sono mai elementi inattivi come nei menù normali.

<p>
Qual è il significato della vita, dell'universo e di ogni cosa? *42* Douglas Adams, la sola persona che ha conosciuto cosa fosse davvero questa questione è ormai morto, sfortunatamente.
Così adesso potreste chiedervi quale sia il significato della morte...

<p>
==============================================================================
<p>
Capitolo seguente: |usr_43.txt| Utilizzo dei tipi di file
<p>
Copyright: vedere |manual-copyright| vim:tw=78:ts=8:ft=help:norl:
<p>
Per segnalazioni scrivere a vimdoc.it at gmail dot com oppure ad Antonio Colombo azc100 at gmail dot com *usr_43.txt*	Per Vim version 7.2.
Ultima modifica: 2008 Dic 28
<p>
VIM USER MANUAL - di Bram Moolenaar 	 Traduzione di questo capitolo: Gian Piero Carzino
<p>
Utilizzo dei tipi di file
<p>

<p>
Quando state scrivendo un file di un certo tipo, per esempio un programma C o uno script di shell, spesso usate lo stessa scelta di impostazioni e di mappature.
Rapidamente diverrete stanchi di impostarli manualmente ogni volta.
Questo capitolo spiega come farlo automaticamente.
<p>
|43.1|	Plugin per un tipo di file |43.2|	Aggiunta di un tipo di file
<p>
Capitolo seguente: |usr_44.txt| Evidenziazione della vostra sintassi Capitolo precedente: |usr_42.txt| Aggiungere nuovi menù 	 Indice: |usr_toc.txt|
<p>
============================================================================== *43.1*	Plugin per un tipo di file 			*filetype-plugin*
<p>
Come iniziare ad usare i plugin per i tipi di file è già stato discusso qui: |add-filetype-plugin|.
Ma probabilmente non siete soddisfatti dalle impostazioni di default, perché sono state ridotte al minimo.
Supponiamo che per i file in C vogliate impostare l'opzione 'softtabstop' a 4 e definire una mappatura per inserire un commento di tre linee.
Potete farlo con due sole operazioni: 							*your-runtime-dir* 1.
Creare una vostra runtime directory.
Su Unix questa è abitualmente "~/.vim". In questa directory create la directory "ftplugin": >
<p>
mkdir ~/.vim 	mkdir ~/.vim/ftplugin < Se non siete su Unix, controllate il valore dell'opzione 'runtimepath' per vedere dove Vim cercherà la directory "ftplugin": >
<p>
set runtimepath
<p>
< Usare normalmente il primo nome di directory (quello che precede la prima virgola).
Oppure potete premettere un nome di directory all'opzione 'runtimepath' nel vostro file |vimrc| se non vi piace il valore di default.

<p>
2.
Creare il file "~/.vim/ftplugin/c.vim", con il contenuto: >
<p>
setlocal softtabstop=4 	noremap <buffer> <LocalLeader>c o/**************<CR><CR>/<Esc>
<p>
Provate ora ad editare un file C.
Potreste accorgervi che l'opzione 'softtabstop' è impostata a 4.
Ma quando editate un altro file è riportata al valore di default che è zero.
Questo succede perché si è usato il comando ":setlocal".
Questo imposta l'opzione 'softtabstop' solo localmente al buffer.
Appena aprite un altro buffer, viene impostata al valore proprio di quel buffer.
Per un nuovo buffer prenderà il valore di default o quello impostato dall'ultimo comando ":set".

<p>
Analogamente, la mappatura per "\c" sparirà quando si lavora in un altro buffer.
Il comando ":map<buffer>" crea una mappatura locale al buffer corrente.
Questo funziona con ogni comando di mappatura: ":map!", ":vmap", ecc.
Il |<LocalLeader>| è sostituito con il valore della variabile "maplocalleader".

<p>
Trovate degli esempi di plugin per i tipi di file in questa directory: >
<p>
$VIMRUNTIME/ftplugin/
<p>
Ulteriori approfondimenti su come scrivere plugin per i tipi di file si trovano qui: |write-plugin|.

<p>
============================================================================== *43.2*	Aggiunta di un tipo di file
<p>
Se usate un tipo di file che non viene riconosciuto da Vim, ecco come si può farglielo riconoscere.
Avete bisogno di una vostra runtime directory.
Vedere sopra |your-runtime-dir|.
<p>
Creare un file "filetype.vim" che contenga un autocomando per il vostro tipo di file.
(Gli autocomandi sono stati spiegati nella sezione |40.3|).
Esempio: >
<p>
augroup filetypedetect 	au BufNewFile,BufRead *.xyz	setf xyz 	augroup END
<p>
Questo riconoscerà tutti i file che terminano in ".xyz" come tipo di file "xyz".
Il comando ":augroup" pone questo autocomando nel gruppo "filetypedetect".
Questo permette di rimuovere tutti gli autocomandi di riconoscimento del tipo di file facendo ":filetypeoff".
Il comando "setf" imposta l'opzione 'filetype' al suo argomento, a meno che non fosse già impostata.
Questo evita che 'filetype' sia impostato due volte.
<p>
Potete usare molti schemi differenti per individuare il nome del vostro file.
Si possono includere anche i nomi delle directory.
Vedere |autocmd-patterns|.
Per esempio che i file in "/usr/share/scripts/" siano tutti file "ruby", ma non abbiano l'estensione attesa.
Basta aggiungere una riga all'esempio di sopra: >
<p>
augroup filetypedetect 	au BufNewFile,BufRead *.xyz			setf xyz 	au BufNewFile,BufRead /usr/share/scripts/*	setf ruby 	augroup END
<p>
Comunque, se ora aprite il file /usr/share/scripts/README.txt, non è un file di Ruby.
Il pericolo di uno schema che finisce in "*" è che individua immediatamente troppi tipi di file.
Per evitare problemi con ciò, mettete il file filetype.vim in un'altra directory, una che sia alla fine di 'runtimepath'.
Per Unix, ad esempio, potreste usare "~/.vim/ultimo/filetype.vim".
Ora mettete il riconoscimento dei file di testo in ~/.vim/filetype.vim: >
<p>
augroup filetypedetect 	au BufNewFile,BufRead *.txt			setf text 	augroup END
<p>
Questo file viene trovato nel 'runtimepath' per primo.
Poi scrivete questo in ~/.vim/ultimo/filetype.vim, che viene trovato per ultimo: >
<p>
augroup filetypedetect 	au BufNewFile,BufRead /usr/share/scripts/*	setf ruby 	augroup END
<p>
Quello che succede ora è che Vim cerca i file "filetype.vim" in ogni directory del 'runtimepath'.
Per primo viene trovato ~/.vim/filetype.vim.
L'autocomando per individuare i file *.txt è definito lì.
Poi Vim trova il file filetype.vim in $VIMRUNTIME, che è a metà strada nel 'runtimepath'.
Infine viene trovato ~/.vim/ultimo/filetype.vim e viene aggiunto l'autocomando per individuare i file ruby in /usr/share/scripts.
Ora, quando editate /usr/share/scripts/README.txt, gli autocomandi vengono provati nell'ordine in cui sono stati trovati.
Lo schema *.txt è soddisfatto, e così si esegue "setf text" e il tipo di file è impostato a "text".
Anche lo schema per ruby è soddisfatto, e anche "setf ruby" viene eseguito.
Ma siccome 'filetype' è stato già impostato a "text", questa seconda volta non succede nulla.
Quando invece si apre /usr/share/scripts/foobar vengono eseguiti gli stessi autocomandi.
Ma solo quello per ruby è soddisfatto, e "setf ruby" imposta 'filetype' a ruby.

<p>

<p>
RICONOSCIMENTO PER CONTENUTO
<p>
Se il vostro file non può essere riconosciuto semplicemente dal nome, potreste essere in grado di riconoscerlo dal suo contenuto.
Per esempio, molti file di script iniziano con una linea del tipo:
<p>
#!/bin/xyz ~
<p>
Per riconoscere questo file di comandi create un file "scripts.vim" nella vostra runtime directory (lo stesso posto in cui va filetype.vim).
Potrebbe apparire così: >
<p>
if did_filetype() 	 finish 	endif 	if getline(1) =~ '^#!.*[/\\]xyz\>' 	 setf xyz 	endif
<p>
Il primo controllo con did_filetype() serve ad evitare di controllare i contenuti dei file per i quali filetype era già stato riconosciuto dal nome.
Questo evita di sprecare del tempo a controllare il file quando il comando "setf" non farà nulla.
Il file scripts.vim viene letto da un autocomando nel default file filetype.vim.
Quindi l'ordine di verifica è:
<p>
1.
i file filetype.vim prima di $VIMRUNTIME in 'runtimepath' 	2.
la prima parte di $VIMRUNTIME/filetype.vim 	3.
tutti i file scripts.vim in 'runtimepath' 	4.
il resto di $VIMRUNTIME/filetype.vim 	5.
i file filetype.vim dopo $VIMRUNTIME in 'runtimepath'
<p>
Se questo non vi basta, aggiungete un autocomando che sia soddisfatto da ogni file, e che legga uno script od esegua una funzione che controlli il contenuto del file.

<p>
==============================================================================
<p>
Capitolo seguente: |usr_44.txt| Evidenziazione della vostra sintassi
<p>
Copyright: vedere |manual-copyright| vim:tw=78:ts=8:ft=help:norl:
<p>
Per segnalazioni scrivere a vimdoc.it at gmail dot com oppure ad Antonio Colombo azc100 at gmail dot com *usr_44.txt*	Per Vim version 7.2.
Ultima modifica: 2008 Dic 28
<p>
VIM USER MANUAL - di Bram Moolenaar 	 Traduzione di questo capitolo: Giuliano Bordonaro
<p>
Evidenziazione della vostra sintassi
<p>

<p>
Vim nasce con la proprietà di evidenziare circa duecento tipi di file diversi.
Se il file che state modificando non fosse incluso, leggete questo capitolo per scoprire come ottenere che anche questo tipo di file venga evidenziato.
Guardate anche |:syn-define| nel manuale di riferimento.

<p>
|44.1|	Fondamentali comandi della sintassi |44.2|	Parole chiave |44.3|	Raffronti |44.4|	Regioni |44.5|	Elementi annidati |44.6|	Seguendo i gruppi |44.7|	Altri argomenti |44.8|	Cluster |44.9|	Inserimento di un altro file di sintassi |44.10|	Sincronizzazione |44.11|	Installare un file di sintassi |44.12|	Aspetto di un file di sintassi portatile
<p>
Capitolo seguente: |usr_45.txt| Selezionate la vostra lingua Capitolo precedente: |usr_43.txt| Utilizzo dei tipi di file 	 Indice: |usr_toc.txt|
<p>
============================================================================== *44.1*	Fondamentali comandi della sintassi
<p>
Usando un file di sintassi esistente per iniziare risparmierete un sacco di tempo.
Provateci trovando un file di sintassi entro $VIMRUNTIME/syntax per un linguaggio che sia simile.
Questi file vi mostreranno l'aspetto normale di un file di sintassi.
Per capirlo dovete leggere quanto segue.
<p>
Cominciamo con gli argomenti fondamentali.
Prima incominciamo definendo una nuova sintassi, dovete togliere qualsiasi vecchia definizione: >
<p>
:syntax clear
<p>
Ciò non è necessario con il file di sintassi finale, ma molto utile quando state sperimentando.

<p>
In questo capitolo ci sono ulteriori semplificazioni.
Se scrivete un file di sintassi che venga usato da altri, leggete comunque tutto sino alla fine per scoprire i dettagli.

<p>

<p>
ELENCARE GLI ELEMENTI DEFINITI
<p>
Per vedere quali elementi di sintassi siano attualmente definiti usate questo comando: >
<p>
:syntax
<p>
Potete usarlo per vedere quali elementi di sintassi siano stati sinora definiti.
Risulta utile per fare esperimenti con un nuovo file di sintassi.
Mostra anche i colori usati per ciascun elemento, il che aiuta a comprendere di cosa si tratta.
Per elencare gli elementi di un gruppo di sintassi specifico usate: >
<p>
:syntax list {group-name}
<p>
Ciò può anche venire impiegato per elencare dei cluster (spiegati in |44.8|).
Soltanto aggiungendo un @ nel nome.

<p>

<p>
CONFRONTO DEI CARATTERI
<p>
Alcuni linguaggi non sono sensibili al carattere come il Pascal.
Altri, come il C, sono sensibili al carattere.
Dovete specificare quale sia il tipo con i seguenti comandi: >
<p>
:syntax case match 	:syntax case ignore
<p>
L'argomento "match" significa che Vim confronterà il carattere degli elementi di sintassi.
Perciò "int" è diverso da "Int" ed "INT".
Se l'argomento "ignore" viene impiegato tutti gli esempi seguenti saranno equivalenti: "Procedure", "PROCEDURE" e "procedure".
I comandi ":syntax case" possono apparire dovunque in un file di sintassi e riferirsi alle definizioni di sintassi che seguono.
Il più delle volte avete solo un comando ":syntax case" nel vostro file di sintassi; se lavoraste con un tipo insolito di linguaggio contenente sia elementi sensibili al carattere che altri che non lo siano, comunque, avete la facoltà di disseminare il comando ":syntax case" per tutto il file.

<p>
============================================================================== *44.2*	Parole chiave
<p>
I più diffusi elementi fondamentali della sintassi sono le parole chiave.
Per definire una parola chiave usate la seguente forma: >
<p>
:syntax keyword {gruppo} {keyword} ...

<p>
Il {gruppo} è il nome del gruppo di sintassi.
Con il comando ":highlight" potete assegnare un colore ad un {gruppo}.
L'argomento {keyword} è una vera parola chiave.
Ecco qualche esempio: >
<p>
:syntax keyword xType int long char 	:syntax keyword xStatement if then else endif
<p>
Questo esempio usa i nomi di gruppo "xType" e "xStatement".
Per convenzione ogni nome di gruppo è preceduto dal tipo di file per il linguaggio che viene definito.
Questo esempio definisce la sintassi per il linguaggio x (linguaggio di esempio senza un nome particolarmente significativo).
In un file di sintassi per script "csh" potrà essere usato il nome "cshType".
Così il prefisso è uguale al valore di 'filetype'.
Questi comandi fanno si che le parole "int", "long" e "char" vengano evidenziate in un modo e le parole "if", "then", "else" ed "endif" lo siano diversamente.
Ora dovete collegare i nomi del gruppo x ai nomi standard di Vim.
Potete farlo con i seguenti comandi: >
<p>
:highlight link xType Type 	:highlight link xStatement Statement
<p>
Ciò dice a Vim di evidenziare "xType" come "Type" e "xStatement" come "Statement".
Vedere |group-name| per i nomi standard.
<p>

<p>
KEYWORD INSOLITE
<p>
I caratteri usati in una parola chiave debbono essere entro l'opzione 'iskeyword'.
Se usate un altro carattere la parola non potrà trovare mai una corrispondenza.
Vim non fornirà un messaggio per informarvi di ciò.
Il linguaggio x usa il carattere '-' nelle parole chiave.
Ecco come viene fatto: > 	:setlocal iskeyword+=- 	:syntax keyword xStatement when-not
<p>
Il comando ":setlocal" viene usato per cambiare 'iskeyword' soltanto per il buffer corrente.
Ora cambierà il comportamento di comandi come "w" e "*".
Se non volete ciò, non definite una parola chiave ma usate un confronto (spiegato nella prossima sezione).

<p>
Il linguaggio x ammette delle abbreviazioni.
Ad esempio "next" può venire abbreviato in "n", "ne" o "nex".
Potete definirlo usando questo comando: > 	:syntax keyword xStatement n[ext]
<p>
Questo non funzionerà per "nextone", le parole chiave corrispondono sempre e soltanto con parole intere.

<p>
============================================================================== *44.3*	Raffronti
<p>
Pensiamo di definire qualcosa di più complesso.
Volete verificare le corrispondenze di identificatori ordinari.
Per farlo definite un elemento di confronto per la sintassi.
Questo trova corrispondenza con ogni parola che consista di soli caratteri minuscoli: >
<p>
:syntax match xIdentifier /\<\l\+\>/ < 	Note: 	Le keyword prevalgono su di ogni altro elemento di sintassi.
Così le 	parole chiave "if", "then", etc., saranno keyword, come definito 	prima dal comando ":syntax keyword", anche se mantengono il modello 	per xIdentifier.

<p>
La parte finale è un modello, come esso viene usato per la ricerca.
Il // viene impiegato in aggiunta al modello (come avviene in un comando ":substitute".
Potete utilizzare qualsiasi altro carattere, come un più o le virgolette.

<p>
Adesso definiamo un confronto per un commento.
Nel linguaggio x si tratta di qualsiasi cosa a partire da # sino alla fine della linea: >
<p>
:syntax match xComment /#.*/
<p>
Poiché potete usare qualunque modello di ricerca, potete evidenziare cose molto complicate con un elemento di confronto.
Vedere |pattern| sui modelli per la ricerca.

<p>
============================================================================== *44.4*	Regioni
<p>
Nel linguaggio x di esempio le stringhe vengono incluse entro virgolette doppie (").
Per evidenziare stringhe definite una regione.
Serve una regione di inizio (double quote) ed una di fine (double quote).
La definizione è come segue: >
<p>
:syntax region xString start=/"/ end=/"/
<p>
Le direttive "start" ed "end" definiscono i modelli usati per trovare l'inizio o la fine della regione.
Ma come fare con stringhe come questa?
<p>
"A string with a double quote (\") in it" ~
<p>
Ciò crea un problema: Le virgolette doppie nel mezzo della stringa faranno terminare la regione.
Dovrete dire a Vim di saltare ogni virgoletta doppia preceduta da \ entro la stringa.
Fatelo con la parola chiave skip: >
<p>
:syntax region xString start=/"/ skip=/\\"/ end=/"/
<p>
La backslash doppia trova una backslash singola, poiché la backslash è un carattere speciale nei modelli per la ricerca.

<p>
Quando usare una regione in luogo di una verifica di corrispondenza? La differenza principale consiste nel fatto che un elemento di confronto è costituito da un unico modello che deve trovare una corrispondenza esatta.
Una regione inizia dove si trova il modello "start".
Se il modello "end" viene trovato o no non importa.
Così quando l'elemento dipendesse dalla corrispondenza con il modello "end" non potreste utilizzare le regioni.
Altrimenti le regioni sono generalmente più facili da definire.
Ed è più semplice per impiegare elementi annidati, come spiegato nella prossima sezione.

<p>
============================================================================== *44.5*	Elementi annidati
<p>
Osservate questo commento:
<p>
%Get input TODO: Skip white space ~
<p>
Volete evidenziare TODO in grosse lettere gialle, nonostante si trovi dentro un commento che viene evidenziato in blu.
Per consentire a Vim di saperlo definite i seguenti gruppi di sintassi: >
<p>
:syntax keyword xTodo TODO contained 	:syntax match xComment /%.*/ contains=xTodo
<p>
Nella prima linea l'argomento "contained" dice a Vim che questa keyword può esistere soltanto entro altri elementi di sintassi.
La linea successiva ha "contains=xTodo".
Ciò indica che l'elemento di sintassi xTodo è dentro di essa.
Il risultato è che la linea di commento nel suo insieme viene riscontrata con "xComment" e viene fatta blu.
La parola TODO entro essa trova corrispondenza con xTodo ed evidenziata in giallo (L'evidenziazione per xTodo era stata fatta per questo).

<p>

<p>
ANNIDAMENTO RICORSIVO
<p>
Il linguaggio x definisce blocchi di codice tra parentesi graffe.
Ed un blocco di codice può contenere altri blocchi di codice.
Ciò può venir definito così: > 	:syntax region xBlock start=/{/ end=/}/ contains=xBlock
<p>
Supponiamo che abbiate questo testo:
<p>
while i < b { ~ 		if a { ~ 			b = c; ~ 		} ~ 	} ~
<p>
Inizialmente uno xBlock comincia dalla { nella prima linea.
Nella seconda linea si trova un'altra {.
Poiché ci troviamo entro un elemento xBlock ed esso contiene solo se stesso, un elemento annidato xBlock inizierà qui.
Così la linea "b = c" lè dentro la regione xBlock di secondo livello.
Allora una } viene trovata nella linea successiva e corrisponde con il modello di fine della regione.
Ciò termina l'xBlock annidato.
Poiché la } si trova nella regione annidata, viene nascosta dalla regione del primo xBlock.
Così all'ultima } termina la regione del primo xBlock.
<p>

<p>
TROVARE LA FINE
<p>
Considerate i seguenti due elementi di sintassi: >
<p>
:syntax region xComment start=/%/ end=/$/ contained 	:syntax region xPreProc start=/#/ end=/$/ contains=xComment
<p>
Definite un commento come qualsiasi cosa a partire da % sino al termine della linea.
Una direttiva di preprocessore è qualunque cosa a partire da # sino al termine della linea.
Poiché potete avere un commento su di una linea di preprocessore, la definizione di preprocessore include un argomento "contains=xComment".
Adesso vediamo cosa succede con questo testo:
<p>
#define X = Y % Comment text ~ 	int foo = 1; ~
<p>
Ciò che vedete è che anche la seconda linea viene evidenziata come xPreProc.
La direttiva preprocessore potrebbe terminare alla fine della linea.
Ciò perché avete usato "end=/$/".
Così cosa è andato male? Il problema è il commento contenuto.
Il commento parte con % e finisce alla fine della linea.
Dopo la fine del commento la sintassi del preprocessore continua.
Ciò succede dopo che si è vista la fine della linea, così viene inclusa anche la linea successiva.
Per evitare questo problema e che un elemento di sintassi contenuto si mangi la necessaria fine della linea, impiegate l'argomento "keepend".
Ciò si occuperà del fatto di trovare una doppia fine della linea: >
<p>
:syntax region xComment start=/%/ end=/$/ contained 	:syntax region xPreProc start=/#/ end=/$/ contains=xComment keepend
<p>

<p>
CONTENIMENTO DI MOLTI ELEMENTI
<p>
Potete usare l'argomento contains per specificare che tutto può essere compreso.
Ad esempio: >
<p>
:syntax region xList start=/\[/ end=/\]/ contains=ALL
<p>
Tutti gli elementi di sintassi verranno compresi entro soltanto questo.
Esso contiene anche se stesso, ma non alla stessa posizione (che potrebbe causare un loop senza fine).
Potete specificare che alcuni gruppi non siano compresi.
Così comprende tutti i gruppi ma solo quelli che vengono elencati: > 	:syntax region xList start=/\[/ end=/\]/ contains=ALLBUT,xString
<p>
Con l'elemento "TOP" potete inserire tutti gli elementi che non abbiano un argomento "contained".
"CONTAINED" viene usato solo per includere elementi con un argomento "contained".
Vedere |:syn-contains| per i dettagli.
<p>
============================================================================== *44.6*	Seguendo i gruppi
<p>
Il linguaggio x comprende dichiarazioni in questa forma:
<p>
if (condition) then ~
<p>
Volete evidenziare i tre elementi in modo diverso.
Ma "(condition)" e "then" potrebbero apparire anche altrove, dove sono richieste diverse evidenziazioni.
Potete fare così: >
<p>
:syntax match xIf /if/ nextgroup=xIfCondition skipwhite :syntax match xIfCondition /([^)]*)/ contained nextgroup=xThen skipwhite :syntax match xThen /then/ contained
<p>
L'argomento "nextgroup" specifica quale argomento possa essere il successivo.
Ciò non è necessario.
Se nessuno degli elementi che avete specificato venisse trovato non succederebbe nulla.
Ad esempio, in questo testo:
<p>
if not (condition) then ~
<p>
L'"if" corrisponde con xIf.
"not" non trova corrispondenze con la specificata xIfCondition di nextgroup, così solo l'"if" viene evidenziato.

<p>
L'argomento "skipwhite" dice a Vim che gli spazi bianchi (spazi e tabulazioni) possono apparire tra gli elementi.
Argomenti analoghi sono "skipnl", che consente un'interruzione di linea tra gli elementi, e "skipempty", che permette linee vuote.
Notate che "skipnl" non salta una linea vuota, talvolta trova corrispondenza dopo l'interruzione di linea.

<p>
============================================================================== *44.7*	Altri argomenti
<p>
MATCHGROUP
<p>
Quando definite una regione l'intera regione viene evidenziata secondo il nome di gruppo specificato.
Per evidenziare il testo incluso tra parentesi () con il gruppo xInside, ad esempio, usate il comando seguente: >
<p>
:syntax region xInside start=/(/ end=/)/
<p>
Immaginiamo che vogliate evidenziare le parentesi in modo diverso.
Potete farlo con molte contorte dichiarazioni di regione, o potete usare l'argomento "matchgroup".
Ciò dice a Vim di evidenziare l'inizio e la fine di una regione con un diverso gruppo di evidenziazione (in questo caso, il gruppo xParen): >
<p>
:syntax region xInside matchgroup=xParen start=/(/ end=/)/
<p>
L'argomento "matchgroup" viene applicato alla corrispondenza di start e di end che lo seguono.
Nell'esempio precedente sia start che end vengono evidenziati con xParen.
Per evidenziare end con xParenEnd: >
<p>
:syntax region xInside matchgroup=xParen start=/(/ 		\ matchgroup=xParenEnd end=/)/
<p>
Un effetto collaterale dell'uso di "matchgroup" è che gli elementi contenuti non trovino corrispondenza all'inizio od alla fine della regione.
L'esempio per "transparent" usa ciò.

<p>

<p>
TRANSPARENT
<p>
In un file in linguaggio C vorreste evidenziare il testo () dopo un "while" in modo differente dal testo tra parentesi dopo un "for".
In entrambi i casi potrebbero esservi annidati degli elementi (), che dovrebbero essere evidenziati allo stesso modo.
Dovete essere certi che l'evidenziazione di () cessi con la corrispondenza).
Ecco un modo per farlo: > 	:syntax region cWhile matchgroup=cWhile start=/while\s*(/ end=/)/ 		\ contains=cCondNest 	:syntax region cFor matchgroup=cFor start=/for\s*(/ end=/)/ 		\ contains=cCondNest 	:syntax region cCondNest start=/(/ end=/)/ contained transparent
<p>
Ora potete dare con cWhile e cFor diverse evidenziazioni.
L'elemento cCondNest può apparire in uno di essi, ma escludere l'evidenziazione dell'elemento che è contenuto.
L'argomento "transparent" causa ciò.
Notare che l'argomento "matchgroup" ha lo stesso gruppo dell'elemento stesso.
Perché definirlo allora? Bene, l'effetto collaterale di usare matchgroup è che elementi contenuti non vengono trovati allora con l'elemento start.
Ciò evita che il gruppo cCondNest trovi la ( appena dopo il "while" od il "for".
Se ciò avvenisse potrebbe accoppiare tutto il testo sino alla corrispondenza con ) e la regione continuerebbe dopo di esso.
Adesso cCondNest trova la corrispondenza solo con il modello start, dopo la prima (.

<p>

<p>
OFFSET
<p>
Poniamo che vogliate definire una regione per il testo tra ( e ) dopo un "if".
Ma non volete includere l'"if" o le ( e ).
Potete fare questo specificando gli offset per i modelli.
Esempio: >
<p>
:syntax region xCond start=/if\s*(/ms=e+1 end=/)/me=s-1
<p>
L'offset per il modello di start è "ms=e+1".
"ms" sta per Match Start.
Ciò definisce un offset per l'inizio della corrispondenza.
Normalmente la verifica parte dal modello di ricerca.
"e+1" significa che la verifica adesso partirà al termine del modello di ricerca e precisamente da un carattere dopo.
L'offset per il modello end è "me=s-1".
"me" sta per Match End.
"s-1" significa l'inizio dal modello di ricerca ed allora un carattere prima. Il risultato è che in questo testo:
<p>
if (foo == bar) ~
<p>
Soltanto il testo "foo == bar" verrà evidenziato come xCond.

<p>
Altro sugli offset qui: |:syn-pattern-offset|.

<p>

<p>
ONELINE
<p>
L'argomento "oneline" indica che la regione non attraversa il limite di una linea.
Ad esempio: >
<p>
:syntax region xIfThen start=/if/ end=/then/ oneline
<p>
Ciò definisce una regione che inizia dall'"if" e termina al "then".
Ma se non ci fosse un "then" dopo l'"if", la regione non corrisponderebbe.

<p>
Note: 	Usando "oneline" la regione non inizia se il modello end non si trova 	nella stessa linea.
Senza "oneline" Vim non potrà trovare una 	corrispondenza per il modello di end pattern.
La regione inizia lo 	stesso quando il modello di end non venisse trovato nel resto del 	file.

<p>

<p>
LINEE CHE VANNO A CAPO E COME EVITARLE
<p>
Adesso le cose diventano un po' più complesse.
Definiamo una linea di preprocessore.
Questa inizia con un # nella prima colonna e continua sino alla fine della linea.
Una linea che finisca con \ rende la linea successiva una linea di continuazione.
Il modo per gestire ciò è consentire che un elemento di sintassi contenga un modello di continuazione: >
<p>
:syntax region xPreProc start=/^#/ end=/$/ contains=xLineContinue 	:syntax match xLineContinue "\\$" contained
<p>
In questo caso sebbene xPreProc verifichi normalmente una sola linea, il gruppo in essa contenuto (vale a dire xLineContinue) gli consente di procedere per più di una sola linea.
Ad esempio, verificherà entrambe queste linee:
<p>
#define SPAM spam spam spam \ ~ 			bacon and spam ~
<p>
In questo caso è quanto volevate.
Se non fosse così potreste imporre alla regione di essere su di una sola linea aggiungendo "excludenl" al modello contenuto.
Ad esempio, volete evidenziare "end" in xPreProc, ma soltanto alla fine della linea.
Per evitare che xPreProc continui anche sulla linea successiva, come fa xLineContinue, usate "excludenl" in questa maniera: >
<p>
:syntax region xPreProc start=/^#/ end=/$/ 		\ contains=xLineContinue,xPreProcEnd 	:syntax match xPreProcEnd excludenl /end$/ contained 	:syntax match xLineContinue "\\$" contained
<p>
"excludenl" deve essere posto prima del modello.
Se c'è "xLineContinue" non si può usare "excludenl", una corrispondenza con esso estenderebbe xPreProc alla prossima linea come prima.

<p>
============================================================================== *44.8*	Cluster
<p>
Una delle cose che dovete sapere quando iniziate a scrivere un file di sintassi è che state per generare molti gruppi di sintassi.
Vim vi consente di definire una collezione di gruppi di sintassi che viene chiamata cluster.
Immaginate di avere un linguaggio che contenga cicli di for, dichiarazioni if, cicli while e funzioni.
Ognuno di essi contiene gli stessi elementi di sintassi: numeri ed identificatori.
Potete definirli così: >
<p>
:syntax match xFor /^for.*/ contains=xNumber,xIdent 	:syntax match xIf /^if.*/ contains=xNumber,xIdent 	:syntax match xWhile /^while.*/ contains=xNumber,xIdent
<p>
Vi tocca ripetere lo stesso "contains=" ogni volta.
Se volete aggiungere un altro elemento contenuto, dovete aggiungerlo tre volte.
I cluster di sintassi semplificano queste definizioni consentendovi di avere un solo cluster che stia per molti gruppi di sintassi.
Per definire un cluster per i due elementi che i tre gruppi contengono usate il seguente comando: >
<p>
:syntax cluster xState contains=xNumber,xIdent
<p>
I cluster vengono usati entro altri elementi di sintassi proprio come ogni gruppo di sintassi.
Il loro nome inizia con @.
Potete definire i tre gruppi in questo modo: >
<p>
:syntax match xFor /^for.*/ contains=@xState 	:syntax match xIf /^if.*/ contains=@xState 	:syntax match xWhile /^while.*/ contains=@xState
<p>
Potete aggiungere nuovi nomi di gruppo a questo cluster con l'argomento "add": >
<p>
:syntax cluster xState add=xString
<p>
Potete togliere dei gruppi di sintassi da questo elenco altrettanto facilmente: >
<p>
:syntax cluster xState remove=xNumber
<p>
============================================================================== *44.9*	Inserimento di un altro file di sintassi
<p>
La sintassi del linguaggio C++ include quella del linguaggio C.
Poiché non volete scrivere due file di sintassi potrete fare leggere il file di sintassi per C++ entro uno per C usando il comando seguente: >
<p>
:runtime! syntax/c.vim
<p>
Il comando ":runtime!" cerca in 'runtimepath' tutti i file "syntax/c.vim".
Ciò fa sì che la parte C della sintassi C++ sia definita come per i file C.
Se aveste sostituito il file di sintassi c.vim, o aggiunto elementi con un file extra, questi verrebbe pure caricati.
Dopo aver caricato gli elementi di sintassi C gli elementi specifici per C++ potranno essere definiti.
Ad esempio, aggiungere keyword che non vengono usate in C: >
<p>
:syntax keyword cppStatement	new delete this friend using
<p>
Funzionerà esattamente come in ogni altro file di sintassi.

<p>
Adesso consideriamo il linguaggio Perl.
Uno script Perl consiste di due parti distinte: una sezione di documentazione in formato POD, e il programma vero e proprio, scritto in Perl.
La sezione POD comincia con "=head" e finisce con "=cut".
Volete definire la sintassi POD in un solo file ed usarlo dal file di sintassi di Perl.
Il comando ":syntax include" legge in un file di sintassi ed immagazzina gli elementi che questo ha definito in un cluster di sintassi.
Per Perl le dichiarazioni sono come segue: >
<p>
:syntax include @Pod <sfile>:p:h/pod.vim 	:syntax region perlPOD start=/^=head/ end=/^=cut/ contains=@Pod
<p>
Quando in un file Perl viene trovato "=head", la regione perlPOD inizia.
In questa regione è contenuto il cluster @Pod.
Tutti gli elementi definiti come elementi di massimo livello nei file di sintassi pod.vim si troveranno qui.
Quando verrà trovato "=cut", la regione finirà e ritorneremo agli elementi definiti nel file di Perl.
Il comando ":syntax include" è abbastanza intelligente da ignorare un comando ":syntax clear" nel file incluso.
Ed un argomento come "contains=ALL" conterrà solo elementi definiti nel file in esso incluso, non nel file che lo include.
La parte "<sfile>:p:h/" usa il nome del file corrente (<sfile>), lo espande al suo path completo (:p) ed allora prende l'intestazione (:h).
Ciò risulta nel nome della directory del file.
Ciò causa che il file pod.vim venga incluso nella directory stessa.

<p>
============================================================================== *44.10*	Sincronizzazione
<p>
I compilatori la fanno semplice.
Partono dall'inizio del file e lo interpretano direttamente.
Vim non fa ciò così facilmente.
Deve partire dal mezzo, dove si è iniziato a lavorare.
Come fare a dirgli dove si trova? Il segreto sta nel comando ":syntax sync".
Spiega a Vim come capire dove si trovi.
Ad esempio, il comando che segue dice a Vim di cercare all'indietro l'inizio o la fine di un commento in stile C ed iniziare da li a colorare la sintassi: >
<p>
:syntax sync ccomment
<p>
Potete affinare questo processo con qualche argomento.
L'argomento "minlines" dice a Vim il minimo numero di linee da vedere all'indietro, e "maxlines" dice all'editor il massimo numero di linee da scandire.
Ad esempio, il comando seguente dice a Vim di osservare almeno 10 linee prima della cima dello schermo: >
<p>
:syntax sync ccomment minlines=10 maxlines=500
<p>
Se non riesce a capire dove si trovi entro questo spazio comincerà a guardare sempre più distante sino a riuscirvi.
Ma non guarderà indietro più di 500 linee.
(Un grosso "maxlines" rallenta il processo.
Uno piccolo potrebbe causare il fallimento di sincronizzazione.) Per sincronizzare un po' più rapidamente dite a Vim quali elementi di sintassi possono essere saltati.
Tutte le corrispondenze e le regioni che richiedono solo di essere usate mentre viene mostrato il testo possono essere date con l'argomento "display".
Di default, il commento che deve essere trovato verrà colorato come parte del gruppo Comment syntax.
Se voleste colorare le cose in altro modo potete specificare un gruppo di sintassi differente: >
<p>
:syntax sync ccomment xAltComment
<p>
Se il vostro linguaggio di programmazione non prevede commenti in stile C potete provare un altro metodo di sincronizzazione.
Il modo più semplice consiste nel dire a Vim di spaziare all'indietro di un certo numero di linee e tentare di riuscire a capire le cose da li.
Il comando seguente dice a Vim di andare indietro di 150 linee ed iniziare ad interpretare da lì: >
<p>
:syntax sync minlines=150
<p>
Un valore grosso di "minlines" può rendere Vim più lento, specialmente scorrendo il file all'indietro.
In ultimo, potete specificare un gruppo di sintassi per cercare usando questo comando: >
<p>
:syntax sync match {sync-group-name} 		\ grouphere {group-name} {pattern}
<p>
Esso dice a Vim che quando vede {pattern} il gruppo di sintassi chiamato {group-name} comincia subito dopo il modello dato.
Il {sync-group-name} viene usato per dare un nome a questa specifica di sincronizzazione.
Ad esempio negli script del programma sh una dichiarazione if inizia con "if" e si conclude con "fi": >
<p>
if [ --f file.txt ] ; then ~ 		echo "File exists" ~ 	fi ~
<p>
Per definire una direttiva "grouphere" per questa sintassi usate il seguente comando: >
<p>
:syntax sync match shIfSync grouphere shIf "\<if\>"
<p>
L'argomento "groupthere" dice a Vim che il modello finisce un gruppo.
Ad esempio, la fine del gruppo if/fi è come segue: >
<p>
:syntax sync match shIfSync groupthere NONE "\<fi\>"
<p>
In questo esempio il NONE dice a Vim che non siete entro una regione di sintassi speciale.
Particolarmente non vi trovate entro un blocco if.
<p>
Potete anche definire corrispondenze e regioni che siano senza "grouphere" od argomenti di "groupthere".
Questi gruppi sono per gruppi di sintassi saltati durante la sincronizzazione.
Ad esempio quanto segue salta ogni cosa entro {}, anche se corrisponderebbe normalmente con altri metodi di sincronizzazione: >
<p>
:syntax sync match xSpecial /{.*}/
<p>
Di più circa la sincronizzazione nel manuale di riferimento : |:syn-sync|.

<p>
============================================================================== *44.11*	Installare un file di sintassi
<p>
Quando il vostro nuovo file di sintassi è pronto per essere usato mettetelo entro una directory chiamandola "syntax", nel 'runtimepath'.
Per Unix potrebbe essere "~/.vim/syntax".
Il nome del file di sintassi deve essere uguale al tipo di file con aggiunto ".vim".
Così per il linguaggio x il path completo potrebbe essere:
<p>
~/.vim/syntax/x.vim ~
<p>
Dovete anche far sì che il tipo di file venga riconosciuto.
Vedere |43.2|.
<p>
Se il vostro file lavora bene potreste desiderare di renderlo disponibile per altri utenti di Vim.
Prima leggete la prossima sezione per essere certi che il vostro file funzioni bene per altri.
Allora inviate un messaggio e-mail al manutentore di Vim: <maintainer@vim.org>.
Così spiegate come il tipo di file può essere riconosciuto.
Con un po' di fortuna il vostro file verrà incluso nella prossima versione di Vim!
<p>

<p>
AGGIUNGERE AD UN FILE DI SINTASSI ESISTENTE
<p>
Stiamo immaginando che stiate aggiungendo un file di sintassi completamente nuovo.
Quando un file di sintassi esistente funziona, ma sono stati persi alcuni elementi, potete aggiungere degli elementi in un file separato.
Ciò evita di cambiare i file di sintassi distribuiti che possono andare perduti installando una nuova versione di Vim.
Scrivete comandi di sintassi nel vostro file possibilmente usando nomi di gruppo dalla sintassi esistente.
Ad esempio per aggiungere nuovi tipi di variabile al file di sintassi di C: > 	:syntax keyword cType off_t uint
<p>
Scrivete il file con lo stesso nome del file di sintassi originale.
In questo caso "c.vim".
Piazzatelo entro una directory vicino alla fine di 'runtimepath'.
Ciò fa sì che venga caricato dopo il file di sintassi originale.
Per Unix potrebbe essere:
<p>
~/.vim/after/syntax/c.vim ~
<p>
============================================================================== *44.12*	Aspetto di un file di sintassi portatile
<p>
Non sarebbe bello se tutti gli utenti di Vim si scambiassero i file di sintassi? Per renderlo possibile il file di sintassi deve seguire poche linee guida.

<p>
Cominciate con un header che spieghi a cosa serve il file di sintassi, chi lo mantiene e quale sia l'ultimo aggiornamento.
Non includete troppe informazioni circa la storia delle modifiche, poca gente lo leggerà.
Esempio: >
<p>
" Vim syntax file 	" Language:	C 	" Maintainer:	Bram Moolenaar <Bram@vim.org> 	" Last Change:	2001 Jun 18 	" Remark:	Included by the C++ syntax.

<p>
Usate lo stesso aspetto degli altri file di sintassi.
Usando un file di sintassi esistente come esempio risparmierete un mucchio di tempo.

<p>
Scegliete un buono, descrittivo nome per il vostro file di sintassi.
Usate lettere minuscole e cifre.
Non fatelo troppo lungo, viene usato in molti posti: Il nome del file di sintassi "nome.vim", 'filetype', b:current_syntax e l'inizio di ogni gruppo di sintassi (nameType, nameStatement, nameString, etc.).

<p>
Iniziate con una prova per "b:current_syntax".
Se è definito, qualche altro file di sintassi, trovato prima in 'runtimepath' era già stato caricato.
>
<p>
if exists("b:current_syntax") 	 finish 	endif
<p>
Per mantenere la compatibilità con Vim 5.8 usate: >
<p>
if version < 600 	 syntax clear 	elseif exists("b:current_syntax") 	 finish 	endif
<p>
Mettete "b:current_syntax" al nome della sintassi alla fine.
Non dimenticate che i file inclusi fanno ciò anche, potreste dover resettare "b:current_syntax" se includete due file.

<p>
Se volete che il vostro file di sintassi funzioni con Vim 5.x, aggiungete una prova per v:version.
Vedere yacc.vim per un esempio.
<p>
Non includete alcunché sia una preferenza dell'utente.
Non impostate 'tabstop', 'expandtab', etc.
Ciò appartiene al plugin di un filename.
<p>
Non includete mappature od abbreviazioni.
Aggiungete soltanto l'impostazione 'iskeyword' se è realmente necessario per riconoscere le keyword.

<p>
Per consentire agli utenti di scegliere i propri colori preferiti, definite un nome di gruppo differente per ogni tipo di elemento evidenziato.
Poi collegate ognuno di essi ad uno dei gruppi di evidenziazione standard.
Ciò ne renderà possibile il funzionamento con ogni schema di colore.
Se scegliete dei colori specifici, potrebbero risultare sgradevoli con alcuni schemi di colore.
E non dimenticate che alcuni usano un differente colore di fondo, oppure hanno a disposizione solo otto colori.

<p>
Per il collegamento usate "hi def link", in modo che l'utente possa scegliere evidenziazioni diverse prima che il vostro file di sintassi sia caricato.
Esempio: >
<p>
hi def link nameString	String 	 hi def link nameNumber	Number 	 hi def link nameCommand	Statement 	 ...
etc ...
<p>
Aggiungete l'argomento "display" agli elementi che non si usano quando si effettua una sincronizzazione, per velocizzare lo scorrimento all'indietro e CTRL-L.

<p>
==============================================================================
<p>
Capitolo seguente: |usr_45.txt| Selezionate la vostra lingua
<p>
Copyright: vedere |manual-copyright| vim:tw=78:ts=8:ft=help:norl:
<p>
*usr_45.txt*	Per Vim version 7.2.
Ultima modifica: 2008 Nov 15
<p>
VIM USER MANUAL - di Bram Moolenaar 	 Traduzione di questo capitolo: Paolo Giovannelli
<p>
Selezionate la vostra lingua
<p>
I messaggi in Vim possono essere dati in molte lingue.
Questo capitolo spiega come cambiare quale venga usata.
Così vengono illustrati i diversi modi per lavorare con file in varie lingue.

<p>
|45.1|	Lingua per i messaggi |45.2|	Lingua per i menù |45.3|	Utilizzare un'altra codifica |45.4|	Elaborare file con una codifica differente |45.5|	Impostare la lingua del testo
<p>
Capitolo seguente: |usr_90.txt| Installare Vim Capitolo precedente: |usr_44.txt| Evidenziazione della vostra sintassi 	 Indice: |usr_toc.txt|
<p>
============================================================================== *45.1*	Lingua per i messaggi
<p>
Quando avviate Vim, esso controlla l'ambiente di lavoro per trovare quale lingua stiate utilizzando.
Generalmente ciò funziona bene ed ottenete dei messaggi nella vostra lingua (se sono disponibili).
Per vedere quale sia la lingua corrente, usate questo comando: >
<p>
:language
<p>
Se risponde con "C", ciò significa che viene impiegato il default, ovvero l'inglese.

<p>
Note: 	L'utilizzo di lingue diverse è possibile solo se Vim era stato 	compilato appositamente per gestirlo.
Per scoprire se funziona, 	utilizzate il comando ":version" e verificate l'output per "+gettext" 	e "+multi_lang".
Se ci sono, siete a posto.
Altrimenti, se vedete 	"-gettext" o "-multi_lang dovrete cercare un altro Vim.
Cosa fare se voleste i vostri messaggi in una lingua diversa? Ci sono diversi modi.
Quale potreste usare dipende dalle capacità del vostro sistema.
Il primo modo consiste nell'impostare l'ambiente di lavoro per la lingua desiderata prima di avviare VIM.
Esempio per Unix: >
<p>
env LANG=de_DE.ISO_8859-1 vim
<p>
Ciò funziona solamente se la lingua è presente nel vostro sistema.
Il vantaggio è che tutti i messaggi della GUI e gli oggetti nelle librerie useranno anch'essi la lingua giusta.
Uno svantaggio è che dovete farlo prima di avviare VIM.
Se invece volete cambiare la lingua mentre Vim è in esecuzione, potete usare il secondo metodo: >
<p>
:language fr_FR.ISO_8859-1
<p>
In questo modo potete provare diversi nomi per la vostra lingua.
Otterrete un messaggio di errore quando tale funzione non fosse supportata dal vostro sistema.
Non ottenete alcun messaggio d'errore quando i messaggi tradotti non siano disponibili.
VIM automaticamente ritornerà ad usare l'inglese.
Per sapere quali lingue sono supportate cercate la cartella ove esse sono elencate.
Nel mio sistema, ad esempio, è "/usr/share/locale".
Su alcuni sistemi "/usr/lib/locale".
La pagina del manuale per "setlocale" potrebbe darvi un'indicazione su dove essa si trovi nel vostro sistema.
State attenti a digitare il nome esattamente come potrebbe essere.
Le maiuscole e le minuscole sono importanti, ed i caratteri '-' e '_' vengono facilmente confusi.

<p>
Potete anche impostare una lingua diversa per i messaggi, il testo in lavorazione ed il formato della data.
Vedere |:language|.
<p>

<p>
REALIZZARE DA SOLI LA TRADUZIONE DEI MESSAGGI
<p>
Se i messaggi tradotti non fossero disponibili nella vostra lingua, potreste scriverli voi stessi.
Per far ciò, procuratevi il codice sorgente di Vim ed il pacchetto gettext GNU.
Dopo aver scompattato i sorgenti, potrete trovare le istruzioni nella cartella src/po/README.txt.

<p>
Non è particolarmente difficile fare la traduzione.
Non avrete bisogno di essere programmatori.
Dovrete semplicemente conoscere sia l'inglese che la lingua in cui state traducendo, ovviamente.
Quando sarete soddisfatti con la traduzione pensate a renderla disponibile ad altri.
Caricatela su vim-online (http://vim.sf.net) o spedendo un mail al mantainer Vim <maintainer@vim.org> o entrambe le cose.

<p>
============================================================================== *45.2*	Lingua per i menù
<p>
I menù di default sono in inglese.
Per poter impiegare la vostra lingua locale devono essere tradotti.
Normalmente ciò viene svolto automaticamente per voi se l'ambiente di lavoro è impostato per la vostra lingua, proprio come per i messaggi.
Non sarà necessario fare di più per questo.
Ma ciò funziona solo se le traduzioni nella vostra lingua sono disponibili.
Supponete di essere in Germania, di avere impostato la lingua tedesca e di preferire "file" a "Datei".
Potreste ripassare ai menù in inglese in questo modo: >
<p>
:set langmenu=none
<p>
E' anche possibile specificare una lingua: >
<p>
:set langmenu=nl_NL.ISO_8859-1
<p>
Come sopra la differenza tra "-" e "_" è rilevante.
Ad ogni modo, la differenza tra le maiuscole e le minuscole è ignorata in questo contesto.
L'opzione 'langmenu' deve essere impostata prima che i menù vengano caricati.
Dopo aver definito i menù infatti, cambiare 'langmenu' non ottiene alcun effetto.
Comunque, inserite il comando per impostare 'langmenu' nel vostro file "vimrc".
Se realmente volete cambiare la lingua dei menù mentre utilizzate Vim, potete farlo in questo modo: >
<p>
:source $VIMRUNTIME/delmenu.vim 	:set langmenu=de_DE.ISO_8859-1 	:source $VIMRUNTIME/menu.vim
<p>
C'è solo uno svantaggio: Tutti i menù definiti da voi se ne andranno.
Dovrete perciò ridefinirli.

<p>

<p>
REALIZZARE DA SOLI LA TRADUZIONE DEI MENU'
<p>
Per sapere quali traduzioni dei menù sono disponibili, guardate in questa cartella:
<p>
$VIMRUNTIME/lang ~
<p>
I file sono denominati menù_{linguaggio}.vim.
Se non vedete la lingua che intendete utilizzare, potete fare voi stessi le traduzioni.
Il modo più semplice per farlo è copiare uno dei file lingua esistenti e modificarlo.
Prima trovate il nome della vostra lingua con il comando ":language".
Usate questo nome, ma con tutte le lettere rese minuscole.
Allora copiate il file nella vostra cartella di runtime, quella trovata prima in 'runtimepath'.
Ad esempio, in Unix sarebbe: >
<p>
:!cp $VIMRUNTIME/lang/menu_ko_kr.euckr.vim ~/.vim/lang/menu_nl_be.iso_8859-1.vim
<p>
Troverete suggerimenti per la traduzione in "$VIMRUNTIME/lang/README.txt".

<p>
============================================================================== *45.3*	Utilizzare un'altra codifica.

<p>
Vim osserva che i file che state per aprire sono codificati per la vostra lingua.
Per molte lingue europee tale codifica è "latin1".
Allora ogni byte è un solo carattere.
Ciò significa che sono possibili 256 differenti caratteri.
Per le lingue asiatiche ciò non è sufficiente.
Queste usano principalmente una codifica a doppio byte, che rende disponibili oltre 10000 possibili caratteri.
Ciò non è ancora sufficiente quando un testo contenga molte lingue diverse.
Qui è dove entra Unicode.
E' stato progettato per includere tutti i caratteri utilizzati nelle lingue comunemente usate.
Questa è la "super codifica che sostituisce tutte la altre".
Ma non è ancora molto utilizzata.
Fortunatamente, Vim supporta tre tipi di codifica.
E, con alcune restrizioni, potete utilizzarle anche quando il vostro ambiente di lavoro usa un'altra lingua rispetto al testo.
Ciononostante, quando aprite solo dei file codificati nella vostra lingua, il default dovrebbe lavorare bene e non dovrete fare altro.
Ciò che segue è importante solo quando lavorate con lingue differenti.

<p>
Note: 	L'utilizzo di molteplici codifiche funziona solo se Vim era stato 	compilato per gestirle.
Per scoprire se ciò funziona, utilizzate il 	comando ":version" e cercate nell'output "+multi_byte".
Se lo trovate 	significa che siete a posto.
Se invece vedete "-multi_byte" significa 	che dovrete cercare un'altra versione di Vim.

<p>

<p>
USARE UNICODE NELLA GUI
<p>
Il bello di Unicode è che le altre codifiche possono essere convertite ad esso e viceversa senza perdere informazioni.
Quando impostate Vim per utilizzare Unicode internamente, potrete lavorare con file in qualsiasi codifica.
Sfortunatamente, il numero di sistemi che supportano Unicode è ancora limitato.
Così è improbabile che la vostra lingua lo utilizzi.
Dovrete dire a Vim che volete usare Unicode, e come interfacciarsi con il resto del sistema.
Iniziamo con la versione GUI di Vim, che può usare i caratteri Unicode.
Ciò potrebbe funzionare: >
<p>
:set encoding=utf-8 	:set guifont=-misc-fixed-medium-r-normal--18-120-100-100-c-90-iso10646-1
<p>
L'opzione 'encoding' dice a Vim quale codifica di caratteri utilizzate.
Ciò si applica al testo nei buffer (i file su cui state lavorando), ai registri, agli script di Vim, etc.
Potete guardare 'encoding' come un'impostazione per le funzioni interne di Vim.
Questo esempio presuppone che abbiate questo font installato nel vostro sistema.
Il nome nell'esempio è per il sistema Xwindow.
Questo font si trova in un pacchetto che viene utilizzato per migliorare xterm con il supporto Unicode.
Se non avete questo font, potete trovarlo qui:
<p>
http://www.cl.cam.ac.uk/~mgk25/download/ucs-fonts.tar.gz ~
<p>
Per MS-Windows, alcuni font hanno un numero limitato di caratteri Unicode.
Provate usando il font "Courier New".
Potete usare il menù Edit/Select Font per selezionare e provare i font disponibili.
Tuttavia solo i font con ampiezza fissa posso essere utilizzati.
>
<p>
:set guifont=courier_new:h12
<p>
Se non dovesse funzionare, cercate di ottenere un fontpack.
Se Microsoft non l'ha spostato, potete trovarlo qui: 	http://www.microsoft.com/typography/fonts/default.aspx ~
<p>
Ora avete detto a Vim di usare Unicode internamente e di visualizzare il testo con un font Unicode.
I caratteri che digitato arrivano ancora nella codifica originale del vostro originale.
Ciò richiede di convertirli in Unicode.
Dite a Vim il linguaggio da cui convertire con l'opzione 'termencoding'.
Potete farlo così: > 	 	:let &termencoding = &encoding 	:set encoding=utf-8
<p>
Ciò assegna il vecchio valore di 'encoding' a 'termencoding', prima di impostare 'encoding' ad utf-8.
Dovrete controllare se questi comandi funzionano davvero con la vostra installazione.
Potrebbe funzionare particolarmente bene usando un metodo di input per una lingua asiatica, e volete scrivere del testo in Unicode.

<p>

<p>
USARE UNICODE IN UN TERMINALE UNICODE
<p>
Esistono terminali che supportano Unicode direttamente.
Lo standard xterm che viene con Xfree è uno di essi.
Usiamolo come esempio.
Prima di tutto, xterm deve essere compilato con il supporto ad Unicode.
Guardate |UTF8-xterm| per sapere come controllare ciò e come compilarlo in caso di necessità.
Avviate xterm con l'argomento "-u8".
Potreste anche avere bisogno di specificare un font.
Esempio: >
<p>
xterm -u8 -fn -misc-fixed-medium-r-normal--18-120-100-100-c-90-iso10646-1
<p>
Ora potete avviare Vim entro questo terminale.
Impostate 'encoding' ad 'utf-8' come prima.
E questo è tutto.
<p>

<p>
USARE UNICODE IN UN TERMINALE NORMALE
<p>
Supponiamo che vogliate lavorare con dei file Unicode, ma non abbiate un terminale con lo supporti.
Potete fare ciò con Vim, tuttalpiù i caratteri non supportati dal terminale non verranno visualizzati.
L'aspetto del testo verrà preservato.
>
<p>
:let &termencoding = &encoding 	:set encoding=utf-8
<p>
Questo è lo stesso che era stato usato per la GUI.
Ma funziona diversamente: Vim convertirà il testo visualizzato prima di inviarlo al terminale.
Ciò evita che il display visualizzi strani caratteri.
Affinché ciò funzioni è necessario che la conversione tra 'termencoding' ed 'encoding' sia possibile.
Vim convertirà da latin1 ad Unicode, cosicché funzioni sempre.
Per altre conversioni è richiesta la caratteristica |+iconv|.
Provate a modificare un file con caratteri Unicode.
Noterete che Vim mette un punto interrogativo (oppure una sottolineatura o qualche altro carattere) nei posti dove c'è un carattere che il terminale non può visualizzare.
Muovete il cursore sino al punto interrogativo ed usate questo comando: >
<p>
ga
<p>
Vim visualizzerà una linea con il codice del carattere.
Ciò vi da un'idea di che carattere sia.
Potrete poi trovarlo in una tabella Unicode.
Potreste realmente leggere un file in questo modo se aveste molto tempo a disposizione.
<p>
Note: 	Poiché 'encoding' è usato per tutto il testo entro Vim, modificarlo 	invaliderebbe tutto il testo non ASCII.
Potete notare ciò usando i 	registri ed il file 'viminfo' (ad esempio, un modello di ricerca 	memorizzato).
Si raccomanda perciò di impostare 'encoding' nel vostro 	file vimrc, e lasciarlo stare.
============================================================================== *45.4*	Elaborare file con una codifica differente Supponete di avere impostato Vim per l'uso di Unicode e che vogliate modificare un file Unicode a 16 bit.
Sembra semplice, giusto? Bene, Vim in realtà usa internamente la codifica utf-8, perciò la codifica a 16 bit deve essere convertita, poiché c'è una differenza tra il set di caratteri (Unicode) e la codifica (utf-8 o 16 bit).
Vim cercherà di individuare il tipo di file con il quale state lavorando.
Esso usa nomi di codifica situati nell'opzione 'fileencodings'.
Quando si usa Unicode, il valore standard è:"ucs-bom,utf-8,latin1".
Ciò significa che Vim controlla il file per vedere se contiene una di queste codifiche:
<p>
ucs-bom		Il file deve iniziare con un 'Byte Order Mark (BOM)'.
Ciò consente la rilevazione delle codifiche unicode a 			16 bit, 32 a bit ed utf-8
<p>
utf-8		utf-8 unicode.
E' rifiutata quando una sequenza di 			byte è illegale in utf-8.

<p>
latin1		La vecchia codifica ad 8-bit.
Funziona sempre.
<p>
Quando iniziate a lavorare su un file Unicode a 16 bit, nel quale è presente un BOM, Vim individua ciò e converte il file in utf-8 quando lo legge.
L'opzione 'fileencoding' (senza la s finale) è impostata al valore individuato.
In questo caso è "utf-16le".
Ciò significa Unicode, due byte e un 'little-endian'.
Questo formato di file è comune in MS-Windows, (ad esempio per i file di registro).
Quando si scrive un file, Vim confronta 'fileencoding' con 'encoding'.
Se sono differenti, il testo sarà convertito.
Un valore nullo in 'fileencoding' significa che nessuna conversione deve essere eseguita.

<p>
Se il valore di 'fileencodings' di default non andasse bene per voi, allora impostatelo per le codifiche che volete che Vim tenti.
Solo quando un valore venisse trovato non valido verrebbe usato quello successivo.
Impostare "latin1" come primo non funziona, perché non è mai illegale.
Un esempio, per tornare al giapponese quando il file non ha un BOM e non è utf-8: >
<p>
:set fileencodings=ucs-bom,utf-8,sjis
<p>
Vedere |encoding-values| per i valori suggeriti.
Altri valori potrebbero funzionare altrettanto bene.
Ciò dipende dal tipo di conversione disponibile.
<p>

<p>
FORZARE UNA CODIFICA
<p>
Se il rilevamento automatico non funzionasse, dovrete dire a Vim quale codifica sia usata dal file.
Esempio: >
<p>
:edit ++enc=koi8-r russian.txt
<p>
La parte "++enc" specifica il nome della codifica da usare solamente per questo file.
Vim convertirà il file dalla codifica specificata, il russo in questo esempio, in 'enconding'.
'fileencoding' verrà così impostato per la codifica specificata, cosicché la conversione inversa può essere fatta quando si scrive il file.
Lo stesso argomento può essere utilizzato scrivendo un file.
In tal modo potete realmente usare Vim per convertire un file.
Esempio: >
<p>
:write ++enc=utf-8 russian.txt < 	Note: 	La conversione può causare una perdita di caratteri.
Convertire da 	una codifica qualsiasi in Unicode e viceversa è generalmente libera 	da questi problemi, a meno che ci siano caratteri illegali.
La 	conversione da Unicode in altre codifiche spesso perde informazioni 	quando ci sia più di un linguaggio nel file.

<p>

<p>
============================================================================== *45.5*	Impostare la lingua del testo
<p>
Le tastiere dei computer non hanno più di un centinaio di tasti.
Alcune lingue hanno un centinaio di caratteri, Unicode ne ha più di 10000.
Così come potete digitare questi caratteri? Prima di tutto, quando non usate troppi caratteri speciali, potete usare i digrami.
Questo argomento è già stato spiegato in |24.9|.
Quando utilizzate una lingua che usa molti più caratteri di quanti ne abbia la vostra tastiera, vorrete usare un Input Method (IM).
Ciò richiede di imparare la traduzione dai tasti digitati ai caratteri risultanti.
Quando vi serve un IM, ne avrete probabilmente già uno installato nel vostro sistema.
Potrebbe funzionare con Vim come con altri programmi.
Per i dettagli vedere |mbyte-XIM| per il sistema XWindow e |mbyte-IME| per MS-Windows.

<p>

<p>
KEYMAP
<p>
Per alcune lingue, il set di caratteri è diverso da quello latino, ma impiega un numero simile di caratteri.
E' perciò possibile mappare i tasti ai caratteri.
Vim utilizza le 'keymap' per questo.
Supponete di voler scrivere in ebraico.
Potete caricare la keymap così: > 	:set keymap=hebrew Vim cercherà di trovare un file di keymap per voi.
Ciò dipende dal valore di "encoding".
Se nessun file corrispondente venisse trovato, otterreste un messaggio di errore.

<p>
Ora potete digitare in ebraico in Insert mode.
In Normal mode e quando digitate un comando ":", Vim automaticamente passerà all'inglese.
Potete usare questo comando per passare dall'ebraico all'inglese: >
<p>
CTRL-^
<p>
Questo funziona solo in Insert mode e in Comand-line mode.
In Normal mode fa qualcosa di completamente diverso (salta ad un altro file).
L'uso della keymap è indicato nel messaggio della modalità, se avete l'opzione 'showmode' attivata.
Nella gui Vim indicherà l'uso delle keymap con un colore diverso del cursore.
Potete anche cambiare l'uso della keymap con le opzioni 'iminsert' e 'imsearch'.

<p>
Per vedere la lista delle mappature, usate questo comando : >
<p>
:lmap
<p>
Per trovare quali file di keymap siano disponibili, nella GUI potete usare il menù Edit/Keymap.
Altrimenti potete usare questo comando: >
<p>
:echo globpath(&rtp, "keymap/*.vim")
<p>

<p>
CREARE DA SOLI LE KEYMAP
<p>
Potete creare da soli i vostri file di keymap.
Non è particolarmente difficile.
Iniziate con un file di keymap simile a quello della lingua che volete impiegare.
Copiatelo nella cartella "keymap" nella vostra directory di runtime.
Ad esempio, in Unix potreste usare la cartella "~/.vim/keymap".
Il nome del file di keymap deve assomigliare a questo:
<p>
keymap/{nome}.vim ~
<p>
oppure
<p>
keymap/{nome}_{encoding}.vim ~
<p>
{nome} è il nome della keymap.
Scegliete un nome che sia ovvio, ma differente dalle keymap esistenti (a meno che non vogliate sostituire un file di keymap esistente).
{nome} non può contenere un underscore.
Volendo, aggiungete la codifica usata dopo un underscore.
Esempi:
<p>
keymap/hebrew.vim ~ 	keymap/hebrew_utf-8.vim ~
<p>
I contenuti del file dovrebbero spiegarsi da sé.
Guardate qualcuna delle keymap distribuite con VIM.
Per i dettagli, vedere |mbyte-keymap|.
<p>
ULTIMA RISORSA
<p>
Se tutti gli altri metodi fallissero, potrete comunque inserire qualsiasi carattere con CTRL-V:
<p>
encoding type			range ~ 	8-bit	 CTRL-V 123		decimal 0-255 	8-bit	 CTRL-V x a1		hexadecimal 00-ff 	16-bit CTRL-V u 013b	hexadecimal 0000-ffff 	31-bit	 CTRL-V U 001303a4	hexadecimal 00000000-7fffffff
<p>
Non digitate gli spazi.
Vedere |i_CTRL-V_digit| per i dettagli.
<p>
==============================================================================
<p>
Capitolo seguente: |usr_90.txt| Installare Vim
<p>
Copyright: vedere |manual-copyright| vim:tw=78:ts=8:ft=help:norl:
<p>
*usr_90.txt*	Per Vim version 7.2.
Ultima modifica: 2008 Set 10
<p>
VIM USER MANUAL - di Bram Moolenaar 				Installare Vim
<p>
*install* Prima di poter utilizzare Vim è necessario installarlo.
Dipende dal vostro sistema se essa sia semplice o facile.
Questo capitolo fornisce alcuni suggerimenti e spiega inoltre come vada fatto l'aggiornamento del programma ad una nuova versione.

<p>
|90.1|	Unix |90.2|	MS-Windows |90.3|	Aggiornamento |90.4|	Problemi comuni di installazione |90.5|	Disinstallare Vim
<p>
Capitolo precedente: |usr_45.txt| Selezionate la vostra lingua 	 Indice: |usr_toc.txt|
<p>
============================================================================== *90.1*	Unix
<p>
Per prima cosa dovrete decidere se state installando Vim per tutto il sistema o per un solo utente.
La procedura è quasi la stessa, ma la directory dove Vim viene installato è diversa.
In una installazione per tutto il sistema la directory di partenza "/usr/local/" viene spesso utilizzata.
Ma ciò può variare per il vostro sistema.
Cercate di trovare dove sono installati altri pacchetti.
Quando installate per un solo utente, potete utilizzare la vostra directory "home".
I file saranno collocati in sottodirectory quali "bin" e "shared/vim".

<p>

<p>
DA UN PACCHETTO
<p>
Potete ottenere i binari precompilati per molti sistemi UNIX diversi.
C'è una lunga lista con i link su questa pagina:
<p>
http://www.vim.org/binaries.html ~
<p>
Dei volontari mantengono i binari, così questi sono spesso poco aggiornati.
E' una buona idea compilare la propria versione UNIX utilizzando i sorgenti.
Così, la creazione dell'editor dal sorgente vi consente di controllare quali siano le caratteristiche da compilare.
Tuttavia ciò richiede un compilatore.
<p>
Se utilizzate una distribuzione Linux, il programma "vi" è probabilmente una versione minimale di Vim.
Non esegue l'evidenziazione della sintassi, ad esempio.
Cercate di trovare un altro pacchetto Vim nella vostra distribuzione, o cercate sul sito Web.

<p>

<p>
DAI SORGENTI
<p>
Per compilare ed installare Vim, avrete bisogno di:
<p>
- Un compilatore C (GCC di preferenza) 	- Il programma GZIP (potete ottenerlo su www.gnu.org) 	- I sorgenti Vim e gli archivi runtime
<p>
Per ottenere gli archivi Vim, cercate in questo file un mirror vicino a voi, consentirà il più veloce dei download:
<p>
ftp://ftp.vim.org/pub/vim/MIRRORS ~
<p>
Od utilizzate l'home site ftp.vim.org se pensate sia veloce abbastanza.
Andate alla directory "unix" e lì troverete un elenco di file.
Il numero di versione è dentro al nome del file.
Prenderete la versione più recente.
Potete ottenere i file per UNIX in due modi: Un grande archivio contenente tutto, oppure quattro archivi più piccoli ognuno dei quali può essere contenuto in un floppy disk.
Per la versione 6.1 l'unico grosso è denominato:
<p>
vim-6.1.tar.bz2 ~
<p>
Avrete bisogno del programma bzip2 per decomprimerlo.
Se non lo avete, prendete i quattro file più piccoli, che possono essere decompressi con gzip.
Per Vim 6.1 essi si chiamano:
<p>
vim-6.1-src1.tar.gz ~ 	vim-6.1-src2.tar.gz ~ 	vim-6.1-rt1.tar.gz ~ 	vim-6.1-rt2.tar.gz ~
<p>

<p>
COMPILARE
<p>
Prima create una directory di partenza dove lavorare, ad esempio: >
<p>
mkdir ~/vim 	cd ~/vim
<p>
Qui ora decomprimete gli archivi.
Se avete l'unico grosso archivio, lo potete decomprimere in questo modo: >
<p>
bzip2 -d -c path/vim-6.1.tar.bz2 | tar xf -
<p>
Sostituite "path" con il percorso della directory dove avete scaricato i file.

<p>
gzip -d -c path/vim-6.1-src1.tar.gz | tar xf - 	gzip -d -c path/vim-6.1-src2.tar.gz | tar xf - 	gzip -d -c path/vim-6.1-rt1.tar.gz | tar xf - 	gzip -d -c path/vim-6.1-rt2.tar.gz | tar xf -
<p>
Se siete soddisfatti delle impostazioni di default ed il vostro ambiente è installato correttamente, dovreste poter compilare Vim solo con: >
<p>
cd vim61/src 	make
<p>
Il programma make configurerà e compilerà ogni cosa.
In seguito spiegheremo come compilare usando altre impostazioni.
Se ci fossero problemi nella compilazione, esaminate attentamente i messaggi di errore.
Lì dovrebbero esserci le spiegazioni di cosa sia andato male.
Con la speranza di riuscire a correggerli.
Potreste dover disabilitare alcune caratteristiche per essere far compilare Vim.
Controllate nel Makefile i suggerimenti specifici per il vostro sistema.
<p>

<p>
TEST
<p>
Ora potete provare se la compilazione abbia funzionato: >
<p>
make test
<p>
Ciò avvierà una serie di script di verifica per controllare che Vim funzioni come ci si aspetta.
Vim verrà avviato diverse volte ed apparirà ogni genere di testo o di messaggio.
Se tutto va bene alla fine vedrete:
<p>
test results: ~ 	ALL DONE ~
<p>
Se ottenete "TEST FAILURE", alcuni dei testi sono andati male.
Se ci sono uno o due messaggi di testi andati male, Vim potrebbe ancora funzionare, ma non perfettamente.
Se vedere una quantità di errori o Vim non arriva alla fine della sequenza di test, ci dev'essere qualcosa di sbagliato.
Potete provare a risolvere il problema da soli, o trovare qualcuno che possa risolverlo.
Potreste guardare in |maillist-archive| per trovare una soluzione.
Se ogni vostro tentativo va a vuoto potete chiedere sulla |maillist| di Vim se qualcuno può aiutarvi.

<p>

<p>
INSTALLAZIONE 							*install-home* Se volete installare nella vostra directory home, modificate il Makefile e cercate una linea
<p>
prefix = $(HOME) ~
<p>
Rimuovete la # all'inizio della linea.
Quando installate per l'intero sistema, Vim avrà molto probabilmente già scelto una buona directory di installazione per voi.
Potete anche specificarne una, guardate sotto.
Dovrete diventare root per quanto segue.
<p>
Per installare Vim digitate: >
<p>
make install
<p>
Ciò dovrebbe collocare tutti i file importanti al giusto posto.
Ora potete provare ad avviare vim per verificare che funzioni.
Usate due semplici test per accertarvi che Vim trovi i propri file di runtime: >
<p>
:help 	:syntax enable
<p>
Se non dovesse funzionare, usate questo comando per verificare dove Vim ricerchi i propri file di runtime: >
<p>
:echo $VIMRUNTIME
<p>
Potete anche avviare Vim con l'argomento "-V" per sapere ciò che accade all'avvio: >
<p>
vim -V
<p>
Non dimenticate che il manuale utente presuppone che usiate Vim in un certo modo.
Dopo aver installato Vim, seguite le istruzioni in |not-compatible| per far funzionare Vim come spiegato in questo manuale.

<p>

<p>
SELEZIONARE LE CARATTERISTICHE
<p>
Vim offre diversi modi per scegliere le che.
Uno dei più semplici consiste nel modificare il Makefile.
Ci sono molti suggerimenti ed esempi al riguardo.
Spesso potete abilitare o disabilitare una caratteristica eliminando il commento ad una linea.
Un'alternativa è di avviare separatamente "configure".
Ciò vi consente di specificare le opzioni di configurazione manualmente.
Lo svantaggio consiste nella necessità di dover riuscire a capire esattamente cosa digitare.
Seguono alcuni degli argomenti di configurazione più interessanti.
Essi possono anche venir abilitati dal Makefile.

<p>
--prefix={directory}		Cartella dove installare Vim.

<p>
--with-features=tiny		Compila con molte impostazioni 					disabilitate.
--with-features=small		Compila con molte impostazioni 					disabilitate.
--with-features=big		Compila con più impostazioni 					abilitate.
--with-features=huge		Compila con ulteriori impostazioni 					abilitate.

<p>
Vedere la |+feature-list| per sapere 					quali impostazioni vengono abilitate 					nei diversi casi.

<p>
--enable-perlinterp		Abilita l'interfaccia Perl.
Esistono 					impostazioni simili per ruby, python 					e tcl.

<p>
--disable-gui			Non compila l'interfaccia GUI.
--without-x			Non compila le caratteristiche della 					X-Windows.
Quando entrambi gli argomenti sono 					utilizzati, Vim non si connette al 					server X, il che rende l'avvio più 					veloce.

<p>
Per vedere l'intera lista usate: >
<p>
./configure -help
<p>
Potete trovare un pò di spiegazioni per ciascuna caratteristica e link per ulteriori informazioni qui: |feature-list|.
Per gli audaci: modificate il file "feature.h".
Potete anche modificare il codice sorgente!
<p>
============================================================================== *90.2*	MS-Windows
<p>
Ci sono due modi per installare Vim per Microsoft Windows.
Potete decomprimere diversi archivi, oppure utilizzare un grosso archivio autoinstallante.
Molti utenti dotati di computer recenti preferiscono il secondo metodo.
Per il primo avrete bisogno di:
<p>
- Un archivio con i binari di Vim.
- L'archivio di runtime di Vim.
- un programma per decomprimere i file zip.

<p>
Per ottenere gli archivi Vim, cercate in questo file il mirror più vicino a voi, garantirà un download più veloce:
<p>
ftp://ftp.vim.org/pub/vim/MIRRORS ~
<p>
Oppure potete utilizzare il sito ftp.vim.org, se per voi è abbastanza veloce.
Recatevi nella directory "pc" nella quale troverete un elenco di file.
Il numero di versione è compreso nel nome del file.
Utilizzerete la versione più recente.
Noi utilizzeremo "61" qui, che è la versione 6.1.
<p>
gvim61.exe		L'archivio autoinstallante.

<p>
Ciò è tutto ciò di cui avrete bisogno se optate per il secondo modo.
Lanciate l'eseguibile e seguite i prompt.

<p>
Per il primo metodo dovete scegliere uno degli archivi binari.
Questi sono disponibili:
<p>
gvim61.zip		La normale versione MS-Windows con GUI.
gvim61ole.zip		La versione MS-Windows GUI con supporto OLE.
Richiede più memoria, consente 				l'interfacciamento con altre applicazioni OLE.
vim61w32.zip		La versione console per MS-Windows a 32 bit.
Per l'utilizzo in una console Win NT/2000/XP.
Non funziona bene su Win 95/98.
vim61d32.zip		La versione per MS-DOS a 32 bit.
Per 				l'utilizzo in una console Win 95/98.
vim61d16.zip		La versione per MS-DOS a 16 bit.
Esclusivamente per i sistemi più vecchi.
Non supporta i nomi dei file lunghi.

<p>
Vi serve solo uno di questi.
Tuttavia potete installare sia una versione con GUI che una a console.
Dovrete sempre prendere l'archivio con i propri file di runtime.

<p>
vim61rt.zip		I file di runtime.

<p>
Usate il vostro programma di unzip per decomprimere i file.
Ad esempio, utilizzando il programma "unzip": >
<p>
cd c:\ 	unzip path\gvim61.zip 	unzip path\vim61rt.zip
<p>
Ciò spacchetterà i file nella directory "c:\vim\vim61".
Se avete già una directory "vim", dovrete spostarvi nella directory immediatamente sopra questa.
Ora andate nella directory "vim\vim61" ed avviate il programma di installazione: >
<p>
install
<p>
Guardate con attenzione i messaggi e selezionate le opzioni che intendete utilizzare.
Selezionando "do it" il programma di installazione eseguirà le azioni da voi selezionate.
Il programma di installazione non sposta i file di runtime.
Essi rimangono nella directory dove li avrete decompressi.

<p>
Nel caso non foste soddisfatti delle caratteristiche incluse nei binari, potete provare a compilare Vim voi stessi.
Recuperate l'archivio dei sorgenti dallo stesso posto dove si trovano i binari.
Avrete bisogno di un compilatore per il quale esiste un makefile.
Microsoft Visual C funziona, ma è costoso.
Si può utilizzare il compilatore gratuito a riga di comando Borland 5.5., così come gli altrettanto gratuiti compilatori MingW e Cygwin.
Consultate il file src/INSTALLpc.txt per i suggerimenti.

<p>

<p>

<p>
============================================================================== *90.3*	Aggiornamento
<p>
Se utilizzate una sola versione di Vim e ne volete installare un'altra, ecco cosa fare.

<p>

<p>
UNIX
<p>
Digitando "make install" i file di runtime verranno copiati in una directory specifica per questa versione.
Così non sovrascriveranno una versione precedente.
Ciò rende possibile usare due o più versioni di Vim l'una accanto all'altra.
L'eseguibile "Vim" tuttavia sovrascriverà una versione precedente.
Se non vi interessa mantenere la versione più vecchia, eseguire "make install" andrà bene.
Potete cancellare manualmente i vecchi file di runtime.
Cancellate la directory con il numero di versione del caso e tutti i file in essa.
Ad esempio: >
<p>
rm -rf /usr/local/share/vim/vim58
<p>
Normalmente non ci sono file modificati sotto questa directory.
Se avete modificato il file "filetype.vim", ad esempio, sarà meglio che uniate le modifiche nella nuova versione prima di cancellarla.

<p>
Se siete prudenti e volete provare la nuova versione prima di passare ad essa, installate la nuova versione sotto un altro nome.
Dovrete specificare un argomento di configure.
Ad esempio: >
<p>
./configure --with-vim-name=vim6
<p>
Prima di avviare "make install", potete usare "make -n install" per assicurarvi che nessun file esistente possa venir sovrascritto.
Quando alla fine decidete di passare alla nuova versione, basterà rinominare il file binario in "vim".
Ad esempio: >
<p>
mv /usr/local/bin/vim6 /usr/local/bin/vim
<p>

<p>
MS-WINDOWS
<p>
L'aggiornamento è quasi uguale all'installazione di una nuova versione.
Soltanto decomprimete i file nello stesso luogo della versione precedente.
Una nuova directory verrà creata, ad esempio ,"vim61", per i file della nuova versione.
I vostri file di runtime, i file vimrc, viminfo, etc verranno lasciati stare.
Se volete avviare la nuova versione acanto a quella vecchia, dovrete lavorare un po'.
Non eseguite il programma di installazione, che sovrascriverebbe qualche file della vecchia versione.
Lanciate i nuovi binari specificando il percorso completo.
Il programma dovrebbe rintracciare automaticamente i file di runtime necessari per la versione corretta.
Ad ogni modo, ciò non funzionerebbe se aveste impostato la variabile $VIMRUNTIME da qualche parte.
Se siete soddisfatti dell'aggiornamento, potete cancellare i file della versione precedente.

<p>
Consultate |90.5|.

<p>
============================================================================== *90.4*	Problemi comuni di installazione.

<p>
Questa sezione descrive alcuni problemi comuni che capitano durante l'installazione di Vim e fornisce alcune soluzioni.
Contiene anche delle risposte a molte delle domande sull'installazione.

<p>
Q: Non ho i privilegi di root.
Come posso installare Vim? (Unix)
<p>
Usate il seguente comando di configurazione per installare Vim in una directory chiamata $HOME/vim: >
<p>
./configure -prefix=$HOME
<p>
Ciò vi fornisce una copia personale di Vim.
Dovrete inserire $HOME/bin nel vostro path per eseguire l'editor.
Consultate anche |install-home|.
<p>

<p>
Q: I colori sul mio schermo non sono corretti.
(Unix)
<p>
Controllate le impostazioni del vostro terminale utilizzando il seguente comando in una shell: >
<p>
echo $TERM
<p>
Se il tipo di terminale ottenuto non è va bene, correggetelo.
Per ulteriori suggerimenti consultate |06.2|.
Un'altra soluzione è di usare sempre la versione GUI di VIM, denominata gvim.
Ciò evita la necessità di una corretta installazione del terminale.

<p>

<p>
Q: I miei tasti Backspace e Delete non funzionano correttamente
<p>
La definizione dei codici che i tasti inviano è piuttosto incerta per bs <bs> e Delete <Del>.
Prima di tutto, controllate le impostazioni di $TERM.
Se non c'è nulla di sbagliato, provate questo: >
<p>
:set t_kb=^V<BS> 	:set t_kD=^V<Del>
<p>
Nella prima riga dovrete premere CTRL-V ed in seguito il tasto backspace.
Nella seconda linea dovrete premere CTRL-V e poi il tasto Delete.
Potete inserire queste righe nel vostro file vimrc, consultate |05.1|.
Uno svantaggio è che non funzionerà quando utilizzerete un altro terminale qualche volta.
Guardate qui per soluzioni alternative: |:fixdel|.
<p>

<p>
Q: Uso RedHat Linux.
Posso utilizzare la versione di Vim fornita nel sistema?
<p>
Di default Redhat installa una versione minimale di Vim.
Controllate i vostri pacchetti RPM per reperire "Vim-enhanced-version.rpm" ed installatelo.

<p>

<p>
Q: Come posso attivare la colorazione della sintassi? Come faccio funzionare i plugin?
<p>
Usate lo script di esempio vimrc.
Potete trovare la spiegazione sul suo uso qui: |not-compatible|.

<p>
Vedere il capitolo 6 per le informazioni circa la evidenziazione della sintassi:|usr_06.txt|.

<p>

<p>
Q: Qual è un buon file vimrc da usare?
<p>
Vedere il sito www.vim.org per diversi buoni esempi.

<p>

<p>
Q: Dove trovo un buon plugin per VIM?
<p>
Vedere il sito Vim.online: http://vim.sf.net.
Molti utenti hanno inviato utili script e plugin.

<p>

<p>
Q: Dove posso trovare altri suggerimenti?
<p>
Vedere il sito Vim-online: http://vim.sf.net.
C'è un archivio di suggerimenti per gli utenti di Vim.
Potete anche consultare |maillist-archive|.
<p>
============================================================================== *90.5*	Disinstallare VIM.

<p>
Nell'improbabile ipotesi che vogliate disinstallare Vim completamente, questo è ciò che dovete fare.

<p>
UNIX
<p>
Se avete installato Vim come pacchetto, controllate il vostro gestore dei pacchetti per sapere come rimuoverlo.
Se avete installato vim dai sorgenti potete usare il seguente comando: >
<p>
make uninstall
<p>
Comunque, se avete cancellato i file originali o avete usato un archivio fornitovi da qualcuno, non potete farlo.
Dovrete cancellare i file a mano, di seguito un esempio di con "/usr/local" usato come root: >
<p>
rm -rf /usr/local/share/vim/vim61 	rm /usr/local/bin/eview 	rm /usr/local/bin/evim 	rm /usr/local/bin/ex 	rm /usr/local/bin/gview 	rm /usr/local/bin/gvim 	rm /usr/local/bin/gvim 	rm /usr/local/bin/gvimdiff 	rm /usr/local/bin/rgview 	rm /usr/local/bin/rgvim 	rm /usr/local/bin/rview 	rm /usr/local/bin/rvim 	rm /usr/local/bin/rvim 	rm /usr/local/bin/view 	rm /usr/local/bin/vim 	rm /usr/local/bin/vimdiff 	rm /usr/local/bin/vimtutor 	rm /usr/local/bin/xxd 	rm /usr/local/man/man1/eview.1 	rm /usr/local/man/man1/evim.1 	rm /usr/local/man/man1/ex.1 	rm /usr/local/man/man1/gview.1 	rm /usr/local/man/man1/gvim.1 	rm /usr/local/man/man1/gvimdiff.1 	rm /usr/local/man/man1/rgview.1 	rm /usr/local/man/man1/rgvim.1 	rm /usr/local/man/man1/rview.1 	rm /usr/local/man/man1/rvim.1 	rm /usr/local/man/man1/view.1 	rm /usr/local/man/man1/vim.1 	rm /usr/local/man/man1/vimdiff.1 	rm /usr/local/man/man1/vimtutor.1 	rm /usr/local/man/man1/xxd.1
<p>

<p>
MS-WINDOWS
<p>
Altrimenti, se avete installato Vim con l'archivio auto-installante potete avviare il programma "uninstall-gui" situato nella stessa directory degli altri programmi di Vim, ad esempio "c:\vim\vim61".
Potete anche lanciarlo dal menù start se vi avete installato i collegamenti a Vim.
Ciò rimuoverà la maggior parte dei file, voci nei menù e collegamenti sul desktop.
Alcuni file possono rimanere comunque in quanto richiedono il riavvio di Windows prima di essere cancellati.
Vi sarà data la possibilità di rimuovere l'intera directory di Vim.
Essa probabilmente conterrà il vostro file vimrc ed altri file di runtime che avrete creato, perciò state attenti.

<p>
Se avete installato Vim dagli archivi zip, il metodo migliore è utilizzare il programma "uninstal" (notate la mancanza della "l" alla fine).
Potete trovarlo nella stessa directory del programma "install", ad esempio "c:\vim\vim61".
Ciò potrebbe funzionare anche dalla solita pagina "install/remove software".
Ad ogni modo, ciò rimuove solo le voci del registro relative a Vim.
Dovrete poi cancellare i file a mano.
Selezionate semplicemente la directory "vim\vim61" e cancellateli ricorsivamente.
Non ci dovrebbero essere file modificati da voi, ma potreste voler controllare ciò prima.
La directory "vim" probabilmente contiene il vostro file vimrc ed altri file di runtime da voi creati.
Potreste volerli conservare.
<p>
==============================================================================
<p>
Indice: |usr_toc.txt|
<p>
Copyright: vedere |manual-copyright| vim:tw=78:ts=8:ft=help:norl:
<p>
Per segnalazioni scrivere a vimdoc.it at gmail dot com oppure ad Antonio Colombo azc100 at gmail dot com *usr_toc.txt*	Per Vim version 7.2.
Ultima modifica: 2006 Apr 24
<p>
VIM USER MANUAL - di Bram Moolenaar 	 Traduzione di questo capitolo: Bartolomeo Ravera
<p>
Indice			*user-manual*
<p>
============================================================================== Panoramica ~
<p>
Per iniziare |usr_01.txt| Sui manuali |usr_02.txt| I primi passi con Vim |usr_03.txt| Muoversi nel file |usr_04.txt| Fare piccole modifiche |usr_05.txt| Configurazioni personali |usr_06.txt| Usare l'evidenziazione della sintassi |usr_07.txt| Elaborare più di un file |usr_08.txt| Dividere le finestre |usr_09.txt| Usare la GUI |usr_10.txt| Fare grandi modifiche |usr_11.txt| Recupero dopo un blocco |usr_12.txt| Trucchi ingegnosi
<p>
Editare efficacemente |usr_20.txt| Immissione rapida dei comandi sulla linea di comando |usr_21.txt| Andarsene e ritornare |usr_22.txt| Trovare il file da aprire |usr_23.txt| Modifica di altri file |usr_24.txt| Inserzione rapida |usr_25.txt| Lavorare con testo formattato |usr_26.txt| Ripetizione |usr_27.txt| Comandi di ricerca ed espressioni |usr_28.txt| La piegatura |usr_29.txt| Spostarsi attraverso i programmi |usr_30.txt| Editare programmi |usr_31.txt| Sfruttare la GUI |usr_32.txt| L'albero degli undo
<p>
Messa a punto di Vim |usr_40.txt| Definire nuovi comandi |usr_41.txt| Preparare uno script Vim |usr_42.txt| Aggiungere nuovi menù |usr_43.txt| Utilizzo dei tipi di file |usr_44.txt| Evidenziazione della vostra sintassi |usr_45.txt| Selezionate la vostra lingua
<p>
Far girare Vim |usr_90.txt| Installare Vim
<p>
Manuale di riferimento |reference_toc| Informazioni più dettagliate su tutti i comandi
<p>
Il manuale utente inglese è disponibile in un unico file HTML e PDF, pronto per la stampa, a questo indirizzo: 	http://vimdoc.sf.net
<p>
============================================================================== Per iniziare ~
<p>
Leggetelo dall'inizio alla fine per apprendere i comandi essenziali.

<p>
|usr_01.txt| Sui manuali 		|01.1|	Due manuali 		|01.2|	A Vim installato 		|01.3|	Usare il tutor di Vim 		|01.4|	Copyright
<p>
|usr_02.txt| I primi passi con Vim 		|02.1|	Avviare Vim la prima volta 		|02.2|	Inserire del testo 		|02.3|	Spostarsi attraverso il file 		|02.4|	La cancellazione di caratteri 		|02.5|	Undo e Redo 		|02.6|	Altri comandi 		|02.7|	Come uscire 		|02.8|	Trovare un aiuto
<p>
|usr_03.txt| Muoversi nel file 		|03.1|	Movimenti di parola 		|03.2|	Spostarsi all'inizio o alla fine di una riga 		|03.3|	Spostarsi verso un carattere 		|03.4|	Spostarsi sulla parentesi corrispondente 		|03.5|	Spostarsi sulla linea desiderata 		|03.6|	Sapere dove siete 		|03.7|	Paginazione 		|03.8|	Ricerche semplici 		|03.9|	Modelli semplici di ricerca 		|03.10|	Marcare il testo
<p>
|usr_04.txt| Fare piccole modifiche 		|04.1|	Operatori e spostamenti 		|04.2|	Cambiare il testo 		|04.3|	Ripetere un cambiamento 		|04.4|	Modo Visual 		|04.5|	Muovere il testo 		|04.6|	Copiare il testo 		|04.7|	Usare la clipboard 		|04.8|	Oggetti di testo 		|04.9|	Modo Replace 		|04.10|	Conclusioni
<p>
|usr_05.txt| Configurazioni personali 		|05.1|	Il file vimrc 		|05.2|	Spiegazione del file vimrc di esempio 		|05.3|	Semplici mappature 		|05.4|	Aggiungere un plugin 		|05.5|	Aggiungere un file di Aiuto 		|05.6|	La finestra delle opzioni 		|05.7|	Le opzioni più usate
<p>
|usr_06.txt| Usare l'evidenziazione della sintassi 		|06.1|	Abilitare l'evidenziazione 		|06.2|	Nessun colore o colori sbagliati? 		|06.3|	Colori diversi 		|06.4|	Con o senza i colori 		|06.5|	Stampare a colori 		|06.6|	Ulteriori letture
<p>
|usr_07.txt| Elaborare più di un file 		|07.1|	Elaborare un altro file 		|07.2|	Una lista di file 		|07.3|	Saltare da file a file 		|07.4|	File di backup 		|07.5|	Copiare testo tra più file 		|07.6|	Visualizzare un file 		|07.7|	Rinominare un file
<p>
|usr_08.txt| Dividere le finestre 		|08.1| Dividere una finestra 		|08.2| Dividere una finestra aprendo un altro file 		|08.3| Dimensioni della finestra 		|08.4| Tagli verticali 		|08.5| Muovere le finestre 		|08.6| Comandi per tutte le finestre 		|08.7| Evidenziare le differenze con vimdiff 		|08.8| Varie ed eventuali 		|08.9| Linguette
<p>
|usr_09.txt| Usare la GUI 		|09.1|	Parti dell'interfaccia grafica (GUI) 		|09.2|	Usare il mouse 		|09.3|	Appunti (clipboard) 		|09.4|	Selezioni (Modo Select)
<p>
|usr_10.txt| Fare grandi modifiche 		|10.1| Registrare e rieseguire comandi 		|10.2| Sostituzione 		|10.3| Intervallo di esecuzione dei comandi 		|10.4| Il comando global 		|10.5| Modo Visual block 		|10.6| Leggere e scrivere parte di un file 		|10.7| Formattare un testo 		|10.8| Cambiare Maiuscole/minuscole 		|10.9| Usare un programma esterno
<p>
|usr_11.txt| Recupero dopo un blocco 		|11.1|	Fondamenti del recupero 		|11.2|	Dove si trova il file di swap? 		|11.3|	Bloccato o no? 		|11.4|	Altre letture
<p>
|usr_12.txt| Trucchi ingegnosi 		|12.1|	Sostituzione di una parola 		|12.2|	Modifica di "Last, First" in "First Last" 		|12.3|	Ordinamento di un elenco 		|12.4|	Inversione dell'ordine delle righe 		|12.5|	Conteggio di parole 		|12.6|	Ricerca di una pagina man 		|12.7|	Eliminazione di spazi vuoti 		|12.8|	Ricerca di una parola all'interno di un file
<p>
============================================================================== Editare efficacemente ~
<p>
Capitoli che possono essere letti indipendentemente.

<p>
|usr_20.txt| Immissione rapida dei comandi sulla linea di comando 		|20.1|	Elaborazione della linea di comando 		|20.2|	Abbreviazioni dei comandi 		|20.3|	Completamento automatico dei comandi 		|20.4|	Cronologia dei comandi 		|20.5|	Finestra della linea di comando
<p>
|usr_21.txt| Andarsene e ritornare 		|21.1|	Sospendere e ripristinare 		|21.2|	Eseguire comandi della shell 		|21.3|	Memorizzare le informazioni; viminfo 		|21.4|	Sessioni 		|21.5|	Viste 		|21.6|	Modeline
<p>
|usr_22.txt| Trovare il file da aprire 		|22.1|	Il file browser 		|22.2|	La directory corrente 		|22.3|	Trovare un file 		|22.4|	La lista dei buffer
<p>
|usr_23.txt| Modifica di altri file 		|23.1|	File DOS, Mac e Unix 		|23.2|	File su internet 		|23.3|	File cifrati 		|23.4|	File binari 		|23.5|	File compressi
<p>
|usr_24.txt| Inserzione rapida 		|24.1|	Effettuare correzioni 		|24.2|	Evidenziare le corrispondenze 		|24.3|	Completamento 		|24.4|	Ripetizione ed inserimento 		|24.5|	Copiare da un'altra linea 		|24.6|	Inserire un registro 		|24.7|	Abbreviazioni 		|24.8|	Scrittura di caratteri speciali 		|24.9|	I digrammi 		|24.10|	Comandi in modo Normal
<p>
|usr_25.txt| Lavorare con testo formattato 		|25.1|	Interrompere le linee 		|25.2|	Allineare il testo 		|25.3|	Rientro e tabulazione 		|25.4|	Trattare le linee lunghe 		|25.5|	Elaborare tabelle
<p>
|usr_26.txt| Ripetizione 		|26.1|	Ripetizioni in modo Visual 		|26.2|	Aggiungere e sottrarre 		|26.3|	Fare una modifica in più file 		|26.4|	Usare Vim in uno shell script
<p>
|usr_27.txt| Comandi di ricerca ed espressioni 		|27.1|	Ignorare le differenze tra i caratteri 			maiuscoli e minuscoli 		|27.2|	Aggirare (nella ricerca) la fine del file 		|27.3|	Scostamento 		|27.4|	Effettuare più volte la ricerca 		|27.5|	Alternative 		|27.6|	Intervalli di caratteri 		|27.7|	Classi di caratteri 		|27.8|	Ricerca di interruzioni di linea 		|27.9|	Esempi
<p>
|usr_28.txt| La piegatura 		|28.1|	Che vuol dire piegatura? 		|28.2|	Piegatura manuale 		|28.3|	Lavorare con le piegature 		|28.4|	Salvataggio e ripristino delle piegature 		|28.5|	Piegature secondo i rientri 		|28.6|	Piegature mediante marker 		|28.7|	Piegature secondo la sintassi 		|28.8|	Piegature secondo espressione 		|28.9|	Piegatura delle linee non modificate 		|28.10| Quale metodo di piegatura usare?
<p>
|usr_29.txt| Spostarsi attraverso i programmi 		|29.1|	Usare i tag 		|29.2|	La finestra di anteprima 		|29.3|	Muoversi all'interno di un programma 		|29.4|	Trovare identificatori globali 		|29.5|	Trovare identificatori locali
<p>
|usr_30.txt| Editare programmi 		|30.1|	Compilazione 		|30.2|	Rientro dei file in C 		|30.3|	Rientro automatico 		|30.4|	Altri rientri 		|30.5|	Tabulazioni e spazi 		|30.6|	Formattazione dei commenti
<p>
|usr_31.txt| Sfruttare la GUI 		|31.1|	Il Navigatore 		|31.2|	Conferme 		|31.3|	Scelte rapide 		|31.4|	Posizione e dimensione della finestra 		|31.5|	Varie
<p>
|usr_32.txt| L'albero degli undo 		|32.1|	Numerazione modifiche 		|32.2|	Percorrere la storia delle modifiche 		|32.3|	Viaggiare nel tempo
<p>
============================================================================== Messa a punto di Vim ~
<p>
Fate funzionare Vim come volete voi.

<p>
|usr_40.txt| Definire nuovi comandi 		|40.1|	Mappatura dei tasti 		|40.2|	Definizione di comandi da linea di comando 		|40.3|	Autocomandi
<p>
|usr_41.txt| Preparare uno script Vim 		|41.1|	Introduzione 		|41.2|	Variabili 		|41.3|	Espressioni 		|41.4|	Condizioni 		|41.5|	Esecuzione di una espressione 		|41.6|	Utilizzo funzioni 		|41.7|	Definizione funzioni 		|41.8|	Liste e Dizionari 		|41.9|	Eccezioni 		|41.10|	Osservazioni varie 		|41.11|	Scrivere un plugin 		|41.12|	Scrivere un plugin per un tipo_file 		|41.13|	Scrivere un plugin per un compilatore 		|41.14|	Scrivere un plugin veloce a caricarsi 		|41.15|	Scrivere librerie di script 		|41.16|	Distribuzione di script Vim
<p>
|usr_42.txt| Aggiungere nuovi menù 		|42.1|	Introduzione 		|42.2|	Comandi dei menù 		|42.3|	Varie 		|42.4|	Toolbar ed i menù popup
<p>
|usr_43.txt| Utilizzo dei tipi di file 		|43.1|	Plugin per un tipo di file 		|43.2|	Aggiunta di un tipo di file
<p>
|usr_44.txt| Evidenziazione della vostra sintassi 		|44.1|	Fondamentali comandi della sintassi 		|44.2|	Parole chiave 		|44.3|	Raffronti 		|44.4|	Regioni 		|44.5|	Elementi annidati 		|44.6|	Seguendo i gruppi 		|44.7|	Altri argomenti 		|44.8|	Cluster 		|44.9|	Inserimento di un altro file di sintassi 		|44.10|	Sincronizzazione 		|44.11|	Installare un file di sintassi 		|44.12|	Aspetto di un file di sintassi portatile
<p>
|usr_45.txt| Selezionate la vostra lingua 		|45.1|	Lingua per i messaggi 		|45.2|	Lingua per i menù 		|45.3|	Utilizzare un'altra codifica 		|45.4|	Elaborare file con una codifica differente 		|45.5|	Impostare la lingua del testo
<p>
============================================================================== Far girare Vim ~
<p>
Prima che possiate usare Vim.

<p>
|usr_90.txt| Installare Vim 		|90.1|	Unix 		|90.2|	MS-Windows 		|90.3|	Aggiornamento 		|90.4|	Problemi comuni di installazione 		|90.5|	Disinstallare Vim
<p>
==============================================================================
<p>
La versione italiana del "Vim User Manual" è stata tradotta da un gruppo di volontari coordinati da Bartolomeo Ravera.

<p>
Grazie per il loro aiuto agli amici di Ianua, di Pluto e del SannioLug.

<p>
Un ringraziamento particolare va agli infaticabili Giuliano Bordonaro e Antonio Colombo.

<p>
Copyright: vedere |manual-copyright| vim:tw=78:ts=8:ft=help:norl:
